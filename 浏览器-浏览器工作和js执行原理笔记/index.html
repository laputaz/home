<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8" />
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui"
  />
  <meta name="renderer" content="webkit" />
  <meta
    name="theme-color"
    content="#9f8113"
    media="(prefers-color-scheme: light)"
  />
  <meta
    name="theme-color"
    content="#9f8113"
    media="(prefers-color-scheme: dark)"
  />
  <meta name="theme-color" content="#9f8113" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="referrer" content="no-referrer" />
  <meta name="format-detection" content="telephone=no,email=no,adress=no" />
  <!-- Color theme for statusbar -->
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
   
  <title>
    浏览器：浏览器工作原理笔记 | laputa z
  </title>
  <meta name="description" content="最近看了浏览器原理，这里记录一下细节。浏览器原理可以把一系列知识串联起来。">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器：浏览器工作原理笔记">
<meta property="og:url" content="https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="River">
<meta property="og:description" content="最近看了浏览器原理，这里记录一下细节。浏览器原理可以把一系列知识串联起来。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4869de48dca84c0299e9efb0848ebd51.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6aOe6amw55qE5Zyw6ZOB,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d2477a4651de44d29525a172045e04d3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e752c6e79e4440b68cefecd19f44c15f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7b6849e77df34127aa6ee7529226ad84.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2ddde4894b664fee83b8d8b927787336.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/17e6846dd0ce40b4be83ba383afb8826.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0c1f5eecbb7841b2915ecbf48e5309a5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/29a985370d6c45b783b3137a4bd69993.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6aOe6amw55qE5Zyw6ZOB,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="article:published_time" content="2020-09-23T16:10:01.000Z">
<meta property="article:modified_time" content="2024-11-26T03:47:07.891Z">
<meta property="article:author" content="River">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/index.html" />
  
  <link
    rel="alternate"
    href="/atom.xml"
    title="River"
    type="application/atom+xml"
  />
   
  <link rel="icon" href="images/logo.svg" type="image/x-icon" />
   
<link rel="stylesheet" href="/home/css/style.css">
   
  <link
    href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css"
    rel="stylesheet"
  />
   
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;1,300;1,400;1,500&display=swap');
  </style>
  <style>
    body header {
      font-family: Ubuntu, 'PingHei', 'PingFang SC', Helvetica Neue, 'Work Sans',
        'Hiragino Sans GB', 'Microsoft YaHei', SimSun, sans-serif !important;
    }
  </style>
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center theme-green" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
       
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img
            class="img-circle img-rotate"
            src="/home/images/logo.svg"
            width="200"
            height="200"
          />
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Laputa Z</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">
          
        </h3>
        <small id="location" class="hidden-xs hidden-sm"
          ><i class="icon icon-map-marker"></i>
          <a href=""
            >桦林</a
          ></small
        >
      </div>
       <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button
        class="navbar-toggle collapsed"
        type="button"
        data-toggle="collapse"
        data-target="#main-navbar"
        aria-controls="main-navbar"
        aria-expanded="false"
      >
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav
      id="main-navbar"
      class="collapse navbar-collapse"
      itemscope
      itemtype="http://schema.org/SiteNavigationElement"
      role="navigation"
    >
      <ul
        class="
          nav
          navbar-nav
          main-nav
          menu-highlight
        "
      >
         
        <li class="menu-item menu-item-home">
          <a href="/home/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
         
        <li class="menu-item menu-item-archives">
          <a href="/home/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
         
        <li class="menu-item menu-item-tags">
          <a href="/home/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
         
        <li class="menu-item menu-item-about">
          <a href="/home/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Slogan</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>向前看，别回头</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/home/tags/AB-Testing/" style="font-size: 13px;">AB Testing</a> <a href="/home/tags/ai/" style="font-size: 13px;">ai</a> <a href="/home/tags/css/" style="font-size: 13.44px;">css</a> <a href="/home/tags/hook/" style="font-size: 13px;">hook</a> <a href="/home/tags/javascript/" style="font-size: 13.78px;">javascript</a> <a href="/home/tags/lerna/" style="font-size: 13px;">lerna</a> <a href="/home/tags/npm/" style="font-size: 13.11px;">npm</a> <a href="/home/tags/sem/" style="font-size: 13px;">sem</a> <a href="/home/tags/shell/" style="font-size: 13px;">shell</a> <a href="/home/tags/vue/" style="font-size: 13.56px;">vue</a> <a href="/home/tags/webpack/" style="font-size: 13px;">webpack</a> <a href="/home/tags/websocket/" style="font-size: 13px;">websocket</a> <a href="/home/tags/yarn/" style="font-size: 13px;">yarn</a> <a href="/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 13.33px;">二进制</a> <a href="/home/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 13px;">人工智能</a> <a href="/home/tags/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0/" style="font-size: 13.22px;">俄语笔记</a> <a href="/home/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 13.11px;">包管理</a> <a href="/home/tags/%E5%9B%9E%E9%A1%BE/" style="font-size: 13.67px;">回顾</a> <a href="/home/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 14px;">基础</a> <a href="/home/tags/%E5%AE%9E%E7%8E%B0/" style="font-size: 13.11px;">实现</a> <a href="/home/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 13px;">小程序</a> <a href="/home/tags/%E6%89%8B%E5%86%99/" style="font-size: 13.89px;">手写</a> <a href="/home/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 13px;">排序</a> <a href="/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/" style="font-size: 13.67px;">方案设计</a> <a href="/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.22px;">浏览器</a> <a href="/home/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a> <a href="/home/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13px;">网络</a> <a href="/home/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 13px;">网络安全</a> <a href="/home/tags/%E8%B7%A8%E7%AB%AF/" style="font-size: 13px;">跨端</a> <a href="/home/tags/%E8%B8%A9%E5%9D%91/" style="font-size: 13.11px;">踩坑</a> <a href="/home/tags/%E8%BF%9B%E5%88%B6/" style="font-size: 13px;">进制</a> <a href="/home/tags/%E9%97%AE%E9%A2%98/" style="font-size: 13.11px;">问题</a> <a href="/home/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" style="font-size: 13.22px;">高阶组件</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2023/">2023</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2022/">2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2021/">2021</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2020/">2020</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2019/">2019</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/home/archives/2018/">2018</a><span class="archive-list-count">14</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-浏览器-浏览器工作和js执行原理笔记" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      浏览器：浏览器工作原理笔记
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" class="article-date">
	  <time datetime="2020-09-23T16:10:01.000Z" itemprop="datePublished">2020-09-23</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/home/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a>, <a class="article-tag-link-link" href="/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a>
  </span>


        

        <!-- <span class="post-comment"><i class="icon icon-comment"></i> <a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#comments" class="article-comment-link">评论</a></span> -->
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>最近看了浏览器原理，这里记录一下细节。浏览器原理可以把一系列知识串联起来。</p>
<span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8">宏观视角下的浏览器</a><br><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B">网页渲染流程</a><br><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6">js 执行机制</a><br><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#chrome-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">chrome 垃圾回收</a><br><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F">页面循环系统</a><br><a href="/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96">页面优化</a></p>
<h1 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>1. 线程 VS 进程</strong></p>
<blockquote>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。</p>
</blockquote>
<p><img src="https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png" alt="图"></p>
<p>总结来说，进程和线程之间的关系有以下 4 个特点。</p>
<ol>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li>
<li>线程之间共享进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
<li>进程之间的内容相互隔离。</li>
</ol>
<h2 id="Chrome-进程架构"><a href="#Chrome-进程架构" class="headerlink" title="Chrome 进程架构"></a>Chrome 进程架构</h2><p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png" alt="jincheng"></p>
<ul>
<li>浏览器进程。主要负责浏览器界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。主进程和网络进程是共享的。</p>
<h1 id="网页渲染流程"><a href="#网页渲染流程" class="headerlink" title="网页渲染流程"></a>网页渲染流程</h1><h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><ol>
<li>用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL</li>
<li>用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得</li>
<li>浏览器进程构建请求行信息，会通过进程间通信（IPC）将 URL 请求发送给网络进程<br><code>GET /index.html HTTP1.1</code></li>
<li>网络进程获取到 URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接 200 返回；否则，进入网络请求过程</li>
<li>网络进程请求 DNS 返回域名对应的 IP 和端口号，如果之前 DNS 数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的 IP 和端口号，如果没有端口号，http 默认 80，https 默认 443。如果是 https 请求，还需要建立 TLS 连接。</li>
<li>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。</li>
<li>TCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输</li>
<li>网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层</li>
<li>底层通过物理网络传输给目的服务器主机</li>
<li>目的服务器主机网络层接收到数据包，解析出 IP 头部，识别出数据部分，将解开的数据包向上传输到传输层</li>
<li>目的服务器主机传输层获取到数据包，解析出 TCP 头部，识别端口，将解开的数据包向上传输到应用层</li>
<li>应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态 code301 或者 302，同时在请求头的 Location 字段中附上重定向地址，浏览器会根据 code 和 Location 进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：<br>``Cache-Control:Max-age=2000`<br>响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程</li>
<li>数据传输完成，TCP 四次挥手断开连接。如果，浏览器或者服务器在 HTTP 头部加上如下信息，TCP 就一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度<br><code>Connection:Keep-Alive</code></li>
<li>网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到文档准备渲染</li>
<li>浏览器进程获取到通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程</li>
<li>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程</li>
<li>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页</li>
</ol>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>导航流程结束后，现在是渲染进程的主场</p>
<ol>
<li><p>构建 DOM 树。</p>
<ul>
<li>构建 DOM 树的输入内容是 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p>样式计算（Recalculate Style）。</p>
<ul>
<li>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。document.styleSheets 可以查看。</li>
<li>转换样式表中的属性值，使其标准化。如 font-size:bold =&gt; font-size:700。</li>
<li>计算出 DOM 树中每个节点的具体样式。（层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。）</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><p>布局阶段。（计算出 DOM 树中可见元素的几何位置）</p>
<ul>
<li>创建布局树。只包含可见元素布局树。</li>
<li>布局计算。计算布局树节点的坐标位置。</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><p>分层。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。devtool Layers 可以看到。</p>
<ul>
<li>拥有层叠上下文属性的元素会被提升为单独的一层。</li>
<li>需要剪裁（clip）的地方也会被创建为图层。（overflow）</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>图层绘制。<ul>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>绘制阶段其实并<strong>不是真正地绘出图片</strong>，而是将绘制指令组合成一个列表。</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><p>栅格化（raster）操作。</p>
<ul>
<li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li>合成和显示。一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li>
</ol>
<hr>
<p>全流程<br><img src="https://img-blog.csdnimg.cn/4869de48dca84c0299e9efb0848ebd51.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6aOe6amw55qE5Zyw6ZOB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>注意：</p>
<ul>
<li>css 与 js 的加载会阻塞布局树的生成，因为布局树需要 css 配合计算完成样式。</li>
<li>重排： 触发重新布局，解析之后的一系列子阶段，这个过程就叫重排</li>
<li>重绘： 并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。</li>
</ul>
<h1 id="js-执行机制"><a href="#js-执行机制" class="headerlink" title="js 执行机制"></a>js 执行机制</h1><p>JavaScript 的执行机制：先编译，再执行。变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升，是指在 JavaScript 代码编译时，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。默认值 undefined。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文是 JavaScript 执行一段代码时的运行环境。在执行上下文中存在一个变量环境的对象（Viriable Environment）。</p>
<ul>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>又称执行上下文栈。调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。例如没有出口的递归。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
<p>es6 之前：</p>
<ul>
<li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>
</ul>
<p>es6 新增：</p>
<ul>
<li>块级作用域</li>
</ul>
<h2 id="块级作用域的实现-gt-词法环境"><a href="#块级作用域的实现-gt-词法环境" class="headerlink" title="块级作用域的实现 =&gt; 词法环境"></a>块级作用域的实现 =&gt; 词法环境</h2><p>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。块级作用域编译的时候不会把内部的 let 放到词法环境，而是在执行阶段。<br>当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。<br>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/d2477a4651de44d29525a172045e04d3.png" alt="在这里插入图片描述"></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。</p>
<p><img src="https://img-blog.csdnimg.cn/e752c6e79e4440b68cefecd19f44c15f.png" alt="在这里插入图片描述"></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>
<p>闭包的作用：</p>
<ol>
<li>私有化变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;luckyStar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">//  =&gt; undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">getName</span>()); <span class="comment">//  =&gt; &#x27;luckyStar&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>柯里化，即简化函数的参数。例如判断模式是 jj 的字符串</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">reg, text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/jj/</span>, <span class="string">&#x27;jj&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/jj/</span>, <span class="string">&#x27;tt&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接写为</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curringCheck</span>(<span class="params">reg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(text);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> checkFunc = <span class="title function_">curringCheck</span>(<span class="regexp">/jj/</span>);</span><br><span class="line"><span class="title function_">checkFunc</span>(<span class="string">&#x27;jj&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">checkFunc</span>(<span class="string">&#x27;js&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><img src="https://img-blog.csdnimg.cn/7b6849e77df34127aa6ee7529226ad84.png" alt="在这里插入图片描述"></p>
<p><a href="/home/js%E5%9F%BA%E7%A1%80-this%E7%9A%84%E6%8C%87%E5%90%91%E4%BB%A5%E5%8F%8Acall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/">this 指向</a></p>
<h1 id="chrome-垃圾回收"><a href="#chrome-垃圾回收" class="headerlink" title="chrome 垃圾回收"></a>chrome 垃圾回收</h1><p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。<br>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的<br>因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</p>
<hr>
<p>栈内存回收：</p>
<ul>
<li>当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。下移后，原执行上下文便会变成无效内存，下一次有执行上下文进栈时便会直接覆盖。</li>
</ul>
<hr>
<p>堆内存回收：<br><strong>代际假说</strong>。有以下两个特点：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p>在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>
<ul>
<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>
<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>
</ul>
<p>不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p>
<ul>
<li>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
</ul>
<p><strong>副垃圾回收器</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2ddde4894b664fee83b8d8b927787336.png" alt="在这里插入图片描述"></p>
<p>Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>
<p><strong>主垃圾回收器</strong></p>
<p>标记 - 清除（Mark-Sweep）的算法。遍历调用栈中不可触达的对象，然后清除。</p>
<p><strong>全停顿</strong></p>
<p>一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>
<h1 id="页面循环系统"><a href="#页面循环系统" class="headerlink" title="页面循环系统"></a>页面循环系统</h1><p>每个渲染进程都有一个主线程，渲染引擎和 JS 引擎都是在该线程执行的。每个渲染进程都有一个主线程，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。这就需要一个系统来统筹调度这些任务，消息队列和事件循环系统。</p>
<p>消息队列：可以存放要执行的任务。也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>
<p>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息。</p>
<p><img src="https://img-blog.csdnimg.cn/17e6846dd0ce40b4be83ba383afb8826.png" alt="在这里插入图片描述"></p>
<p>消息队列的两个问题：</p>
<ol>
<li><p>如何处理高优先级的任务。<br>为了适应效率和实时性，引入了微任务。通常把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p>
</li>
<li><p>如何解决单个任务执行时长过久的问题<br>可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。</p>
</li>
</ol>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表（延迟队列）。处理完主消息队列中的一个任务之后，会根据发起时间和延迟时间计算出到期延迟队列的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，会回到主消息队列。</p>
<ol>
<li><p>如果当前任务执行时间过久，会影响定时器任务的执行。例如有个 for 循环任务阻塞住了主消息队列的执行。</p>
</li>
<li><p>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</p>
</li>
<li><p>延时执行时间有最大值。如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</p>
</li>
<li><p>使用 setTimeout 设置的回调函数中的 this 不符合直觉，如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。</p>
</li>
</ol>
<p>requestAnimationFrame 实现的动画效果比 setTimeout 好的原因：</p>
<blockquote>
<p>使用 requestAnimationFrame 不需要设置具体的时间，它会在一帧（一般是 16ms）间隔内根据选择浏览器情况去执行相关动作。requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销</p>
</blockquote>
<h2 id="同步回调和异步回调"><a href="#同步回调和异步回调" class="headerlink" title="同步回调和异步回调"></a>同步回调和异步回调</h2><p>回调函数：将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p>
<p>同步回调： 在主函数返回之前执行，即为同步回调。同步回调就是在当前主函数的上下文中执行回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am do homework&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start do work&#x27;</span>);</span><br><span class="line">  <span class="title function_">cb</span>(); <span class="comment">// 在主函数返回之前执行，同步回调</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end do work&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doWork</span>(callback);</span><br></pre></td></tr></table></figure>

<p>异步回调:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am do homework&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start do work&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(cb, <span class="number">1000</span>); <span class="comment">// 异步回调</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end do work&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doWork</span>(callback);</span><br></pre></td></tr></table></figure>

<p>这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</p>
<h2 id="XMLHttpRequest-异步回调运作机制"><a href="#XMLHttpRequest-异步回调运作机制" class="headerlink" title="XMLHttpRequest 异步回调运作机制"></a>XMLHttpRequest 异步回调运作机制</h2><p><img src="https://img-blog.csdnimg.cn/0c1f5eecbb7841b2915ecbf48e5309a5.png" alt="在这里插入图片描述"></p>
<p>网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<h2 id="宏任务-和-微任务"><a href="#宏任务-和-微任务" class="headerlink" title="宏任务 和 微任务"></a>宏任务 和 微任务</h2><p>普通消息队列和延迟执行队列中的任务都统称为“宏任务”。</p>
<p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p>
<p>产生微任务有两种方式：</p>
<ol>
<li><p>使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来操作节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务</p>
</li>
<li><p>promise</p>
</li>
</ol>
<p>在当前宏任务快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p>
<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>
<hr>
<p>Event Loop 中，每一次循环称为 tick，每一次 tick 的任务如下：</p>
<p>执行栈选择最先进入队列的宏任务（一般都是 script），执行其同步代码直至结束；<br>检查是否存在微任务，有则会执行至微任务队列为空</p>
<table>
<thead>
<tr>
<th></th>
<th>宏任务</th>
<th>微任务</th>
</tr>
</thead>
<tbody><tr>
<td>具体事件</td>
<td>1. script 2. setTimeout/setInterval 3. UI rendering/UI 事件 4. postMessage，MessageChannel 5. setImmediate，I/O（Node.js）</td>
<td>1. Promise 2. MutaionObserver 3. Object.observe（已废弃；Proxy 对象替代）4. process.nextTick（Node.js）</td>
</tr>
</tbody></table>
<h1 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h1><h2 id="白屏和优化"><a href="#白屏和优化" class="headerlink" title="白屏和优化"></a>白屏和优化</h2><p><img src="https://img-blog.csdnimg.cn/29a985370d6c45b783b3137a4bd69993.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6aOe6amw55qE5Zyw6ZOB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>浏览器渲染页面包括构建 DOM，构建 CSSOM, 构建布局树，渲染等。白屏的瓶颈主要体现在：</p>
<ol>
<li>下载 html 文件（阻塞 DOM 的合成）</li>
<li>下载 CSS 文件（阻塞 CSSOM 的合成）</li>
<li>下载 JavaScript 文件</li>
<li>执行 JavaScript</li>
</ol>
<p>3、4 =&gt; 在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。）</p>
<hr>
<p><strong>策略</strong></p>
<ul>
<li><strong>去掉、减少多余网络请求</strong><ul>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>对于依赖数据的 html,采用预渲染和服务端渲染，减少在前端再次请求。</li>
</ul>
</li>
<li><strong>减少请求的文件大小</strong><ul>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
<li>尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>Webpack 的代码切割</li>
</ul>
</li>
<li><strong>异步请求</strong><ul>
<li>将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>
</ul>
</li>
<li><strong>优化网络请求</strong><ul>
<li>CDN</li>
</ul>
</li>
<li><strong>障眼法</strong><ul>
<li>对于依赖数据的 html,采用骨架屏和 loading</li>
</ul>
</li>
</ul>
<h2 id="为什么-CSS-动画比-JavaScript-高效"><a href="#为什么-CSS-动画比-JavaScript-高效" class="headerlink" title="为什么 CSS 动画比 JavaScript 高效"></a>为什么 CSS 动画比 JavaScript 高效</h2><p>显示器是怎么显示图像的： 每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都缓冲区，显示器每秒固定读取 60 次缓冲区中的图像，并将读取的图像显示到显示器上。</p>
<p>动画的效果：在滚动或者缩放操作等动画操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的缓冲区。</p>
<p>正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 [刷新率] 张图片到显卡的后缓冲区</p>
<ul>
<li>把渲染流水线生成的每一副图片称为一帧。</li>
<li>把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</li>
</ul>
<p><strong>要解决卡顿问题，就要解决每帧生成时间过久的问题。</strong></p>
<p>通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。<br>将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。<br>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</p>
<hr>
<p>能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。</p>
<p>能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容。</p>
<p>比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <!-- 
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="浏览器：浏览器工作原理笔记" target="_blank" rel="external">https://laputaz.github.io/home/浏览器-浏览器工作和js执行原理笔记/</a>
    </li>
     -->
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用
      <a
        href="http://creativecommons.org/licenses/by/4.0/deed.zh"
        target="_blank"
        rel="external"
        >CC BY 4.0 CN协议</a
      >
      许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>
 
<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a
          href=""
          target="_blank"
          class="img-burn thumb-sm visible-lg"
        >
          <img
            src="/home/images/logo.svg"
            class="img-rounded w-full"
            alt=""
          />
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading">
          <a href="" target="_blank"
            ><span class="text-dark">Laputa Z</span
            ><small class="ml-1x"></small></a
          >
        </h3>
        <div>Жизнь, как качели - то вверх, то вниз.</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/home/js%E5%9F%BA%E7%A1%80-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="js基础：算法笔记"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/home/js%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="js基础：排序算法总结"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <!-- <div class="copyright">
    	
        &copy; 2024 River
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div> -->
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/home/js/plugin.min.js"></script>


<script src="/home/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/home/',
        CONTENT_URL: '/home/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/home/js/insight.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:laputaz.github.io/home ' + keyword;
        return false;
    });
})(jQuery);
</script>




   




   


  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>