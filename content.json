{"meta":{"title":"River","subtitle":"Carpe Diem","description":"River","author":"River","url":"https://laputaz.github.io/home","root":"/home/"},"pages":[{"title":"Laputa Z","date":"2024-11-26T03:47:07.903Z","updated":"2024-11-26T03:47:07.903Z","comments":true,"path":"about/index.html","permalink":"https://laputaz.github.io/home/about/index.html","excerpt":"","text":"关于我 就职: KLOOK、深信服 主职: 前端 邮箱: zdhanunity@163.com github: https://github.com/laputaz"},{"title":"categories","date":"2019-10-26T10:42:39.000Z","updated":"2024-11-26T03:47:07.903Z","comments":true,"path":"categories/index.html","permalink":"https://laputaz.github.io/home/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-26T10:38:56.000Z","updated":"2024-11-26T03:47:07.903Z","comments":true,"path":"tags/index.html","permalink":"https://laputaz.github.io/home/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法-珂珂吃香蕉问题","slug":"算法-珂珂吃香蕉问题","date":"2023-09-11T10:13:05.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"算法-珂珂吃香蕉问题/","link":"","permalink":"https://laputaz.github.io/home/%E7%AE%97%E6%B3%95-%E7%8F%82%E7%8F%82%E5%90%83%E9%A6%99%E8%95%89%E9%97%AE%E9%A2%98/","excerpt":"leetcode 875：爱吃香蕉的珂珂 https://leetcode-cn.com/problems/koko-eating-bananas/可以看看我的题解：https://leetcode.cn/problems/koko-eating-bananas/solutions/1094146/bu-yao-shang-lai-jiu-gao-su-wo-shi-er-fe-8n1y/","text":"leetcode 875：爱吃香蕉的珂珂 https://leetcode-cn.com/problems/koko-eating-bananas/可以看看我的题解：https://leetcode.cn/problems/koko-eating-bananas/solutions/1094146/bu-yao-shang-lai-jiu-gao-su-wo-shi-er-fe-8n1y/ 题目珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。 示例 1： 12输入: piles = [3,6,7,11], H = 8输出: 4 示例 2： 12输入: piles = [30,11,23,4,20], H = 5输出: 30 示例 3： 12输入: piles = [30,11,23,4,20], H = 6输出: 23 心路历程很多答案一开始就说是二分法，然后给我介绍二分法。对于我这种菜鸟，一开始看真的一头雾水。😭在这里写一下完整的心里历程。 题意分解题目的意思是说： 珂珂要吃香蕉，面前摆了 n 堆，一堆一堆地吃； 珂珂 1 小时能吃 k 个；但如果一堆少于 k 个，那也得花一小时 (一小时到了，才吃下一堆) 如果 1 堆大于 k 个，那么超过 k 的部分也算 1 小时。（例如，一堆 10 个，k=3 时，珂珂花 3 小时吃了 9 个，剩下的 1 个也算 1 小时，也就是总用时 4 小时） 问：只给 h 小时，珂珂要吃多慢(k 多小)，才能充分占用这 h 小时 思路珂珂吃的速度和时间是此消彼长的关系，吃的速度越快，花的时间越少。吃的速度越慢，花的时间越多。 我们要让珂珂吃得够慢，又能吃完。 那我们从最最慢开始，让珂珂一小时只吃 1 个（k=1），看珂珂能否在 h 小时内吃完。 如果吃不完，就吃 2 个(k+1)，重头吃一遍。 一直到找到 k。 说到这里，就可以写出推断的代码了。（那怎么判断吃不吃得完? 这么想：它就是一个函数，吃得完返回 true，吃不完返回 false，具体实现可以后面再做） 12345678910111213var minEatingSpeed = function(piles, h) &#123; // 每小时吃 k 根, 最小是 1 根, 从 1 开始试吃 let k = 1 // 一直试吃 while(true) &#123; // 可以吃完，返回 k if(canFinish(...)) &#123; return k &#125; // 当不能吃完的时候，多吃一根再试试 k++ &#125;&#125;; 接下来问题变成, 怎么判断能否吃完？硬算！ 按顺序去吃每一堆，记录时间；最后超过了 h 小时，说明吃不完： 123456789101112131415161718192021// 每小时吃 k, 有 piles 堆, 给了 h 小时function canFinish(k, h, piles) &#123; // 假设总时间为 total, 当 total 大于 h 的时候，说明吃不完 let totalTime = 0 // 循环每堆 for (var i = 0; i &lt; piles.length; i++) &#123; // 当香蕉少于 k 的时候，当成 1 小时算 if (piles[i] &lt;= k) &#123; totalTime += 1 // 当香蕉大于 k 的时候，多出的部分按1小时记 &#125; else &#123; totalTime += Math.ceil(piles[i] / k) &#125; // 已经超时了？那就直接返回吃不完，不再继续吃 if (totalTime &gt; h) &#123; return false &#125; &#125; // 最后吃完了 return true&#125; 那第一版代码就完成了： 12345678910111213141516171819202122232425262728293031323334var minEatingSpeed = function (piles, h) &#123; // 每小时吃 k 根, 最小是 1 根, 从 1 开始试吃 let k = 1 // 一直试吃 while (true) &#123; // 可以吃完，返回 k if (canFinish(k, h, piles)) &#123; return k &#125; // 当不能吃完的时候，多吃一根再试试 k++ &#125;&#125;// 每小时吃 k, 有 piles 堆, 给了 h 小时function canFinish(k, h, piles) &#123; // 假设总时间为 total, 当 total 大于 h 的时候，说明吃不完 let totalTime = 0 // 循环每堆 for (var i = 0; i &lt; piles.length; i++) &#123; // 当香蕉少于 k 的时候，当成 1 小时算 if (piles[i] &lt;= k) &#123; totalTime += 1 // 当香蕉大于 k 的时候，多出的部分按1小时记 &#125; else &#123; totalTime += Math.ceil(piles[i] / k) &#125; // 已经超时了？那就直接返回吃不完，不再继续吃 if (totalTime &gt; h) &#123; return false &#125; &#125; // 最后吃完了 return true&#125; 优化我们发现，k 从 1 开始遍历，效率太低了。k 最小是 1，最大是最多的那一堆香蕉数量。 也就是，我们要在一个范围里找 k，这个时候，我才想到二分法： 1234567891011121314var minEatingSpeed = function (piles, h) &#123; let l = 1 let r = Math.max(...piles) let mid while (l &lt; r) &#123; mid = Math.floor(l + (r - l) / 2) if (canFinish(mid, h, piles)) &#123; r = mid &#125; else &#123; l = mid + 1 &#125; &#125; return l&#125; 最后代码1234567891011121314151617181920212223242526272829303132333435var minEatingSpeed = function (piles, h) &#123; let l = 1 let r = Math.max(...piles) let mid while (l &lt; r) &#123; mid = Math.floor(l + (r - l) / 2) if (canFinish(mid, h, piles)) &#123; r = mid &#125; else &#123; l = mid + 1 &#125; &#125; return l&#125;// 每小时吃 k, 总数 piles, 时间总长 h// 一个约束条件是，当香蕉少于 k 的时候，当成 1 小时算function canFinish(k, h, piles) &#123; // 循环每堆 // 假设总时间为 total, 当 total 大于 h 的时候，说明吃不完 let totalTime = 0 for (var i = 0; i &lt; piles.length; i++) &#123; // console.log(p[i], k) // 当香蕉少于 k 的时候，当成 1 小时算 if (piles[i] &lt;= k) &#123; totalTime += 1 &#125; else &#123; totalTime += Math.ceil(piles[i] / k) &#125; if (totalTime &gt; h) &#123; return false &#125; &#125; return true&#125; 二分法思路很简单，不就是减半减半再减半吗，但难的是边界问题: left &lt; right 还是 left &lt;= right left 等于 mid 还是 mid + 1 ? right 等于 mid 还是 mid - 1 ？ 最后返回 mid ? 还是返回 left ? 还是返回 right? 关于二分的边界，这里有一篇文章写的很详细：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"算法","slug":"算法","permalink":"https://laputaz.github.io/home/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"回顾：cypress 总结、质量左移指南","slug":"cypress 总结、质量左移指南","date":"2023-07-20T19:06:34.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"cypress 总结、质量左移指南/","link":"","permalink":"https://laputaz.github.io/home/cypress%20%E6%80%BB%E7%BB%93%E3%80%81%E8%B4%A8%E9%87%8F%E5%B7%A6%E7%A7%BB%E6%8C%87%E5%8D%97/","excerpt":"我们经常有听到 TDD、写单测等等，那么跟 UI 强关联的组件的测试应该怎么做？ 本文使用 Cypress 框架，通过一个组件示例，一步步进行实践，尝试把 TDD 在前端落地。","text":"我们经常有听到 TDD、写单测等等，那么跟 UI 强关联的组件的测试应该怎么做？ 本文使用 Cypress 框架，通过一个组件示例，一步步进行实践，尝试把 TDD 在前端落地。 环境搭建Cypress 是一个完整易用的测试框架，我们可以使用 Cypress 进行 e2e 测试、集成测试、单元测试用来实现组件测试有着几大优势 支持真实的浏览器运行环境，直接使用 web 浏览器上的开发工具直接调试 在运行测试的时候，会获取快照，记录了测试执行过程的每一步细节 运行速度非常快，基本可以与浏览器内容实时同步 在 Cypress 官方的组件测试示例仓库 cypress-component-examples 中，选择 vite-vue 作为初始化的模板 1实际业务中已有的项目可以参考 Vite Based Projects (Vue, React) 中说明进行接入 可以看到，有一个 HelloWorld.spec.js 的测试文件 首先开始安装、运行，看看是什么效果 12345pnpm install# 在浏览器打开测试用例集的界面pnpm cypress open-ct 从 Cypress 自带的测试用例预览界面可以看到，用例已经正常运行通过了，接下来进入正文 由于后续示例代码使用 ts 编写，这里先添加 @vitejs/plugin-vue-jsx 插件 123456789// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue(), vueJsx()],&#125;); 12345// cypress.json&#123; &quot;testFiles&quot;: &quot;**/*.spec.[jt]s&quot;, &quot;componentFolder&quot;: &quot;src&quot;&#125; 组件测试以一个 Rate 评分组件为例 基础显示 支持点击选中 支持传入初始值选中 支持 hover 高亮 受限篇幅，本文只支持以上功能 测试驱动开发测试驱动开发，即 TDD，它的规则很简单，可以归纳为下面三条： 先编写一个因为缺乏实现代码而运行失败的测试，然后编写实现代码。 只允许编写一个刚好失败的测试 - 编译失败也算失败。 只允许编写刚好能使当前失败测试通过的实现代码。 遵循 TDD 三原则，意味着你的每一行实现代码都是有测试保证的，先有的测试，才有的你那一行恰好可以通过的实现代码。你的测试是完备的，你有信心部署你测试全过的代码，这些测试告诉我们，我们的系统是可靠、可部署的。通过上述的三原则，从第一个测试用例开始 编写第一个测试用例在 components 下新建 rate 目录存放相关代码实现以及测试用例 如上图所示，由于我们还没开始写 Rate 组件的实现，现在导入组件是编译报错的状态 假设初始化会渲染 5 个类为 mio-rate-item 的元素，那么此时写下第一个测试用例代码 12345678910import &#123; mount &#125; from &#x27;@cypress/vue&#x27;;import Rate from &#x27;./index&#x27;;describe(&#x27;rate component&#x27;, () =&gt; &#123; it(&#x27;should render 5 item elements&#x27;, () =&gt; &#123; mount(Rate); cy.get(&#x27;.mio-rate-item&#x27;).should(&#x27;have.length&#x27;, 5); &#125;);&#125;); 打开浏览器用例运行界面，可以看到左侧的用例列表多出来了 src/component/rate/rate.spec.ts ，且编译摆错了。 针对第一个用例编写实现代码为了使刚才写的第一个用例通过，回想之前提到的三原则，这次只针对性的写这个用例对应的实现代码 创建一个容器，然后渲染 5 个类名为 mio-rate-item 的子元素 123456789101112131415161718192021222324252627// rate/index.tsximport &#123; defineComponent &#125; from &#x27;vue&#x27;;import &#123; renderIcon &#125; from &#x27;./icon&#x27;;import &#x27;./index.css&#x27;;const getNumberList = (num: number) =&gt; &#123; return Array.from(&#123; length: num &#125;).map((_, i) =&gt; i + 1);&#125;;const useRateClasses = () =&gt; &#123; return [&#x27;mio-rate-item&#x27;];&#125;;export default defineComponent(&#123; name: &#x27;Rate&#x27;, setup() &#123; const renderRateItem = () =&gt; ( &lt;div class=&#123;useRateClasses()&#125;&gt;&#123;renderIcon()&#125;&lt;/div&gt; ); const renderRate = () =&gt; ( &lt;div class=&quot;mio-rate&quot;&gt;&#123;getNumberList(5).map(() =&gt; renderRateItem())&#125;&lt;/div&gt; ); return () =&gt; renderRate(); &#125;,&#125;); 查看用例运行界面可以发现用例已经运行通过了，右侧的界面成功的渲染了 5 个 ⭐️ 第二个测试用例根据上述的步骤继续，这次需要支持点击选择功能 假设我们点击后会给选中的子元素加上 .is-active ，那么自然而然写下测试用例代码 12345678910111213141516171819202122import &#123; mount &#125; from &#x27;@cypress/vue&#x27;;import Rate from &#x27;./index&#x27;;describe(&#x27;rate component&#x27;, () =&gt; &#123; it(&#x27;should render 5 item elements&#x27;, () =&gt; &#123; mount(Rate); cy.get(&#x27;.mio-rate-item&#x27;).should(&#x27;have.length&#x27;, 5); &#125;); it(&#x27;should be highlighted when the element is clicked&#x27;, () =&gt; &#123; mount(Rate); cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 0); // 点击第 3 个子元素 cy.get(&#x27;.mio-rate-item:nth-of-type(3)&#x27;).click(); // 带有 .is-active 的子元素应该有 3 个 cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 3); &#125;);&#125;); 查看运行界面，可以看到用例运行状态是失败的，右侧渲染的组件中也没有高亮 然后需要在对应的组件文件进行实现 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; defineComponent, ref, Ref &#125; from &#x27;vue&#x27;;import &#123; renderIcon &#125; from &#x27;./icon&#x27;;import &#x27;./index.css&#x27;;const getNumberList = (num: number) =&gt; &#123; return Array.from(&#123; length: num &#125;).map((_, i) =&gt; i + 1);&#125;;function useRateClasses(&#123; currentValue, index,&#125;: &#123; currentValue: Ref&lt;number&gt;, index: number,&#125;) &#123; return [&#x27;mio-rate-item&#x27;, currentValue.value &gt;= index ? &#x27;is-active&#x27; : &#x27;&#x27;];&#125;export default defineComponent(&#123; name: &#x27;Rate&#x27;, setup() &#123; const currentValue = ref(0); const onClickItem = (index: number) =&gt; (currentValue.value = index); const renderRateItem = (index: number) =&gt; ( &lt;div class=&#123;useRateClasses(&#123; currentValue, index &#125;)&#125; onClick=&#123;() =&gt; onClickItem(index)&#125; &gt; &#123;renderIcon()&#125; &lt;/div&gt; ); const renderRate = () =&gt; ( &lt;div class=&quot;mio-rate&quot;&gt; &#123;getNumberList(5).map((i) =&gt; renderRateItem(i))&#125; &lt;/div&gt; ); return () =&gt; renderRate(); &#125;,&#125;); 切换到用例运行的面板，可以看到用例已经执行成功了 点击步骤可查看组件的中间状态，如果中间出现问题，还可以打开 chrome devtools 去调试 重复上述步骤根据之前提到的 TDD 三原则，重复的进行 写用例 -&gt; 写实现代码 -&gt; 调试通过 -&gt; 重构/优化设计 -&gt; 写用例 -&gt; … 的过程。 v-model 功能 支持传入初始值选中显示 props 用例 12345678910111213141516171819202122232425262728import &#123; mount, mountCallback &#125; from &#x27;@cypress/vue&#x27;;import Rate from &#x27;./index&#x27;;describe(&#x27;rate component&#x27;, () =&gt; &#123; // ... describe(&#x27;v-model value&#x27;, () =&gt; &#123; // 当前 describe 作用域下每个用例执行前进行 mount beforeEach( mountCallback(Rate, &#123; propsData: &#123; modelValue: 3, &#125;, &#125;) ); it(&#x27;should work when set props value&#x27;, () =&gt; &#123; cy.get(&#x27;.mio-rate-item.is-active&#x27;) .should(&#x27;have.length&#x27;, 3) .then(() =&gt; &#123; // 参考 @vue/test-utils 的 wrapper api Cypress.vueWrapper.setProps(&#123; modelValue: 4, &#125;); cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 4); &#125;); &#125;); &#125;);&#125;); Props 逻辑实现 123456789101112131415161718192021export default defineComponent(&#123; name: &#x27;Rate&#x27;, props: &#123; modelValue: &#123; type: Number, default: 0, &#125;, &#125;, setup(props) &#123; const currentValue = ref(props.modelValue); watch( () =&gt; props.modelValue, (value) =&gt; &#123; currentValue.value = value; &#125; ); // ... &#125;,&#125;); emit 用例 12345678910it(&#x27;should be emit input when the element is clicked&#x27;, () =&gt; &#123; cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 3); cy.get(&#x27;.mio-rate-item:nth-of-type(2)&#x27;) .click() .then(() =&gt; &#123; expect(Cypress.vueWrapper.emitted()[&#x27;update:modelValue&#x27;].length).to.eq(1); expect(Cypress.vueWrapper.emitted()[&#x27;update:modelValue&#x27;][0][0]).to.eq(2); &#125;);&#125;); emit 实现 123456789setup(props, &#123; emit &#125;) &#123; const currentValue = ref(props.modelValue); watch(currentValue, (value) =&gt; &#123; emit(&#x27;update:modelValue&#x27;, value); &#125;); // ...&#125;) 悬浮高亮功能 用例 1234567891011it(&#x27;should be highlighted when hover&#x27;, () =&gt; &#123; mount(Rate); cy.get(&#x27;.mio-rate-item:nth-of-type(3)&#x27;).trigger(&#x27;mouseenter&#x27;); cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 3); cy.get(&#x27;.mio-rate-item:nth-of-type(3)&#x27;).trigger(&#x27;mouseleave&#x27;); cy.get(&#x27;.mio-rate-item.is-active&#x27;).should(&#x27;have.length&#x27;, 0);&#125;); 实现 12345678910111213141516171819202122232425262728// ...function useRateClasses(&#123; currentValue, currentOverValue, index,&#125;: &#123; currentValue: Ref&lt;number&gt;, currentOverValue: Ref&lt;number&gt;, index: number,&#125;) &#123; return [ &#x27;mio-rate-item&#x27;, (currentOverValue.value || currentValue.value) &gt;= index ? &#x27;is-active&#x27; : &#x27;&#x27;, ];&#125;// setup ...const currentOverValue = ref(0);const renderRateItem = (index: number) =&gt; ( &lt;div class=&#123;useRateClasses(&#123; currentValue, currentOverValue, index &#125;)&#125; onClick=&#123;() =&gt; onClickItem(index)&#125; onMouseenter=&#123;() =&gt; (currentOverValue.value = index)&#125; onMouseleave=&#123;() =&gt; (currentOverValue.value = 0)&#125; &gt; &#123;renderIcon()&#125; &lt;/div&gt;); 运行效果 可以看到，用例已经全部运行通过了 重构完成了上述的过程是否就已经结束了呢？其实还漏了一个重要的步骤，那就是重构。如果有任何重复的逻辑、比较冗余的代码，重构可以消除重复并提高表达能力（减少耦合，增加内聚力）。再次运行测试验证重构是否引入新的错误。如果没有通过，很可能是在重构时犯了一些错误，需要立即修复并重新运行，直到所有测试通过。以上述实现的 v-model 功能为例，在封装组件的时候，这类功能是比较常见的，那么这部分是否可以抽离出一个单独的函数来维护？先简单来实践一下首先封装一个名为 useVModel 的函数，将 v-model 所涉及到的关联逻辑放进来 12345678910111213141516171819const useVModel = &lt;T extends &#123; modelValue: T[&#x27;modelValue&#x27;] &#125;&gt;(props: T) =&gt; &#123; const &#123; emit &#125; = getCurrentInstance(); const proxy = ref(props.modelValue); watch(proxy, (value) =&gt; &#123; emit(&#x27;update:modelValue&#x27;, value); &#125;); watch( () =&gt; props.modelValue, (value) =&gt; &#123; proxy.value = value as UnwrapRef&lt;T[&#x27;modelValue&#x27;]&gt;; &#125;, ); return proxy;&#125;; 替换完成后，再次执行刚才写的测试用例，正常通过。通过这个重构操作，上述封装的 useVModel 就可以在其他地方进行复用，也简化了在业务上的调用逻辑。总的来说，有了之前的测试用例基础，重构也有对应的质量保障，且重构能够 消除重复设计，优化设计结构 ，对于整体的代码质量，可维护性与可扩展性都有了提升。 编写总结测试驱动开发 要求每次只添加一个行为，先写一个失败的测试，然后写出恰好能使这个测试通过的实现代码。你写出的每一个测试都是一份代码示例，如何调用 API，如何创建某个对象。测试已经有了超过 90% 使用场景覆盖，而且这可以立即发现错误，去调试、修复它。如果先写一大堆实现代码，再来补测试，这时候已经先入为主，你很难发现自己的代码有什么问题。在此过程中穿插的重构，也会让我们不断的思考如何实现好的代码，提升整体的代码质量。另外，在工具层面，Cypress 新的组件测试器对测试组件有着很好的支持，而且对于 vite 项目来说，也有比较好的集成，是测试在浏览器中呈现的任何内容理想选择。 质量左移Cypress 给项目带来的价值： 缺陷前移 质量后盾 提升个人能力 缺陷前移什么是缺陷前移？简单理解：缺陷前移就是在前期阶段做详尽的分析，采取好的措施去尽早地发现不合理的地方，尽早地暴露问题，促使团队更早地识别修复缺陷，这样后面出问题的几率就会越低，效能越好。编码阶段的措施可以是完成业务开发的同时产出测试用例，尽可能保证所有的代码都被测试到，所有的业务流程都能被测试用例覆盖到。为什么要做缺陷前移？ 如上图，项目修复 Bug 流程简化版所示，前期修改 Bug 很简单，开发自检出来有 Bug，自己改代码修复，然后上库代码即可。后期修改 Bug 就会增加很多很多前期没有的环节了： 开发需要根据测试人员描述去复现 Bug，可能需要自己构建复现的环境，Bug 可能是必现的，可能是偶现的，如果复现不出来，还需要找测试人员沟通，让测试人员复现。从这一点可以看出，前端测试属于正向追溯，开发人员可以直接把问题复现，直接看到用例的代码执行细节，方便进行问题定位。而后期修改 Bug 属于逆向追溯，盲目性和工作量都是大大增加的。Bug 解决得慢、后期 Bug 数量多都可能会阻塞项目进度，导致项目延期。修改好 Bug 后，开发人员还要提供代码改动点，评估改动关联影响，给予测试人员测试建议。修改好 Bug 后，还需要分析 Bug 产生的原因，开发人员需要对 Bug 负责任，转交给项目负责人审核。测试人员需要重新构建新环境进行 Bug 修复验证，需要对 Bug 进行测试发散，如果 Bug 没改好，或者改动引发了新问题，还需要让开发人员重新修改 Bug，重新走一系列改 Bug 流程。…… Bug 越到后面抛出，项目中人员所付出的时间也就越多，项目所承担的风险也就越大。基于 Cypress 做缺陷前移，在开发阶段写组件测试、e2e 测试，在前期就把问题测出来，而不是等到后期才测出，缺陷前移率越高，项目的健康度、项目的能效也就越好。 质量后盾开发代码上库前一般会有 CodeReview、代码走读等机制去严格把关代码的质量，CodeReview、代码走读机制都是以人为主体的保障，CodeReview 的效果好坏会受人的当前状态和人的技术能力水平影响。比如一个人粗枝大叶，看代码不够细心，或者这个人感冒发烧、失恋、基金亏损导致头脑不清醒，CodeReview 的效果都会大打折扣，项目的质量不能仅仅通过 CodeReview 去保障，而前端测试是以机器为主体的保障，机器不会受情绪影响。相信你或者你身边的同事都遇到过，编写代码改了好几个文件，然后上库代码的时候，忘记提交其中的一个文件，执行报错影响基础功能，合代码时没发现，等到测试人员反馈，等到被投诉时才知道自己犯了这么一个低级错误。假设 CI 流水线上有前端测试去保障基础业务功能，这种低级错误一般都可以在合代码跑流水线的时候暴露出来了。针对改代码漏测场景、改老问题引发新问题，可以通过提高前端测试的覆盖率来保障基本的业务流程跑通、业务功能不出问题。组件测试可以反映出你的组件封装得好不好用，如果你的组件不好用，测试代码写起来肯定也是偏向复杂的，上库代码审核的时候，CodeReview 的人也可以通过你写的测试用例理解你的代码，拥有前端测试用辅助的 CodeReview 效果肯定会比没有的好。项目迭代积累下来的测试用例，可以用来支撑未来模块的重构优化、项目的架构演进。升级第三方库对项目的影响面广，比如升级&#118;&#x75;&#x65;&#64;&#x32;&#x2e;&#x35;到&#x76;&#117;&#101;&#x40;&#x32;&#x2e;&#x36;，如果有问题，开发人员是比较难提前感知到的。 提升个人能力懂前端去做前端测试是一个优势，而测试与前端属于不同的领域，需要自己折腾，自己学习很多东西： 项目引入测试框架，Cypress 集成到 CI 流水线上，肯定会遇到很多问题，比如内网代理，测试框架与技术栈的冲突……在解决这些问题的同时锻炼了你的解决问题能力Cypress 有自己的 API 封装、有自己的插件，如何使用 Cypress 编写用例？如何用 Cypress 测试一个组件？如何测试 TypeScript 的类型声明？你在学习新知识、实践新知识的同时也锻炼了你的学习上手能力如何基于 UI 组件库、基于项目去封装好用的测试 API？如果做好大型项目的 e2e 测试和组件测试？这可以锻炼你的设计能力测试框架的选型如何做选择？选 Jest 还是 Cypress？这可以考察锻炼你的预研能力 当你把 Cypress 很好地集成进项目里面时，想必那时候你的能力也成长了许多。 如何使用 Cypress 做前端测试 测试设计 实践建议 调试技巧 测试设计这里提供一种可行的测试规划设计： 版本前期做到测试用例覆盖业务的主流程，版本后期持续沉淀更多的测试用例，比如对一些边界场景下产生的 Bug，补充相应的测试用例。 对于迭代很快、生命周期又短的页面（如商家活动页、运营页），允许不做前端测试。图表组件一般交互性不强，代码不会很复杂，也可以不对图表组件做前端测试。 前端开发者在写测试用例时，需要尽可能不去依赖公共组件的 DOM 结构、内部封装细节，假设你写了 200 条测试用例依赖了弹窗组件的 DOM 结构细节，有一天组件库升级修改了弹窗组件的 DOM 结构，到时候你就需要手动修改这 200 条测试用例，改起来十分痛苦。得益于 Cypress 的 command 特性，开发者可以对公共组件库的组件行为、组件断言进行二次封装，做到开发者在写测试用例时尽可能使用封装好的 command，不需要去关注组件的内部细节。 大粒度测试结合小粒度测试，大粒度测试业务流程，小粒度测试相对独立的组件。 我们在写测试用例可能会有一种感觉，就是你发现要测的东西测重复了，比如你在子组件里测了这个功能，然后你在父组件里又把这个功能测了一遍。为了更好的测试效率和测试效果，我们要对前端测试区分粒度。大粒度通常是页面级别的，干扰项、依赖项多，依赖接口数据，依赖他人的组件。干扰项和依赖项都需要去做 mock。运行时间上，大粒度测试耗时会比较久。在业务没有变化的情况下，假设我们对代码进行重构，我们是不需要去改动大粒度测试的测试用例代码的。大粒度测试的标题可以与需求点、QA 测试点一一对应起来，格式可以参考：test(‘已知 xxx，进行 xxx，期望 xxx’, () =&gt; { /** 用例代码 */ });。小粒度测试通常是针对单一组件、单一函数、类级别的，干扰项很少。小粒度测试运行速度很快，如果模块重构，相关组件的测试代码很可能需要被一起重构掉或者重写掉。小粒度测试的标题对应组件的实现细节：test(‘prop username work’, () =&gt; { /** 用例代码 */ });。 实践建议 对于组件测试，不需要测试组件内部实现的 API，使用组件时内部 API 对开发人员是隐藏的，我们应该测试组件的使用功能，vue 组件一般是测试传入的 props、slots，测试对外暴露的 API，像浮层类 UI 组件可能还需要测试父组件销毁时，浮层类组件是否跟着销毁。如果项目对无障碍性有要求，还需要测试组件的无障碍性。 不要把所有的单测代码都塞在一个测试用例里面，这样会降低阅读性和维护性，而且还会降低单测运行速度，适当拆分成多个可以做到并发运行单测。 像 Math.random、new Date 等尽量不要在单测中使用，因为这些 API 带有不确定性，应该使用固定的具体值，我们要尽可能保证测试用例不管运行多少次，每次运行它的前置条件的完全一致的。 试代码不完善导致测试是通过的，但是功能是有 Bug 的。 带来的问题Cypress 接入项目是会增加使用成本的，不同的测试框架，API 都存在差异，前端开发人员需要学习上手 Cypress 框架的框架理念、框架 API。在编码阶段让开发人员写测试用例会增加开发人员的工作量，但是不会加工资，开发人员评估工作量任务排期的时候，需要把前端测试的工作量也计算进去。一些防抖节流操作可能导致测试用例偶尔挂掉、偶尔通过，排查这一类问题时费时费力。","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"踩坑","slug":"踩坑","permalink":"https://laputaz.github.io/home/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"ChatGPT - 利用 ChatGPT 的 api 编写 AI 问答界面","slug":"chatgpt-利用chatgpt的api写一个AI工具","date":"2023-06-18T10:13:05.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"chatgpt-利用chatgpt的api写一个AI工具/","link":"","permalink":"https://laputaz.github.io/home/chatgpt-%E5%88%A9%E7%94%A8chatgpt%E7%9A%84api%E5%86%99%E4%B8%80%E4%B8%AAAI%E5%B7%A5%E5%85%B7/","excerpt":"接入 ChatGPT 快速实现的 MVP 版本的AI问答界面","text":"接入 ChatGPT 快速实现的 MVP 版本的AI问答界面 背景最近发现 ChatGPT 有提供了一套 api 以及 node 工具，于是就想着能不能利用 ChatGPT 的 api 写一个 AI 工具。 准备实现一个最小可行性产品 MVP 版本 前端界面：简单的对话框即可，用 vue 快速实现 后台设计：使用官方提供的 node 包以及 api，用 nestjs 快速实现 前端界面编写 使用 vue-cli 快速生成一个前端项目，命名为 dh-chat-ui 如图： 简单编写界面，包含标题、输入框、提问按钮、提问问题展示、答案展示，界面元素使用 naive-ui， 预览如下： 代码非常简单： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;header&gt; &lt;n-gradient-text type=&quot;info&quot; :size=&quot;30&quot;&gt; DH&amp;nbsp;&lt;/n-gradient-text&gt; &lt;n-gradient-text type=&quot;danger&quot; :size=&quot;30&quot;&gt; CHAT AI &lt;/n-gradient-text&gt; &lt;/header&gt; &lt;main&gt; &lt;n-input v-model:value=&quot;content&quot; round class=&quot;dh-input&quot; type=&quot;textarea&quot; size=&quot;large&quot; placeholder=&quot;请输入提问&quot; &gt; &lt;!-- &lt;template #prefix&gt; &lt;n-icon :component=&quot;FlashOutline&quot; /&gt; &lt;/template&gt; --&gt; &lt;/n-input&gt; &lt;n-button v-if=&quot;!isLoading&quot; type=&quot;primary&quot; @click=&quot;handleAsk&quot;&gt;提问&lt;/n-button&gt; &lt;n-button v-else type=&quot;primary&quot; disabled&gt;请稍候&lt;/n-button&gt; &lt;n-divider&gt; 提问 &lt;/n-divider&gt; &lt;div class=&quot;answer&quot;&gt; &#123;&#123; curAsk &#125;&#125; &lt;/div&gt; &lt;n-divider&gt; 答案 &lt;/n-divider&gt; &lt;div class=&quot;answer&quot;&gt; &#123;&#123; answer &#125;&#125; &lt;/div&gt; &lt;/main&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; NButton, NInput, NDivider, NGradientText &#125; from &#x27;naive-ui&#x27;import &#123; FlashOutline &#125; from &#x27;@vicons/ionicons5&#x27;import axios from &#x27;axios&#x27;export default &#123; components: &#123; NButton, NInput, NDivider, NGradientText &#125;, setup() &#123; const content = ref(&#x27;&#x27;) const answer = ref(&#x27;-&#x27;) const curAsk = ref(&#x27;您还没有提问&#x27;) const isLoading = ref(false) const handleAsk = async () =&gt; &#123; if (!content.value) &#123; return &#125; isLoading.value = true curAsk.value = content.value content.value = &#x27;&#x27; answer.value = &#x27;思考中&#x27; try &#123; const response = await axios.post(&#x27;http://222.125.89.250:70/ask&#x27;, &#123; content: curAsk.value &#125;) answer.value = response?.data.content || &#x27;-&#x27; &#125; finally &#123; isLoading.value = false &#125; &#125; return &#123; content, answer, handleAsk, FlashOutline, curAsk, isLoading &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.dh-input &#123; margin: 10px 0;&#125;.dh-answer &#123; padding: 0 10px;&#125;&lt;/style&gt; 后台设计 首先创建一个简单的 nest 项目，如图： 到 openai 官网创建一个 api 密钥、组织 ID，存放到常量文件，模型我选择 gpt-3.5-turbo： 123456// 密钥export const OPENAI_API_KEY = &#x27;sk-mTkhGQJfdTd0zX4iaFrYT3BlbkFJr2kTg1yxxxxxxxxx&#x27;;// 组织IDexport const ORGANIZATION_ID = &#x27;org-wBO3nA6YWjAN3Z8Cngxxxxxxxx&#x27;;// 默认模型export const DEFAULT_MODEL = &#x27;gpt-3.5-turbo&#x27;; 接着使用 openai 提供的 node 包初始化, 得到一个对象。 1234567891011121314import &#123; Configuration, OpenAIApi &#125; from &#x27;openai&#x27;;import &#123; OPENAI_API_KEY, ORGANIZATION_ID &#125; from &#x27;./const&#x27;;/** init openai */export const initOpenai = () =&gt; &#123; const configuration = new Configuration(&#123; organization: ORGANIZATION_ID, apiKey: OPENAI_API_KEY, &#125;); return new OpenAIApi(configuration);&#125;;/** openai instance */export const openai = initOpenai(); 编写接口，此处只提供一个 ask 接口用于返回答案： 123456789101112131415161718192021222324252627282930313233// controller 层，向外暴露接口import &#123; Controller, Body, Post &#125; from &#x27;@nestjs/common&#x27;;import &#123; AppService &#125; from &#x27;./app.service&#x27;;@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Post(&#x27;/ask&#x27;) async postCompletion(@Body(&#x27;content&#x27;) content: string): Promise&lt;string&gt; &#123; console.log(content); const data = await this.appService.createChatCompletion(content); console.log(data); return data; &#125;&#125;// service 层，调用 openai 接口import &#123; Injectable &#125; from &#x27;@nestjs/common&#x27;;import &#123; openai &#125; from &#x27;../ai&#x27;;import &#123; DEFAULT_MODEL &#125; from &#x27;ai/const&#x27;;@Injectable()export class AppService &#123; async createChatCompletion(content: string): Promise&lt;any&gt; &#123; const response = await openai.createChatCompletion(&#123; model: DEFAULT_MODEL, messages: [&#123; role: &#x27;user&#x27;, content &#125;], &#125;); return response.data.choices[0].message; &#125;&#125; 跨域怎么解决? 直接 cors 允许即可 12345678async function bootstrap() &#123; const app = await NestFactory.create(AppModule); // 允许跨域 app.enableCors(); await app.listen(3000);&#125;bootstrap(); 完成简单的回答，很 OK 简单的 MVP 版本 以上。","categories":[],"tags":[{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"人工智能","slug":"人工智能","permalink":"https://laputaz.github.io/home/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"ai","slug":"ai","permalink":"https://laputaz.github.io/home/tags/ai/"}]},{"title":"回顾：Marketing 和 SEM 的相关知识","slug":"回顾-sem的相关知识","date":"2023-06-16T19:06:34.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"回顾-sem的相关知识/","link":"","permalink":"https://laputaz.github.io/home/%E5%9B%9E%E9%A1%BE-sem%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"在 admin 和 marketing 团队的时候，接触了市场营销和 sem 相关的知识，这里总结一下。","text":"在 admin 和 marketing 团队的时候，接触了市场营销和 sem 相关的知识，这里总结一下。 什么是 MarketingMarketing 也就是市场营销。主要职责是通过各种手段推广公司的产品，制定特殊的活动等，以提升收益。 什么是 SEMSEM 就是搜索引擎营销 （Search Engine Marketing，缩写为 SEM）。简单来说，就是利用用户对搜索引擎的依赖和使用习惯，提升自身网站的排名和曝光。 但 sem 不等于 seo，seo 单纯是让自身网站遵守 seo 规则，或者利用搜索引擎的抓取规则，来提升自身的排名。而 sem 还包括付费收录，关键字竞价，设置精准的投放目标等等。 以 google 搜索为例，流程： 常用的工具sem 只是推广的其中一种形式，另外的推广营销方式还包括网站广告投放，社交媒体广告投放，还有联盟营销 (Affiliate marketing)，邀请奖励等。在我司，主要是通过 google ads 和配套的第三方工具，以及内部工具实现的。 主要工具： sem 和网站广告投放： google ads (google 搜索引擎 naver 的广告平台) naver ads (韩国搜索引擎 naver 的广告平台) display &amp; video 360 (用于管理广告视频图片素材) marketing automation admin (公司内部实现的 admin 系统，通过前两者的 api，简化一些重复的操作) 社交媒体广告投放： FaceBook、Twitter (运营一个账号) 抖音 （运营一个账号） 微信、WhatsApp、等等（提供指定的分享格式，追踪链接+主图） 联盟营销： 内部 Affilate 平台（提供几种形式的广告类型，生成代码，使用者嵌入到自己的网站，当产生点击时，使用者可以获得收益） 邀请奖励： 邀请和被邀请页面（用户可以邀请其他人注册，注册并成功下单后，可以获得奖励） SEM 的常见指标 Metric Formula Comment Click Through Rate (CTR) Clicks / Impressions 点击率，广告的点击次数/广告的曝光次数 Cost Per Click (CPC) Cost / Clicks 每次点击付费，出价/广告的点击次数 Conversion Rate (CVR) Orders / Clicks 转化率，简言之就是用户点击广告到成为一个有效激活或者注册甚至付费用户的转化率 Average Order Value (AOV) Revenues / Orders 收益/订单数量 Cost Per Acquisition (CPA) Cost / Orders 每行动成本 Returns On Ad Spend(ROAS) Revenues / Cost 广告支出回报率，这是 SEM 的关键指标 google ads 一般会提供一个报表 Search Query Report（SQR），其中便会包含上述大多数指标。marketing 同事再根据指标调整搜索关键字的出价。 marketing automation admin 的常见工具 SQR Toolsem 关键字匹配的模式有很多种，例如精确匹配，模糊匹配，否定，竞品关键字。SQR Tool 从 google 定期拉取 Search Query Report。筛选掉无用的指标数据，存储到 bigQuery。市场同事再根据指标，调整关键字的匹配类型，以及 landingpage（到达页）。例如将 “携程” 设置为竞品关键字。将 ‘hongkong’ 关键字的到达页设置为 “www.xxx.com/city/hongkong&quot;。这样市场同事就可以批量修改关键字设置，不需要一个一个地在 google das 上修改。 sem alert广告会出现一些异常的场景。例如： 广告设置不当被拒, ad disappear。 广告定位错误。 广告是存在地区限制的, 例如设置香港的广告只在香港，不能出现在其他地区亦或者是非目标人群等。 一段时间内某个广告的支出超出预算百分比，例如超出预算 5%。 没有获得预期点击次数的广告。 … … 这些异常的场景，会导致成本被浪费。当然，出现这些场景的时候，google 一样会提供数据报表。所以 sem alert 平台，可以自定义与预警，例如输入代码： 1select A from table B 将这段代码定义为’严重‘， 并每日执行，结果通知到 &#x78;&#120;&#120;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;由此检测告警，市场同事再到 google ads 检查对应的设置。 Campaign manager tool在投放 display 类型的广告时，即如下广告： 这种广告需要媒体素材的支持，指定尺寸的图片，视频。如长度为 6s 的 mp4。 该工具用于为每个 campaign 上传媒体资源。 sem setting tool除了关键字相关的设置，还有一些公共的设置，例如账号的预算池，这种设置是所有 campaign 共享的。sem setting tool 也是用于快速批量设置，而不是到 google ads 手动操作。 sem experiment toolgoogle ads 同样有实验机制，即同一个广告系列，更改部分参数作为实验组，最后验证实验组和控制组哪个效果更好，以此来改进广告系列的设置。sem experiment tool 用于快速创建实验，只关注默认的几个选项，其余设置均为默认值。大致长这样： naver bidding toolnaver 是韩国的搜索引擎，有一个很特殊的竞价规则。naver 的规则是出价第二的人，将会赢得竞价。该工具定时抓取关键字及关键字所在的排名，并自动更改出价策略。 sem feed back针对投放出去的页面，会检测用户的离开行为，当用户尝试离开时，弹出反馈收集的弹窗。由于我们不可能阻止用户关闭页面，所以以下行为会被侦测为 attempt to leave (尝试离开)：web: 鼠标快速离开窗口 鼠标移动至窗口以下 30px 的范围 切换 tab mweb: 滚动一定距离后，往上回滚（可能用户想要看到地址栏输入框） 在侦测到行为以后，弹出反馈收集的弹窗，并记录用户选择的离开的原因。 Ad copy tool搜索引擎出现的一个广告，通常分为以下模块： 其中，description，ad extension 等都是需要手动设置的。 该工具提供了批量上传（文件）的功能。 以上","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"sem","slug":"sem","permalink":"https://laputaz.github.io/home/tags/sem/"}]},{"title":"回顾：vue-cli老项目升级vite踩坑指南","slug":"回顾-vue-cli老项目升级vite踩坑指南","date":"2023-06-14T19:06:34.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"回顾-vue-cli老项目升级vite踩坑指南/","link":"","permalink":"https://laputaz.github.io/home/%E5%9B%9E%E9%A1%BE-vue-cli%E8%80%81%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7vite%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/","excerpt":"公司的项目大部分都是 2B 类型的中后台 PC 端项目，且业务都非常庞大。常年累月的维护下，使用 webpack dev 速度变得非常慢。因为最近的工作主要是负责一些前端的基础设施建设，各个业务线的产品都有一定的接触。有一个项目在我的电脑上面 npm run dev 居然要 6 分钟之久，实在是难以感到愉悦。加上公司内部已经新项目使用 vite 作为构建工具，所以挑选了一个自己比较熟悉的老项目(vue-cli)进行 vite 迁移。并将过程进行了记录。","text":"公司的项目大部分都是 2B 类型的中后台 PC 端项目，且业务都非常庞大。常年累月的维护下，使用 webpack dev 速度变得非常慢。因为最近的工作主要是负责一些前端的基础设施建设，各个业务线的产品都有一定的接触。有一个项目在我的电脑上面 npm run dev 居然要 6 分钟之久，实在是难以感到愉悦。加上公司内部已经新项目使用 vite 作为构建工具，所以挑选了一个自己比较熟悉的老项目(vue-cli)进行 vite 迁移。并将过程进行了记录。 项目背景先简单说明一下项目的情况： 内容：2B 的 PC 端中后台管理系统，是一个双入口的应用（登录页一个入口，管理系统一个入口）。 构建工具：vue-cli-service 技术栈：vue 2.6 + Axios + Vuex + Vue-Router + sf-vue-componet(公司内部组件库) + ElementUI 维护时长：3 年+，（实际上应该远远超过五年，这个项目是以一个已经维护了很久的项目为基础进行开发的，而当前最早的一条 commit 记录是 3 年前，但是这个基础项目已经开发很久时间了） 模块数量：6000（npm run serve 时显示的模块数量） 业务代码量：19.3W 行 兼容性要求：IE11 项目的体量在公司内部只能算是中等，之所以挑选这个项目进行处理是因为对这个业务比较熟悉。话不多说，开搞。 思路分析本次的目的不是直接用 vite 替换 vue-cli，而是想同时保留 vite 和 vue-cli。除去影响开发体验也主要是集中在 dev 这一块的原因外，还有以下两点： 产品需要兼容 IE11，尚不清楚 vite 在此方面有多少坑。步子迈太大了，可能扯着胯。 rollup 打包机制毕竟和 webpack 还是不同，且业务也比较复杂。修改完成之后也很难保证所有业务都能测试到位。 webpack 和 vite 本质上都是入口文件 + 依赖分析 + 模块转换。vite 是 使用的时候进行处理（vite 针对第三方库有同样会进行预处理），webpack 则是先全部处理完毕。当浏览器天然支持 ES module 之后，实时处理变得可能。这也是 vite 启动速度快的原因。所以，从理论上来说，从 Vue-cli 迁移到 vite 是可行的。 开始迁移step1 分析 vue.config.js首先，我们先进行 vue.config.js 进行分析。主要是把一些插件，和比较特殊的配置整理出来。然后再去 vite 官网和社区查看，看是匹配的配置或者插件。把其中不匹配的部分进行解决，估计迁移也就差不多了。 分析完成之后主要两点无法匹配的情况 1234567891011121314// vue.config.jsmodule.exports = &#123; chainWebpack: (config) =&gt; &#123; config.plugins.delete(&#x27;preload-loginPlatform&#x27;); config.plugins.delete(&#x27;prefetch-loginPlatform&#x27;); config.plugins.delete(&#x27;preload-platform&#x27;); config.plugins.delete(&#x27;prefetch-platform&#x27;); &#125;, transpileDependencies: [ &#x27;@sxf/cloudsec-components&#x27;, &#x27;@sxf/validations&#x27;, &#x27;@sxf/sf-vue-component&#x27;, ],&#125;; chainWebpack 中的配置主要是为了解决两个入口资源互相加载的问题，即访问登录页时，会预加载管理系统资源。由于这个是打包后在生产环境中才会用到的内容，且这次迁移无需关系打包的内容，所以暂时不用处理。transpileDependencies 主要是让 node_modules 中的文件也进行 babel 的处理，而我们在开发时可以使用最新的浏览器，完全可以不用 babel，所以这个问题也不用处理。 https://cli.vuejs.org/zh/config/#transpiledependencies step2 安装依赖，添加 scripts一般情况下，会需要用到以下的 npm 包。 vite vite-plugin-vue2：vite 支持 vue2 的插件（默认情况下，vite 并不支持 vue） vite-plugin-eslint（可选）：vite eslint 插件，用于在 run dev 时，实时校验 eslint vite-plugin-legacy（可选）：处理浏览器兼容性，本次这里不需要。 vite-plugin-mock（可选）：mock 数据 1yarn add vite vite-plugin-vue2 -D # 这里只安装了必要的vite 与 vite vue2插件 然后添加 package.json 中 添加 scripts 命令。 12345678// package.json&#123; ..., &quot;scirpts&quot;: &#123; ..., &quot;dev&quot;: &quot;vite&quot; &#125;&#125; step3 编写 vite.config.js 文件因为原本的 vue.config.js 不是特别复杂，网上也有其他迁移的文章讲解如何迁移 webpack 配置，所以我这里直接粘贴结果。 1234567891011121314151617181920212223242526272829303132333435363738394041const &#123; createVuePlugin &#125; = require(&#x27;vite-plugin-vue2&#x27;)const &#123; resolve &#125; = require(&#x27;path&#x27;);const config = require(&#x27;./config&#x27;);module.exports = &#123; server: &#123; host: &#x27;0.0.0.0&#x27;, https: true, port: 4433, proxy: &#123; &#x27;/platform&#x27;: &#123; target: `https://$&#123;config.host&#125;`, secure: false, changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/platform/, &#x27;&#x27;) &#125;, ... // &#125; &#125;, resolve: &#123; alias: &#123; &#x27;@&#x27;: resolve(__dirname, &#x27;./src&#x27;), &#x27;src&#x27;: resolve(__dirname, &#x27;./src&#x27;), &#x27;home&#x27;: resolve(__dirname, &#x27;./src/home&#x27;), &#x27;components&#x27;: resolve(__dirname, &#x27;./src/components&#x27;), &#x27;assets&#x27;: resolve(__dirname, &#x27;./src/assets&#x27;), &#x27;utils&#x27;: resolve(__dirname, &#x27;./src/utils&#x27;), &#125; &#125;, build: &#123; // 这里是build时才会用到，所以这里可以省略 rollupOptions: &#123; input: &#123; login: resolve(__dirname, &#x27;./public/login_platform.html&#x27;), platform: resolve(__dirname, &#x27;./public/platform.html&#x27;) &#125; &#125; &#125;, plugins: [ createVuePlugin() ]&#125; 从上面的结果来看其实只用写三个部分的内容： serve: 开发时的运行端口，以及数据请求的反向代理的规则 alias: 别名 plugins: 引入 vite-plugin-vue2 用于加载 vue 文件。 关于多入口在项目介绍的时候说到，项目是一个多入口的文件。实际上在 vite 的开发环境中，多入口无需配置。启动文件之后直接访问对应的 html 资源即可。 关于 wp2vitehttps://github.com/tnfe/wp2vite (一个前端项目转换工具，可以让 webpack 项目支持 vite) wp2vite 能够将根据你当前的 webpack 配置生成 vite 配置（支持 vue-cli），如果不想手写 vite.config.js 可以使用该工具进行自动转换。我是在撰写本文整理资料时，才发现有此工具。 wp2vite 转换的结果并非完全正确，存在以下问题。 alias 添加了一些莫名其妙的别名 （也有可能是 Feature :smile:） proxy 配置 rewrite 不正确 以上两点，各位同学在参考的时候注意一下就行。 step 4 调整入口文件与 vue-cli 有区别的是，vite 默认只能将 html 作为入口文件，所以需要对 HTML 内容进行调整。 别忘记给 script 标签添加 type=”module” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- index.html 主应用的入口文件 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; ... &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot; /&gt; &lt;title&gt;...&lt;/title&gt; &lt;!-- 添加这一行直接引入之前的 入口文件 --&gt; + &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong &gt;We&#x27;re sorry but project doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong &gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- login.html 登录页的入口文件 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; ... &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot; /&gt; &lt;title&gt;...&lt;/title&gt; &lt;!-- 添加这一行直接引入之前的 入口文件 --&gt; + &lt;script type=&quot;module&quot; src=&quot;/src/login.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong &gt;We&#x27;re sorry but project doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong &gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; step 5 npm run dev直接运行 npm run dev，可以发现 vite 马上就开启了服务。相对于原来 70s 左右的时间，这快了可不止一星半点，简直就是火箭起飞。 当然，服务的启动并不代表迁移已经完成。vite 更多的是在访问对应的资源时才会去处理内容。所以需要访问对应的页面来进行验证。而真正的迁移，才刚刚开始。 无尽采坑：阶段一问题 1：URIError: URI malformedvite 开启之后，访问登录页 https://localhost:4433/static/login_platform.html，报错 URIError: URI malformed 这是 decodeURIComponent 函数在执行时报的错。通过在错误堆栈中，加上 console 语句，得知出错的 URI 是/static/%3C%=%20BASE_URL%20%%3Efavicon.ico对应的代码则是 login.html 中的代码，这里的 BASE_URL 是 vue-cli 中模板变量的写法，这里可以修改为/public/favicon.ico（根据自己的目录结构调整，切勿盲目套用） 123456789&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;/&gt;=&gt;&lt;link rel=&quot;icon&quot; href=&quot;/public/favicon.ico&quot;/&gt; 修改完成之后，vite 则提示去掉 public 前缀，那我们直接去掉就行。 问题 2：Failed to resolve import “xxx” 提示找不到对应的 vue 文件（实际肯定是有）。经过查阅资料这一块主要是为了类型提示的问题（ts 的项目）,vite 不在自动查找.vue 扩展名的文件。这里只需要补全 PageLogin.vue 即可。 在这里补全.vue 扩展名不太现实，因为项目里面大部分都是省略了扩展名的。好在官方给出了解决的方案，直接配置即可。 https://cn.vitejs.dev/config/#resolve-extensions 1234567resolve.extensions类型： string[]默认： [&#x27;.mjs&#x27;, &#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.jsx&#x27;, &#x27;.tsx&#x27;, &#x27;.json&#x27;]导入时想要省略的扩展名列表。注意，不 建议忽略自定义导入类型的扩展名（例如：.vue），因为它会影响 IDE 和类型支持。 配置 resolve.extensions 的方式，并不能够完全的解决问题。这里卖个关子，后面会继续遇到因为缺少.vue 扩展名而导致的问题。那里会给出完美的解决方案。 问题 3: less import修复完问题 2 之后，继续访问页面。这个时候又出了新的问题。 经过查阅资料，vite 对 less 和 sass 文件的 import 进行了优化的处理，不在需要在别名前添加 ~符号来进行识别。 123vite 为 Sass 和 Less 改进了 @import 解析，以保证 vite 别名也能被使用。另外，url() 中的相对路径引用的，与根文件不同目录中的 Sass/Less 文件会自动变基以保证正确性。由于 Stylus API 限制，@import 别名和 URL 变基不支持 Stylus。 这里就只需要全局搜索然后全局替换就行，如果有发现全局没有替换到的（多了空格什么的），手动替换一下就行。 问题 4：net::ERR_ABORTED 408 (Request Timeout)修复好问题 3，再次访问时出现很多资源 408 的错误。 出现这个问题不要慌，重新刷新即可，这是 vite 在对一些依赖进行预构建。因为是请求到对应的资源才会进行预构建，在碰到需要预构建的包后，vite 直接返回了 408。 有时候需要重新刷新多次，每次构建完成之后重新刷新，如果发现新的需要预构建的依赖会再次返回 408 至于这里为什么返回 408，而不是直接挂起请求预构建完成之后再返回，个人不是很清楚。有了解 vite 原理的同学可以解答下。 1234vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import &#123; debounce &#125; from &#x27;lodash-es&#x27; 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。通过预构建 lodash-es 成为一个模块，我们就只需要一个 HTTP 请求了！ 问题 5：Vue warn：runtime-only等待所有内容都预构建完成之后，又出现了新的问题。 这里问题比较好理解，vue 的默认引用的内容是不包含模板编译功能的。因为之前使用的是 vue-cli，毕竟是一家的东西 vue-cli 针对这个情况做了特殊的处理。 这种情况在 vite.config.js 中，添加一条别名即可解决。 1234567891011// vite.config.js&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: resolve(__dirname, &#x27;./src&#x27;), ......, &#x27;vue&#x27;: require.resolve(&#x27;vue/dist/vue.esm.js&#x27;) &#125; &#125; &#125; 问题 6：require is not defined 这里继续爆出来 import 的问题，但是这里肯定不是因为确实 .vue 扩展名引起的。经过分析，问题的原因是业务代码中使用了 require 语句，而 vite 主要是依赖于 ES module 机制。这也就导致无法识别该业务代码，进而导致该模块加载失败。 123这里吐槽下，这里 vite 控制台 和 浏览器控制台爆出了不同的错误，而 vite 控制台的错误信息完全没法排查思路。而在迁移前期，一直盯着 vite 控制台，这就导致一个很简单的问题实际上花费了很多的时间。 这种情况下，需要手动对业务代码进行处理。 12345678&#123; image: require(&#x27;@uedc/login/dist/static/copyright/copyright-zh_CN@2016-2021.png&#x27;);&#125;// =&gt;import copyright from &#x27;@uedc/login/dist/static/copyright/copyright-zh_CN@2016-2021.png&#x27;;&#123; image;&#125; 采坑阶段一总结修改完上述问题之后，本项目的多入口应用中的一个登录页面入口，终于可以正常展示了。 vite 控制台，chrome 控制台均无报错 之前修改的 require 改为 import 的 logo，正常显示 通过网络请加载的验证码，正常显示（说明反向代理这些都是正常的） 虽然遇到问题还是比较多，但是解决起来都不是很费时间，排查起来也比较顺利。至此迁移工作可以说已经进行了一半。除去 html 模板文件中修改 favicon.ico 和导入图片的 requrie 之外，没有改动其他的业务代码，对业务的入侵很小。话不多说，输入账号密码，开启第二个阶段的采坑。 无尽采坑：阶段二问题 7： uses lang html for template 这是一个相当无语的错误，应该是 vite-plugin-vue2 插件的 bug。问题的原因是在 template 中，写了 lang=”html” 123&lt;template lang=&quot;html&quot;&gt; &lt;div&gt;.....&lt;/div&gt;&lt;/template&gt; 虽然模板默认就是 html，这个声明时多此一举，但是报错感觉不应该。好在这个问题比较好解决，通过查找字符串全局替换即可。你问我为什么要多此一举要声明 lang=”html”?我也不知道，这不就是老项目的魅力嘛。 问题 8： npm 包出错 这也是本次迁移过程中，最为棘手的问题。不止一个 npm 包出错，且出错的内容也不一样。有些出错可以通过 vite 的配置解决，有些则无法解决。 一般来说有以下几种方法来解决 npm 包报错的问题。 方法一：修改别名，指向源码即在 vite.config.js 中添加 alias 1&#x27;@sxf/sp-qrcode&#x27;: resolve(__dirname, &#x27;./node_modules/@sxf/sp-qrcode/src/index.js&#x27;), 这种方法适用于 npm 包的源码是用 ES module 规范编写的，且上传的 npm 包中包含了源码。 方法二：修改别名，指向 esm 格式的打包文件修改方式同方法一，只不过是执行打包后的 esm 文件。这种方式适用于 npm 包已经 build 了 esm 模块的内容，但是未在 packages.json 中提供 module 字段指向对应的文件。一般开源的，使用人数较多的 npm 包不会出现这种情况，只是因为这次出问题有一些是内部的包，确实存在 build 了 esm 的文件，但是没有在 package.json 中指明的情况。 方案三：optimiziDep.include默认情况下，不在 node_modules 中的，链接的包不会被预构建。使用此选项可强制预构建链接的包。 从官网的文档的描述信息来看 optimiziDep.include 是无法解决 npm 包出错的问题。因为不管怎样，node_modules 中的内容都会被预构建。但是从实际的使用中来看 在 vite 2.4.4 中，optimiziDep.include 能够解决部分 npm 加载的问题。 在 vite 2.5.3 中，optimiziDep.include 不再起作用。 因为 vite 一直在高速迭代，保不齐部分情况下此方法依旧有用。 方案四：参考问题 10问题 10 也是 npm 出问题，但是这个问题比较具有代表性，所以单独拿出来。 方案五：换个 npm 包，或者修改 npm 包如果上面三种方案都无法解决，那就只能从 npm 包本身下手了。 对于自己内部维护 npm 包，可以重新打包一个 ES module 的文件并发布。这里推荐用 rollup 打包，能够很轻松的构建 CommonJS、ES module、UMD、IIFE 格式的文件 对于第三方的 npm 包，出现这种情况应该是很久没有维护了，所以也应该换一个了。 问题 9：Failed to resolve entry (ops，same proplem)出现问题原因与问题 2 相同，也是因为没有.vue 扩展名的问题。 @sxf/cloudsec-component 是一个自己维护的业务组件库，基于基础的 UI 组件库，将一些常用的业务进行封装，单独发布一个 npm 包。主要是为了方便同一个开发团队维护多个产品（这点与公司组织架构有一定的关系，不在深究）。因为业务组件需要调试的原因，npm 发布的是.vue 的源码。同样因为保持着相同的编码规范，业务中对组件库的引用，以及组件库本身开发时的互相引用都是省略了.vue 扩展的。而以上两种方案都无法通过 resolve.extensions 解决。 123在 vite 2.4.4 的版本中，配置了 resolve.extensions 之后，无法识别 vue-router 中的 () =&gt; import(&#x27;foo/bar/baz&#x27;)这个问题在 vite 2.5.3 中进行了修复，如果出现了此类问题，可以升级一下 vite 版本。 解决方案一：人肉修改人肉一个个修改，这种情况适用于刚开始不久的项目。但是对于一个维护数年的老项目来说，这基本不现实。20W 行左右的代码，几千个 vue 文件。作为程序员明显不能这么干活。 解决方案二：vite 插件vite 插件的第一个例子就是讲的引入一个虚拟文件，这里的问题其实类似。就是没有补充扩展名，导致找不到，那么可以通过插件查找。 这里提供一下伪代码，未进行实际的验证。 因为这只是解决了 vite 加载的问题，但是没有解决类型提示的问题，这对于后续进行 ts 相关改造不友好，所以没有去验证此方案。 感兴趣的可以验证一下，个人在实际的业务中是采用的方案三。 123456789101112module.exports = function () &#123; return &#123; name: &#x27;vite-plugin-fix-vue-ext&#x27;, resolveId(id) &#123; // 判断是否需要补充后缀，如果需要则返回id，表示命中。 if (isNeedFixExt(id)) return id; &#125;, load(id) &#123; if (isNeedFixExt(id)) return fs.readFileSync(fixExt(id)); &#125;, &#125;;&#125;; 问题 10： does not provide an export named ‘default’这个问题是因为第三方的 npm 包是提供的是 CommonJS 规范的文件。 1CommonJS 和 UMD 兼容性: 开发阶段中，vite 的开发服务器将所有代码视为原生 ES 模块。因此，vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。 vite 官网说，会兼容 CommonJS 格式的文件，但是这里为什么还是因为 CommonJS 格式的问题呢？其实这个文件是可以 import 导入的只是并没有提供 default 这个属性，这么说 vite 也确实支持了 CommonJS。遇到这种情况我们需要引入 @originjs/vite-plugin-CommonJS 这个包 123456789const &#123; viteCommonJS &#125; = require(&#x27;@originjs/vite-plugin-CommonJS&#x27;);module.exports = &#123; plugins: [ viteCommonJS(&#123; include: [&#x27;procurios.resizesensor&#x27;], &#125;), createVuePlugin(), ],&#125;; 采坑阶段二总结在 主入口页面的迁移过程中，改动了非常多的代码。 业务代码 293 个文件 业务组件的代码 139 个文件 但是修改这些文件大多数没有修改业务，只是补全了链接。但是 less 的文件 import 却是和 webpack 不兼容。此外，还有有一些有问题的 npm 包，这次迁移的过程并没有完全解决,只是将对应的代码给注释。最终通过以上措施，终于能够访问了，也看到了主入口的页面。 最终总结vite 优点大家都知道，我主要来说一下现阶段的缺点。总的来说现阶段的 vite 还存在以下问题： 手动重新 npm run dev 后，预构建之后缓存丢失，而修改 vite.config.js 导致的自动重启不会。 预构建需要访问到对应的文件才能触发，会导致频繁 408，且速度非常慢。整个下来时间比较久，而且需要你手动刷新浏览器。比较奇怪的是 vite 2.4.4 在这方面 比 vite 2.5.3 快非常多，基本上只会出现一次 408。 无法很好的处理非 ES module 的 npm 包，与 webpack 还存在一定的差距。 请求数量巨大，从 network 的面板来看，请求的数量高达 468，除去 XHR 请求之外也有将近 400 个请求。所以首次加载的时间比较慢大概花了 5 秒，这一块应该是可以通过 vite 的配置来优化。等内部的一些 npm 包调整完毕能够进行正常的开发之后，会总结一些开发的实践并发出来。 功能不稳定。在早期使用 vite 2.4.4 进行迁移时，问题稍微还多一些。之后更新到 vite 2.5.3 之后，部分问题被修复了，但是也增加了一些新的问题。 针对老项目需要迁移到 vite，需要考虑以下情况： 不在支持非 ES module 的业务代码（如 require，module.exports），如果有这些代码需要进行调整，可以尝试与问题 9 相同的方式。 less/sass 的@import: vite 不在需要 ~ 来使用别名，这一点与 webpack 不兼容。 因为 IE11 天然不支持 ES module，所以 IE 调试比较麻烦，不建议需要支持 IE11 的项目将 vite 作为唯一的构建工具。 现阶段的 vite 对 npm 包有着较高的要求，迁移之前可以先看下项目的 npm 包，该替换的替换，该升级的升级。 整体来说，vite 的开发体验比较好，轻量且快。即便是一个臃肿的老项目也能够做到反应迅速且不占用过多资源。项目较大时 webpack 启动时会占用大量的电脑资源，导致这一段时间 VSCode 非常卡，这一点体验非常不好。","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"踩坑","slug":"踩坑","permalink":"https://laputaz.github.io/home/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"进制（四）：利用二进制解码 wbmp 并转换为 png 图片","slug":"进制（四）利用二进制解码wbmp并转换为png图片","date":"2023-05-18T12:30:56.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"进制（四）利用二进制解码wbmp并转换为png图片/","link":"","permalink":"https://laputaz.github.io/home/%E8%BF%9B%E5%88%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%A9%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A7%A3%E7%A0%81wbmp%E5%B9%B6%E8%BD%AC%E6%8D%A2%E4%B8%BApng%E5%9B%BE%E7%89%87/","excerpt":"上一篇文章介绍了 ArrayBuffer，刚好实际场景中就有运用到 - wbmp 图片转换。demo：https://laputaz.github.io/wbmp-convert/","text":"上一篇文章介绍了 ArrayBuffer，刚好实际场景中就有运用到 - wbmp 图片转换。demo：https://laputaz.github.io/wbmp-convert/ 背景admin需要做一个对接 google ads 的工具, 以简化市场同事在做广告投放时做的一些重复性操作。其中涉及到一个流程: 将图片/zip/视频上传到服务端存储, 上传前需要校验图片的尺寸是否符合要求。 其中有一种图片格式是 wbmp , 这种格式浏览器并不支持, 所以需要转换成 png，再去判断尺寸。其中就涉及到了 js 中的二进制转换。 什么是 wbmpwbmp 是一种图像格式，只支持 1 位颜色，即 wbmp 图像只包含黑色和白色像素。但目前 chrome 、Safari 都不支持，估计是比较陈旧的格式了，在前端使用的场景太少了，几乎没有见到。 wbmp 的存储形式（文件结构）wbmp 包含头部和图片数据： 头部： 第一个字节表示图片类型，目前只有 0，即非压缩的黑白位图。 第二个字节固定是 0 第三个字节开始，是图片的宽和高，使用多字节整数格式存储。 多字节整数：一个多字节整数由一个或多个字节构成，每个字节的左边第一位表示后边的字节是否为当前整数的一部分。如果当前字节的左边第一位为 0，表示后面没有更多的字节了，该多字节整数结束；如果当前字节的左边第一位为 1，表示后边的字节也用来构成该多字节整数。 图片数据： 剩下就是图像数据了，每一个 bit 表示一个像素：1 表示白色，0 表示黑色。 示意图： 思路 将 wbmp 读取为 arraybuffer，以读取二进制数据。 读取 wbmp 文件的宽高。 新建一个 canvas，设置画布的宽高。 canvas 绘制图片时，每个像素由 rgba 四个值组成，因为只有黑白，则读取成 255，255，255，255 白色 0，0，0，0，255 黑色 输出图片 DataURI 实现写一个 input，type=file，用于选择文件，并绑定选择事件，将选择的文件转换为 ObjectUrl 提供给 img12345678910&lt;input type=&quot;file&quot; /&gt;&lt;hr /&gt;&lt;img src=&quot;&quot; alt=&quot;no img yet&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;script type=&quot;module&quot;&gt; const inputElement = document.querySelector(&#x27;input&#x27;) inputElement.addEventListener(&#x27;change&#x27;, function (e) &#123; let img = document.querySelector(&#x27;img&#x27;) img.src = URL.createObjectURL(e.target.files[0]) &#125;)&lt;/script&gt; 选择正常的图片，展示没有问题 选择 wbmp 文件，可以看到，Chrome 并不支持。 改造一下，引入 wbmp.js 文件，暴露一个方法。 该方法接受 ArrayBuffer 对象，转换成 png, 最终返回 png 的 dataURI。 1234567891011121314151617181920&lt;input type=&quot;file&quot; /&gt;&lt;hr /&gt;&lt;img src=&quot;&quot; alt=&quot;no img yet&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;script type=&quot;module&quot;&gt; // 暴露一个方法 decodeWBMP import &#123; decodeWBMP &#125; from &#x27;./wbmp.js&#x27; const inputElement = document.querySelector(&#x27;input&#x27;) // 绑定事件 inputElement.addEventListener(&#x27;change&#x27;, function (e) &#123; // 读取图片 let img = document.querySelector(&#x27;img&#x27;) let reader = new FileReader() // 读取为 ArrayBuffer reader.readAsArrayBuffer(e.target.files[0]) reader.onloadend = function (e) &#123; // 返回一个 dataURI img.src = decodeWBMP(e.target.result) &#125; &#125;)&lt;/script&gt; 实现 wbmp.js 入口 123456export const decodeWBMP = function (arrayBuffer) &#123; // ... // ... // 最终返回 dataURI return dataURI&#125; 先建立一个视图，该视图每 8 位读取 arrayBuffer 1234// 8 位 8 位地读，也就是一字节一字节地读let bytes = new Uint8Array(arrayBuffer)// 起始字节 indexlet ptr = 0 定义一个方法，读取前两个字节，前面提到，这两个字节必须是 0 12345678910111213// 读一个字节function readOctet() &#123; return bytes[ptr++]&#125;try &#123; // 以 0 开始 if (readOctet() != 0) return false // 第二位也是 0 if (readOctet() != 0) return false&#125; catch &#123; return null&#125; 从第三位开始，读取多字节整数。 最后一个字节如果是以 0 开头，则结束 否则循环，拼接除了最高位以外的后续位 返回整数 代码 12345678910111213141516171819202122232425262728// 读取多字节整数function readMultiByteInt() &#123; let result = 0 while (true) &#123; // 读取下一位 let next = bytes[ptr++] // 左移7位 =&gt; 低位7位补零 result = result &lt;&lt; 7 // next &amp; 0b01111111 表示最高位变0，其余位置保留 result = result | (next &amp; 0b01111111) // 判断最高位是不是0，是的话结束。（肯定会有一个最高位为0的字节，作为多字节数结尾的字节） if (!(next &amp; 0b10000000)) &#123; return result &#125; &#125;&#125;//...//...// 紧接上个步骤// 以 0 开始if (readOctet() != 0) return false// 第二位也是 0if (readOctet() != 0) return false// 读取宽度let width = readMultiByteInt()// 读取高度let height = readMultiByteInt() 以 426 为例，存储状态为两个字节：1000001100101010，分析状态如图: 剩下的数据就是图片的像素点了！ 知道了宽高，画一个 canvas 画布，并 createImageData 拿到图片数据： 1234567// 建立一个 canvas，并建立一个图片数据let canvas = document.createElement(&#x27;canvas&#x27;)canvas.setAttribute(&#x27;width&#x27;, width)canvas.setAttribute(&#x27;height&#x27;, height)let ctx = canvas.getContext(&#x27;2d&#x27;)let imageData = ctx.createImageData(width, height)let data = imageData.data 接下来，往图片列逐行填充像素点，首先要知道 canvas imageData，每 4 位表示一个像素点，表示 R、G、B、A。例如一个只有 2 个像素点的 canvas 图片，data 数组为: 我们还需要一个知识，按位与可以用得知对应位置是否为 0。 例如：5 &amp; 4 即 0b101 &amp; 0b100 得到 4，则知道 5 的二进制的第 3 位不是 0例如：5 &amp; 2 即 0b101 &amp; 0b010 得到 0，则知道 5 的二进制的第 2 位是 0 代码： 1234567891011121314151617181920212223242526272829303132// 设置图片数据// rgbafunction write(bit) &#123; // 当前位不为0，则是白色，否则填充黑色 let color = bit ? 255 : 0 data[w++] = color // r data[w++] = color // g data[w++] = color // b data[w++] = 255 // a 透明度，不透明&#125;// 从上到下遍历每一行for (let y = 0; y &lt; height; ++y) &#123; // 从左到右遍历每一列的像素点。 // 每一个字节有 8 位，可以填充8个像素点，所以每次循环 +8 for (let x = 0; x &lt; width; x += 8) &#123; // 一个字节 8 位 let bits = bytes[ptr++] // 计算填充位置 let w = (y * width + x) * 4 // 8位，取每一位，判断当前位是否为 0 write(bits &amp; 0x80) // 0x80 即 10000000 write(bits &amp; 0x40) // 0x40 即 1000000 write(bits &amp; 0x20) // 0x20 即 100000 write(bits &amp; 0x10) // 类推 write(bits &amp; 0x08) // ... write(bits &amp; 0x04) write(bits &amp; 0x02) write(bits &amp; 0x01) &#125;&#125; 填充完以后，输出 dataURI 1234// 从 0 位置开始写ctx.putImageData(imageData, 0, 0)// 转换为 DataURIreturn canvas.toDataURL(&#x27;image/png&#x27;) 完整代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576export const decodeWBMP = function (arrayBuffer) &#123; // 8 位 8 位地读，也就是一字节一字节地读 let bytes = new Uint8Array(arrayBuffer) // 其实位 let ptr = 0 // 读一个字节 ptr++ function readOctet() &#123; return bytes[ptr++] &#125; // 读取多字节整数 function readMultiByteInt() &#123; let result = 0 while (true) &#123; // 读取下一位 let next = bytes[ptr++] // 左移7位 =&gt; 低位7位补零 result = result &lt;&lt; 7 // next &amp; 0b01111111 表示最高位变0，其余位置保留 result = result | (next &amp; 0b01111111) // 判断最高位是不是0，是的话结束。（肯定会有一个最高位为0的字节，作为多字节数结尾的字节） if (!(next &amp; 0b10000000)) &#123; return result &#125; &#125; &#125; try &#123; // 以 0 开始 if (readOctet() != 0) return false // 第二位也是 0 if (readOctet() != 0) return false let width = readMultiByteInt() let height = readMultiByteInt() // 建立一个 canvas let canvas = document.createElement(&#x27;canvas&#x27;) canvas.setAttribute(&#x27;width&#x27;, width) canvas.setAttribute(&#x27;height&#x27;, height) let ctx = canvas.getContext(&#x27;2d&#x27;) let imageData = ctx.createImageData(width, height) let data = imageData.data // 设置图片数据 for (let y = 0; y &lt; height; ++y) &#123; for (let x = 0; x &lt; width; x += 8) &#123; let bits = bytes[ptr++] let w = (y * width + x) * 4 // rgba function write(bit) &#123; let color = bit ? 255 : 0 data[w++] = color data[w++] = color data[w++] = color data[w++] = 255 // 透明度，不透明 &#125; write(bits &amp; 0x80) write(bits &amp; 0x40) write(bits &amp; 0x20) write(bits &amp; 0x10) write(bits &amp; 0x08) write(bits &amp; 0x04) write(bits &amp; 0x02) write(bits &amp; 0x01) &#125; &#125; if (ptr &gt; bytes.length) return null // 从 0 位置开始写 ctx.putImageData(imageData, 0, 0) // 转换为 DataURI return canvas.toDataURL(&#x27;image/png&#x27;) &#125; catch (e) &#123; // 出错了 return null &#125;&#125; 效果 以上","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"二进制","slug":"二进制","permalink":"https://laputaz.github.io/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"进制（三）：hex/rgb/hsl 色值, 实现转换工具","slug":"进制（三）hex和rgb色值和转换","date":"2023-05-17T21:40:42.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"进制（三）hex和rgb色值和转换/","link":"","permalink":"https://laputaz.github.io/home/%E8%BF%9B%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89hex%E5%92%8Crgb%E8%89%B2%E5%80%BC%E5%92%8C%E8%BD%AC%E6%8D%A2/","excerpt":"自给自足。代码：https://laputaz.github.io/color-converter/","text":"自给自足。代码：https://laputaz.github.io/color-converter/ 在线 Demo: https://laputaz.github.io/color-converter/ 背景在日常的 css 编写中，经常会和色值打交道，最常见的几种格式便是： 123color: #12fe21;color: rgb(123, 11, 56);color: hsl(0deg 48% 33%); 这三种色值分别称为：hex 色值，rgb 色值，hsl 色值。 色值组成那么这三种色值为什么是这么表示的呢？首先有一个“原色”的概念： 原色是指不能透过其他颜色的混合调配而得出的“基本色”。 –wiki 常见的说法是，三原色为：红、绿、蓝。但是这个说法不是固定的，“原色”并不是一个物理概念，而是一个生物概念，是指人的肉眼对于光线的生理作用。在显示，印刷，和绘画等领域，“三原色”定义都可能不一样。 而以上提到的三种色值表示法，使用的是三原色光模式 RGB (红、绿、蓝)。 hexhex 也就是 hexadecimal，十六进制表示法。因为是 16 进制，所以每一位的取值范围都是 0 ~ f, 其中:前 2 位代表红色的浓度，中间 2 位代表绿色浓度，最后 2 位代表蓝色浓度。 #ff0000 =&gt; 纯红色 #00ff00 =&gt; 纯绿色 #0000ff =&gt; 纯蓝色 当每两位数值一样的时候，可以简写，如： #f00 =&gt; 纯红色 一些浏览器支持 8 位，末尾两位为透明度： #ff000088 =&gt; 纯红色半透明 按照这种关系，那就可以随意组合了，例如： #ffff00 =&gt; 红色+绿色=黄色 #ff00ff =&gt; 红色+蓝色=品红 #00ffff88 =&gt; 绿色+蓝色+半透明=半透明靛青 rgbrgb 表示法，跟 hex 类似，只是采用了 10 进制表示数字，前面提到的 hex 表示法，用两位 16 进制数表示一个颜色，所以转换成十进制的话，一共有 16*16=256 种组合，即范围是 0 ~ 255： rgb(255,0,0) =&gt; 纯红色 rgb(0,255,0) =&gt; 纯绿色 rgb(0,0,255) =&gt; 纯蓝色 同样，可以增加一位，表示透明度，这个时候就要写成 rgba 了，其中 a 表示 阿尔法通道（α Channel或Alpha Channel）是指一张图片的透明和半透明度。，取值是 0 ~ 1。 rgba(0, 255, 255, 0.5) =&gt; 绿色+蓝色+半透明=半透明靛青 hslhsl 和 前面两种表示方式有一些区别，hsl 指的是 色相、饱和度、亮度（Hue, Saturation, Lightness） 色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100%的数值。明度（V），亮度（L），取 0-100%。 表示方式： hsl(0deg 100% 50%) =&gt; 纯红色 hsl(120deg 100% 50%) =&gt; 纯绿色 hsl(240deg 100% 50%) =&gt; 纯蓝色 同样，可以增加一位表示透明度, 改写成 hsla： hsla(240deg, 100%, 50%, 50%) =&gt; 半透明纯蓝色 色值转换这里主要说 hex 和 rgb 的转换，至于 hsl 比较复杂，它是将 rgb 使用的笛卡尔坐标系转换成用圆柱坐标系来表示，所以涉及到几何、向量等计算，早就忘光了。有兴趣可以看： hsl 的空间表示 HSL to RGB color conversion hex 转换成 rgb也就是每两位 16 进制转换成 10 进制，比较简单，如 ef 转换成 10 进制是 15 * 16**0 + 14 * 16**1。 代码实现： 1234567891011121314151617181920212223// 错误信息const WRONG_MESSAGE = &#x27;wrong format.&#x27;// 转换成 10 进制，柯里const pInt = (num) =&gt; parseInt(num, 16)// hex 转换成 rgbconst convertHexToRGB = (hex) =&gt; &#123; // 去掉 # let str = hex.replace(&#x27;#&#x27;, &#x27;&#x27;) // 判断剩下的长度是不是 3 、6 if (![3, 6].includes(str.length)) return WRONG_MESSAGE // 长度是 3，则拓展为 6 位 if (str.length === 3) &#123; str = `$&#123;str[0]&#125;$&#123;str[0]&#125;$&#123;str[1]&#125;$&#123;str[1]&#125;$&#123;str[2]&#125;$&#123;str[2]&#125;` &#125; // 每 2 位转换为 10 进制 (第1位 * 16^0 + 第2位 * 16^1) const R = pInt(str[1]) + pInt(str[0]) * 16 const G = pInt(str[3]) + pInt(str[2]) * 16 const B = pInt(str[5]) + pInt(str[4]) * 16 return `rgb($&#123;R&#125;,$&#123;G&#125;,$&#123;B&#125;)`&#125;// 使用convertHexToRGB(&#x27;#ff0000&#x27;) // 输出 rgb(255,0,0) rgb 转换成 hex将 10 进制数转换成 2 位的 16 进制数，思路是: 转换后的事必须是 2 位，所以第 2 位必须是能被 16 整除的，否则不可能进位 第一位最大是 15 (f) 数字减去 15 后，仍能被 16 整除，以这个思路不断循环即可，例如 (254 - 15) / 16 = 15，那么结果就是 15 15 =&gt; ff 或者更简单的是，直接用 toString()： 12const num = 255num.toString(16) // ’ff‘ 代码实现： 123456789101112131415161718192021222324252627282930const WRONG_MESSAGE = &#x27;&#x27;// 十进制转两位16进制//! 或者 const getOctal = (num) =&gt; num.toString(16)const getOctal = (num) =&gt; &#123; let count = 15 while (count &gt; 0) &#123; let res = (num - count) / 16 if (!(res + &#x27;&#x27;).includes(&#x27;.&#x27;)) &#123; return `$&#123;res.toString(16)&#125;$&#123;count.toString(16)&#125;` &#125; count-- &#125; return &#x27;ff&#x27;&#125;// 转换const convertRGBToHex = (rgb) =&gt; &#123; let arr = [] try &#123; arr = rgb.replace(&#x27;rgb(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;) &#125; catch (err) &#123; return WRONG_MESSAGE &#125; if (arr.length &lt; 3) &#123; return WRONG_MESSAGE &#125; const R = getOctal(arr[0]) const G = getOctal(arr[1]) const B = getOctal(arr[2]) return `#$&#123;R&#125;$&#123;G&#125;$&#123;B&#125;`&#125; Demo这里部署了一个在线的 Demo: https://laputaz.github.io/color-converter/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"},{"name":"二进制","slug":"二进制","permalink":"https://laputaz.github.io/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"进制（二）：Blob、File、ArrayBuffer、DataView、TypedArray","slug":"进制（二）Blob、File和ArrayBuffer","date":"2023-05-16T13:11:53.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"进制（二）Blob、File和ArrayBuffer/","link":"","permalink":"https://laputaz.github.io/home/%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89Blob%E3%80%81File%E5%92%8CArrayBuffer/","excerpt":"js 的进制转换第二篇，Blob、File、ArrayBuffer、DataView、TypedArray。","text":"js 的进制转换第二篇，Blob、File、ArrayBuffer、DataView、TypedArray。 上回说到，[js 中各个进制是怎么转换的](/home/进制（一） js的各种进制转换/)，接下来看看，二进制在 js 中的实际使用和如何操作。 背景实际开发的过程中，调用后端接口下载文件一般有两种方式 (以 axios 为例)： 一是后端存储文件，生成文件地址，前端拿到地址后打开，如 1234567// 返回的 url 为文件地址 http://xxx.xxx.xlsxaxios.post(`$&#123;BASE_URL&#125;/api`).then((res) =&gt; &#123; // open window.open(res.url) // location.href location.href = res.url&#125;) 二是以二进制流的形式返回，此时响应头设置的 content-type 为 application/octet-stream： 123456789101112131415161718192021222324const downloadFile = (file, fileName = &#x27;filename.xlsx&#x27;) =&gt; &#123; // 如果 response type 为 blob let blob = file // 如果 response type 为 arraybuffer，转换为 Blob if (file instanceof ArrayBuffer) &#123; blob = new Blob([file]) &#125; // 创建URL对象 const url = URL.createObjectURL(blob) const el = document.createElement(&#x27;a&#x27;) el.href = url el.download = fileName el.click() // 释放URL对象 URL.revokeObjectURL(url)&#125;// 返回二进制流axios .post(`$&#123;BASE_URL&#125;/api`, &#123; responseType: &#x27;blob&#x27;, // 或者 arraybuffer &#125;) .then((res) =&gt; &#123; downloadFile(res) &#125;) 这两种方式是很常用的 那什么是 Blob 和 ArrayBuffer 呢，与很少见到的 DataView、TypedArray，或者 常见的 File 有什么关系呢 解释理了一下之间的关系，大致如下。 Blob、File、ArrayBuffer 可以归为一类，它们都是数据或者说缓冲区； FileReader 算是一种工具，用来读取数据； DataView、TypedArray 是一种视图，视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 ArrayBuffer 中的字节。 BlobBlob (binary large object,二进制大文件对象)。表示一个不可变、原始数据的类文件对象。只可以 slice 拆分，不能进行细粒度的操作，细粒度的操作需要转换成 ArrayBuffer。 创建： 123let blobObj = new Blob(array, options)// array：一堆数据构成的数组//options：设置一些属性，主要是type属性 属性: 12size:数据的字节大小（只读）type:数据的MIME类型，例如&#x27;image/png&#x27;（只读） 操作方法: 123//start:分割起始点//end: 分割终点Blob.slice(start, end) FileFile 就是文件，继承自 Blob，也是二进制对象。（可以用在任意的 Blob 类型的 context 中。比如说，FileReader 就能处理 Blob 和 File）。有自己特有的属性和方法， 可以看到。 创建，类似于 Blob: 1234// array：一堆数据构成的数组// name: 文件名// options：设置一些属性，type属性、lastModifiedlet file = new File(array, name, options) 常见属性: 12345name：文件名size：文件大小lastModified ：最后修改时间（时间戳）lastModifiedDate: 最后修改时间Data对象type：MIME类型 File 继承于 Blob，所以也拥有 slice 方法。 1new File([1], &#x27;a.js&#x27;).slice() ArrayBufferArrayBuffer 是内存上一段二进制数据，我们可以借助工具 TypeArray、DataView 对它进行读写。 创建： 12let buffer = new ArrayBuffer(16) // 创建一个长度为 16 字节的 bufferconsole.log(buffer.byteLength) // 16 区别： ArrayBuffer 是底层二进制数据，可以视图 TypeArray、DataView 进行读写。 而 Blob 是对底层二进制数据的封装，js 获取到的是一个整体，能够读取他的大小，类型，但是不能看到细节。 Blob 作为一个整体文件，更适合用于传输；而只有需要关注细节（比如要修改某一段数据时），才需要用到 ArrayBuffer。 ArrayBuffer 转 Blob 1234// 使用 new Blob 即可把 ArrayBuffer 的二进制数据进行封装const arraybuffer = new ArrayBuffer(16)const blob = new Blob([arraybuffer])// Blob &#123;size: 16, type: &#x27;&#x27;&#125; Blob 转 ArrayBuffer 123// ArrayBuffer() 可以将 blob 转换成 ArrayBufferconst blob = new Blob([1])const arraybuffer = await blob.ArrayBuffer() FileReaderFileReader通过 fileReader 可以将 Blob、File 读取为不同的格式，常见： 将图片文件转换为 base64 123456789101112// FileReader.readAsDataURL(blob 将二进制数据读取并编码为 Base64 格式var file = document.querySelector(&#x27;input[type=file]&#x27;).files[0]var reader = new FileReader()reader.onload = (e) =&gt; &#123; // base64 console.log(e.result)&#125;// 转换成 base64reader.readAsDataURL(file)// 也可以转换为 arraybuffer -----------------reader.readAsArrayBuffer(file) TypedArrayTypedArray 没有直接的构造函数，常见的对他的实现有: 123456789101112131415161718// 下面代码是语法格式，不能直接运行，// TypedArray 关键字需要替换为底部列出的构造函数。new TypedArray(); // ES2017中新增new TypedArray(length);new TypedArray(typedArray);new TypedArray(object);new TypedArray(buffer [, byteOffset [, length]]);// TypedArray 指的是以下的其中之一：Int8Array();Uint8Array();Uint8ClampedArray();Int16Array();Uint16Array();Int32Array();Uint32Array();Float32Array();Float64Array(); Uint8Array —— 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字(00000000 ~ 11111111)，称为 “8 位无符号整数”。Uint16Array —— 将每 2 个字节视为一个 0 到 65535 之间的整数，称为 “16 位无符号整数”。Uint32Array —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数，称为 “32 位无符号整数”。Float64Array —— 将每 8 个字节视为一个 5.0x10-324 到 1.8x10308 之间的浮点数。 因此，一个 16 字节 ArrayBuffer 中的二进制数据可以解释为： 16 个“小数字” 8 个更大的数字（每个数字 2 个字节） 4 个更大的数字（每个数字 4 个字节） 2 个高精度的浮点数（每个数字 8 个字节）。 实例： 123let arr = new Uint8Array([0, 1, 2, 3])alert(arr.length) // 4，创建了相同长度的二进制数组alert(arr[1]) // 1，用给定值填充了 4 个字节（无符号 8 位整数） TypedArray 具有常规的 Array 方法，可以遍历（iterate），map，slice，find 和 reduce 等。但没有 splice —— 无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。也没有 concat 方法。 以上下一篇：运用 进制（四）：利用二进制解码 wbmp 并转换为 png 图片","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"二进制","slug":"二进制","permalink":"https://laputaz.github.io/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"进制","slug":"进制","permalink":"https://laputaz.github.io/home/tags/%E8%BF%9B%E5%88%B6/"}]},{"title":"进制（一）：js 中的各种进制转换","slug":"进制（一） js的各种进制转换","date":"2023-05-10T19:49:59.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"进制（一） js的各种进制转换/","link":"","permalink":"https://laputaz.github.io/home/%E8%BF%9B%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%20js%E7%9A%84%E5%90%84%E7%A7%8D%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"最近项目里涉及到了进制转换，顺带回忆一下二进制。。","text":"最近项目里涉及到了进制转换，顺带回忆一下二进制。。 背景javascript中很少会使用到二进制做处理, 但是最近开发时遇到了一个场景 : admin需要做一个对接 google ads 的工具, 以简化 marketing team 在做广告投放时做的一些重复性操作. 而其中涉及到一个流程: 将图片/zip/视频上传到 amazon aws s3 存储, 后端再上传到 google ads . 其中有一种图片格式是 wbmp , 这种格式浏览器并不支持, 所以需要转换, 其中就涉及到了 js 中的二进制转换。 计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位（比特）构成，即 1 个字节等于 8 个比特（1Byte=8bit） 二进制先复习一下二进制, 数字在计算机中使用二进制表示, 有两个注意点: 有符号位: 最高位不表示数值, 表示符号 补码表示: 以原码形式表示数值 原码以一个字节, 即 8 个二进制位为例, 第一位为符号位, 剩余为数字位 用原码, 可表示范围为: 11111111 ~ 00000000 ~ 01111111 按等比数列可得: - (2^7 - 1) ~ 0 ~ 2^7 - 1 即: -127 ~ 0 ~ 127 原码对人的识别友好, 但是在用原码计算时会出现问题: 100000001(1) + 10000001(-1) = 10000010(-2) 这不是我们想要的 反码反码是将数字位取反获得的, 其中规定: 正数反码, 为本身 负数反码, 数字位按位取反 即 11111111 的反码为 10000000 如果反码相加的话, 结果似乎是对的: 123456-127: 原码: 11111111, 反码: 10000000+127: 原码: 01111111, 反码: 01111111反码相加: -127 + 127 = 10000000 + 01111111 = 1111111111111111 转换为原码为: 10000000 (-0) 虽然结果是对的, 但是存在 -0 的情况, -0 和+0 是相等的, 没有意义 补码还有一种表示形式, 补码 正数补码, 本身 负数补码, 反码的基础上 +1 网络上很多文章提到, 补码是为了解决反码相加得出正负 0 而提出的, 虽然能说得通, 但是 在既不能证实也不能证伪的情况下，只能存疑 — 周孝正 我们不讨论反码补码因为什么出现的, 只说明反码补码解决了什么问题 补码确实可以解决相加正负 0 的问题 123456-127: 原码: 11111111, 反码: 10000000 补码: 10000001+127: 原码: 01111111, 反码: 01111111 补码: 01111111补码相加: -127 + 127 = 10000001 + 01111111 = 100000000100000000 最高位溢出, 剩余8位刚好为0 js 中图片转换 怎么用 js 进行进制转换 表示形式 各进制数值在 js 中的表示时的前缀 2 进制: 0b 8 进制: 0 10 进制: 无前缀 16 进制: 0x 其中要注意的是符号位还是用 +- 表示, 如十进制 -12 表示为 2 进制是 -0b1100 , 表示为 8 进制是 -014 , 表示为 16 进制是 -0xc , 转换方法 javascript 进制转换的方法主要有两个: parseInt: 其他进制转 10 进制 123456789101112// 按2进制解析parseInt(&#x27;-0b1100&#x27;, 2) // -12// 按2进制解析parseInt(&#x27;-1100&#x27;, 2) // -12// 按8进制解析parseInt(&#x27;-014&#x27;, 8) // -12// 按8进制解析parseInt(&#x27;-14&#x27;, 8) // -12// 按16进制解析parseInt(&#x27;-0xc&#x27;, 16) // -12// 按16进制解析parseInt(&#x27;-c&#x27;, 16) // -12 toString : 将数字以任意进制表示 123456789// 假定有一个2进制数let num = -0b1100// 以8进制表示num.toString(8) // &quot;-14&quot;// 以16进制表示num.toString(10) // &quot;-12&quot;// 以16进制表示num.toString(16) // &quot;-c&quot; 精度问题js 的所有数字，都是使用 64 位双精度浮点型来表示。并且是指数的形式。 转换成二进制后，就会有除不尽的问题： 123const a = 0.2;a.toString(2)// 0.0001100110011001100110011001100110011001100110011001101 可以看到 0011 一直在重复，我们不能用有限的空间存储无限长度的数。 我们可以先转换成字符串，再按位数相加，大数相加也是一个道理。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"二进制","slug":"二进制","permalink":"https://laputaz.github.io/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"实现：AB-testing 和组件设计","slug":"实现-AB-Testing和组件设计","date":"2022-08-22T16:59:10.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"实现-AB-Testing和组件设计/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-AB-Testing%E5%92%8C%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/","excerpt":"自从到了 marketing 团队，接触了大量 AB Testing 的需求。这里做一下简单总结。","text":"自从到了 marketing 团队，接触了大量 AB Testing 的需求。这里做一下简单总结。 什么是 AB Testing产品经理、设计师在设计需求的实现时，可能会有多条路径或者说多个方案来达成一个业务目标。 在经过评审之后，一般会权衡利弊，得出一个平衡了用户体验、业务目标和开发成本的最终方案。 但也可能存在一种情况：方案 A、B、C 各有优劣，没办法通过主观判断和讨论得出几个方案谁更优、收益更好。 有一个方法是，同时上线 A、B、C，并将用户流量平均分配到这三者，在固定时间周期后通过埋点等数据来分析哪一个方案效果更好（收益，访问量，订单转化率，下载量等等指标），最后选择出最优方案。 这就是 AB Testing。 例子marketing 团队大部分 AB 实验都是与 C 端展示相关的，例如文案的调整，模块的设计样式或相对位置等。 例如一个驱使用户下载 App 的 banner: 针对这一个简单的 banner，实验的情况就有多种多样： 例如，在 HK 地区，展示不同的文案，统计最后 app 在 HK 的下载量，分析出哪一个文案更具吸引力 “下载新用户享有 95 折扣” “下载后赠送 $5 折扣券” 例如，修改 banner 的样式，对比不同 banner 带来的下载量，最后更新最优设计 样式 A：按钮蓝色，不带边距 样式 B: 按钮橙色，圆角，带阴影 … … 实验的种类非常多，一般由产品经理来构思。并且需要确定： 实验的人群，地区 实验的平台 web / mweb 实验的划分 划分后每个实验组流量的分配量 埋点，曝光 or 行为 … … 关键点和注意事项关键点： 流量划分每一个访问的用户，都会有一个设备 ID。通过设备 ID，将用户等量划分，并生成一个 cookie 值，记录用户命中的实验和分组。前端根据命中的实验展示不一样的效果。 实验目标实验只面向某个地区的群体，或者某类设备的群体。 数据采集当实验组、控制组被命中时，根据需要上报曝光或者行为事件。作为最后统计的依据。 需要注意的事项： 确保实验的变量唯一 试验周期不宜过长，一般控制在 2 到 3 周，最好不要超过一个月 分析实验结果时，排除其他因素在实验中的影响。 前端实现前提：获取实验命中情况流量划分和用户命中由后端计算。前端需要在 node 层请求 api 获取当前用户命中的分组情况（放在客户端请求可能会造成页面闪动和数据误报）， 如： 12345678910111213141516171819202122router.get(&#x27;/home&#x27;, async function (ctx) &#123; let pageData = &#123;&#125; // node let experiments = await fetch.get(&#x27;/experiments/group&#x27;) pageData.experiments = experiments // experiments: &#123; // // 实验 1 // experiment1: &#123; // id: xxx, // hitGroup: &#x27;group1&#x27; // &#125;, // // 实验 2 // experiment2: &#123; // id: xxx, // hitGroup: &#x27;ctrl&#x27; // &#125; // &#125; // process other data // 渲染页面 ctx.render(&#x27;home.html&#x27;, pageData)&#125;) 这段代码表示，用户命中了实验 1 的 group1 分组，命中了实验 2 的 ctrl 控制组。 首页 home.html 中 js 拿到实验命中情况，渲染出对应的样式。 旧有的实现在旧的项目中，前端的技术栈是 渲染模板 handlebars + koa，后续引入了 Vue 的开发模式。 实验的实现方式没有做统一，公共代码只提供获取分组的方式，获取之后做什么完全由开发自己控制，如： 123456789101112131415161718192021import &#123; ABTestTool &#125; from &#x27;../ABTestingTool&#x27;export function abtestExperiment1() &#123; ABTestTool(&#123; notation: &#x27;experiment1&#x27; &#125;, (exp) =&gt; &#123; // 命中实验 group1 if (exp[&#x27;experiment1&#x27;] === &#x27;group1&#x27;) &#123; // doSomething &#125; // 命中实验 group2 if (exp[&#x27;experiment1&#x27;] === &#x27;group2&#x27;) &#123; // doSomething // 往往是直接修改样式 $(&#x27;body&#x27;).append(`&lt;style&gt;.theme_activities &#123; display: flex;&#125;&lt;/style&gt;`) &#125; // 命中实验 group3 if (exp[&#x27;experiment1&#x27;] === &#x27;group3&#x27;) &#123; &#125; &#125;)&#125;export &#123; abtestExperiment1 &#125; 亦或者使用了 Vue 的页面的写法： 123456789101112131415161718192021222324import &#123; ABTestTool &#125; from &#x27;../ABTestingTool&#x27;import hitComponent1 from &#x27;com1.vue&#x27;import hitComponent2 from &#x27;com2.vue&#x27;let hitComponent = &#123;&#125;export function abtestExperiment1() &#123; ABTestTool(&#123; notation: &#x27;experiment1&#x27; &#125;, (exp) =&gt; &#123; // 命中实验 group1 if (exp[&#x27;experiment1&#x27;] === &#x27;group1&#x27;) &#123; // doSomething hitComponent = hitComponent1 &#125; // 命中实验 group2 if (exp[&#x27;experiment1&#x27;] === &#x27;group2&#x27;) &#123; // doSomething hitComponent = hitComponent2 &#125; &#125;)&#125;abtestExperiment1()// 拿到结果的 Vue 组件export &#123; hitComponent &#125; 这些实现形式不统一，往往比较杂乱。实验完成后，剔除实验代码也没有统一的办法。 新的实现handlebars + koa 旧项目的代码将逐渐被 nuxt 替代。强行统一实现的话投入产出比太低。 所以这里只考虑 nuxt 上的实现，旧项目的逻辑保持不变，逐步淘汰。 定制规范。因为实验代码原则是临时性质的，为了便于维护和代码整洁，代码的编写需要遵循统一的规范： 通过需求单号标识实验代码、静态文件资源、多语言标记，并且合理添加带有单号标记的注释以便代码删除或回退 实验代码尽量集中，最大限度的减少对主业务逻辑的侵染，理想情况下，实验代码应该是易移除，可插拔，位置集中，标识明晰的 原则上不需要实验开发人员关注到数据上报发送，对于需求依赖的埋点，需要开发集中体现在实验代码中，并且事件命名带有实验标识，以在数据分析时，区别正常业务发的埋点。 … … 思路 这里使用了高阶函数的思路，入参为一个配置，AB 函数内部计算命中哪一个实验，最后生成一个 Vue 组件。 代码模拟： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;business-component /&gt; ... &lt;!-- 1. 作为实验组件穿插在业务组件之间 --&gt; &lt;abtest-xxxx&gt;&lt;/abtest-xxxx&gt; ... &lt;!-- 2. 没有匹配到实验的业务组件会作为默认slot渲染 --&gt; &lt;abtest-xxxx&gt; &lt;business-component /&gt; &lt;/abtest-xxxx&gt; ...&lt;/template&gt;&lt;script&gt; // 基础函数 import AB, &#123; IABTestingConfigs &#125; from &#x27;~/components/common/ab-testing/index.ts&#x27; // 声明组件 @Component(&#123; components: &#123; // 这里使用了高阶函数的思路，入参为一个配置，AB函数内部计算命中哪一个实验 abtestXXXX: AB(&#123; // 实验名 experimentName: &#x27;Chat_Btn_Design_AB_1_Mweb&#x27;, // 分组名和对应的组件，这里使用动态引入，拆分为单文件按需加载 groupComponents: &#123; &#x27;实验组1名称&#x27;: () =&gt; import(&#x27;~/experiments/abtestXXXX/variant1.vue&#x27;), &#x27;实验组2名称&#x27;: () =&gt; import(&#x27;~/experiments/abtestXXXX/variant2.vue&#x27;) &#125;, // 判断是否需要公共逻辑自动发送埋点数据 autoDataSend: true &#125; as IABTestingConfigs) &#125;)&lt;/script&gt; 在 ~/experiments/abtestXXXX/variant1.vue 实验代码中，需要说明实验的细节，开始结束时间，需求单，如 12345678/** * @Author: xxxx * @Date: 2020/7/21 8:51 下午 * @Description: 首页 banner 验证不同文案的影响 * @Orion: https: xxxxx/xxxx/xxx * @PM: 产品负责人 * @Backend: no */ AB 函数的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// config 就是上面的分组和组件的映射关系export default function (config) &#123; const &#123; experimentName, groupComponents &#125; = config // 组件，这里用 class 写法 class AB extends Vue &#123; // 命中的实验 get hitExperiment() &#123; // 从 store 拿到 命中的实验 const hitExp = store.state.itExperiment // 从 store 拿到 命中的分组 const hitExpGroupName = hitExp.group.name return &#123; // 返回一些必要的信息 id: &#x27;xxx&#x27;, component: groupComponents groupName: hitExp.group.name, // ... // ... &#125; &#125; // mouted后发送埋点 mounted() &#123; // 发送埋点数据 autoDataSend &amp;&amp; this.customTrack() &#125; // 埋点数据 customTrack() &#123; if (this.hitExperiment) &#123; // 发送 mixpanel 埋点 // .... this.sendTracking() // ..... &#125; &#125; // 渲染组件 render(h: any) &#123; if (this.hitExperiment) &#123; // 根据命中的实验拿到组件 return h(this.hitExperiment.component, &#123; props: &#123; hitExperimentName: experimentName, hitGroupName: this.hitExperiment.groupName, hitExperimentId: this.hitExperiment.id, hitGroupId: this.hitExperiment.groupId, customTrack: this.customTrack, &#125;, attrs: this.$attrs, on: &#123; ...this.$listeners, // 处理事件 &#125;, &#125;) &#125; else &#123; // 没有命中实验，返回 slot 的内容 return this.$slots.default ? h(&#x27;div&#x27;, this.$slots.default) : null &#125; &#125; &#125; return AB&#125; 利用高阶组件，可以返回实际，命中的分组对应的组件，展示在页面中。 以上","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://laputaz.github.io/home/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"},{"name":"AB Testing","slug":"AB-Testing","permalink":"https://laputaz.github.io/home/tags/AB-Testing/"}]},{"title":"实现：使用 lerna 管理 npm 包","slug":"实现-使用lerna管理npm包","date":"2022-08-10T17:23:56.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"实现-使用lerna管理npm包/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8lerna%E7%AE%A1%E7%90%86npm%E5%8C%85/","excerpt":"最近 xxx-admin-ui 和 xxx-admin-service 都用到了lerna, 记录一下注意点","text":"最近 xxx-admin-ui 和 xxx-admin-service 都用到了lerna, 记录一下注意点 Needlernanpm 1. 初始化工程1mkdir temp &amp;&amp; cd temp &amp;&amp; lerna init 2. 初始化每个包 假设我们有 2 个包, 如 : 123packages - admin-1 - admin-2 分别进入 admin-1 和 admin-2 初始化: 123cd packages/admin-1 &amp;&amp; npm init -ycd packages/admin-2 &amp;&amp; npm init -y 当然, 每个包都是完整的工程, 可以自由发挥 在 admin-1 和 admin-2 的package.json中修改包名和版本 123456// admin-1 package.json&#123; &quot;name&quot;: &quot;@laputaz/admin-1&quot;,// 包名 &quot;version&quot;: &quot;0.0.1&quot;, // 起始版本号, 我用 0.0.1 开始 ...&#125; @laputaz 为 scope, 所有相同 scope 的包, 安装后会被放在 scope 目录下 admin-2 同理 3. 每个包添加内容 为两个包都增加一个 src/index.js 12// admin-1/src/index.jsconsole.log(&#x27;admin-1&#x27;); - 12// admin-2/src/index.jsconsole.log(&#x27;admin-2&#x27;); 如果我们不需要对代码打包压缩等操作, 直接指定入口以及需要发布的内容即可: 123456789// in package.json&#123; &quot;main&quot;: &quot;src/index.js&quot;, // 发布后被引用时的入口 &quot;files&quot;: [ // 需要发布的文件 &quot;src&quot;, // 直接发布src的内容以及 README.md &quot;README.md&quot; ]&#125; 也可以用.npmignore指定不需要发布的内容, 区别如下 12.npmignore 该文件指定的内容将不会被发布package.json =&gt; files 字段, 该字段指定的内容将会被发布, 优先级高于.npmignore 4. 修改 lerna 配置在 lerna.json 中, 增加如下配置: 1234567891011121314// in lerna.json&#123; &quot;packages&quot;: [&quot;packages/admin-1&quot;, &quot;packages/admin-2&quot;], &quot;command&quot;: &#123; &quot;bootstrap&quot;: &#123; &quot;hoist&quot;: true &#125;, &quot;publish&quot;: &#123; &quot;message&quot;: &quot;release: publish tag &quot;, // lerna version打tag的时候的commit &quot;conventionalCommits&quot;: false // &#125; &#125;, &quot;version&quot;: &quot;independent&quot;&#125; 建议: packages 中我们可以写 packages/* , 但经常会建立一些不用发布的 demo 等代码文件目录, 所以最好手动指定需要发布的包 command =&gt; bootstrap =&gt; hoist 设置为 true, 可以把所有的 node_modules 的内容提升到顶层, 让每个包里的 node_modules 看起来更干净 version 改为 independent, 让每个包版本号可以不一样 command =&gt; publish =&gt; conventionalCommits 设置为 false 把自动生成 changelog 的功能关了, 太鸡肋, 因为生成的 changelog 可读性很差. 如果没有依赖关系,或者代码打包压缩等处理, 可以走直接第 6 步发布了. 5. 处理依赖关系包之间可能存在依赖关系, 这里演示有依赖关系的情况: 更新两个包的 src/index.js, 假设 admin-2 依赖 admin-1 12// admin-1/src/index.jsexport const say1 = () =&gt; console.log(&#x27;I am admin-1&#x27;); &amp; 123// admin-2/src/index.jsimport &#123; say1 &#125; from &#x27;@laputaz/admin-1&#x27;;say1(); 更新 admin-2 的 dependencies: 123456789// admin-2 package.json&#123; &quot;name&quot;: &quot;@laputaz/admin-2&quot;, ... ... &quot;dependencies&quot;: &#123; &quot;@laputaz/admin-1&quot;: &quot;0.0.1&quot; &#125;&#125; 本地调试时, 需要为 admin-1建立一个软链接, 运行: 1lerna bootstrap 该命令会在 admin-2 的node_modules下建立指向admin-1的快捷方式: 可以发现 admin-2/node_modules/@laputa/admin-1 的内容就是 admin-1 的内容 这样不需要先发布admin-1 , 也可以在本地正常调试了. 6. 发布由于权限限制, 我们不能直接运行lerna publish 发布. 需要分两步操作. 首先保证代码均已 push 到仓库. 运行 1lerna version [ patch | minor | major | ... ] # 还有其他选项, 但主要使用了这三个 该命令会自动更新每个包的版本并打 tag 提交到 git 仓库 slack deploy channel: 1@k fab knpm_lerna_publish:xxxx.git xxxx.git为 git 仓库地址 然后在 npm 上就能看到发布的包了 7. 如果要发布打包后的代码我们经常需要对代码打包压缩等处理, 然后发布处理后的代码 假设, 我们对 admin-1 打包压缩, 输出文件为 lib/index.common.js 首先在 package.json修改包的入口 123&#123; &quot;main&quot;: &quot;lib/index.common.js&quot;&#125; 然后需要在scripts增加一个钩子: 1234567&#123; &quot;scripts&quot;: &#123; ... ... &quot;prepublishOnly&quot;: &quot;do something here ......&quot; &#125;&#125; 我们在 deploy channel执行发布命令的时候, 会在远端执行 lerna publish 而 lerna publish 中又会执行 npm publish 而 prepublishOnly 这个钩子, 会在npm publish 前执行 prepublishOnly 中就可以写一些譬如: 切换 node 版本/ 执行 npm install &amp;&amp; npm run build等操作 8. 如果需要 changelogconventionalCommits生成的changelog是基于每个commit的, 难看且鸡肋, 所以决定手动生成. 文件: 121. changelog.md // 该文件为最终的所有的版本记录2. current.md // 当前版本的log 每次只修改 current.md 记录当前版本的更改内容 在pulish之前将 current.md 的内容放到 changelog.md中, 并清空 current.md 在工程根目录的 package.json 中增加 1234567&#123; &quot;scripts&quot;: &#123; ... ... &quot;version&quot;: &quot;cat current.md &gt;&gt;&gt; changelog.md &amp;&amp; git ad .&quot; &#125;&#125; 因为执行version 的时候, package中的版本号已经被更新了(即可以拿到最新的版本号), 所以可以在version钩子中操作版本文档的更新, 然后git ad . 9. 后话2024 不得不说，pnpm 自带的 workspace 更好用","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"npm","slug":"npm","permalink":"https://laputaz.github.io/home/tags/npm/"},{"name":"lerna","slug":"lerna","permalink":"https://laputaz.github.io/home/tags/lerna/"}]},{"title":"vue-优惠券组件化设计","slug":"vue-优惠券组件化","date":"2022-05-01T15:36:07.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"vue-优惠券组件化/","link":"","permalink":"https://laputaz.github.io/home/vue-%E4%BC%98%E6%83%A0%E5%88%B8%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"通用优惠券以及 srv 优惠券组件化方案","text":"通用优惠券以及 srv 优惠券组件化方案 Overview范围： 该方案包括通用优惠券以及 srv 优惠券 分为业务层和 UI 层，UI 只是容器，不考虑数据。 业务层逻辑 业务线会调用各自的 API，取得各自的一些业务数据之后，再调用 coupon api。 UI 组件desktop 列表模块 输入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051coupons: [&#123; disabled: Boolean, // default false isChosen: Boolean, // default false isRecommended: Boolean,// default false couponDetail: Object, // required&#125;]couponDetail: CouponDetail &#123; // coupon detail 结构 usable, top_tag: &#123; // optional // API下发限定券标识，如srv限定圈，只支持一种标示 background_color, text_color, text &#125;, discount_desc, end_time, end_date, code, special_desc, // for tooltip desc, // for tooltip reason， // for tooltip, optional bottom_link: &#123; // optional url, text &#125;&#125; 输出 choose-coupon: // select/deselect event, if user select emit selected code, if user deselect emit blank string 兑换模块输入 inputCouponCode(可输入可用户填写) 提供一个方法，clear coupon code 输出 event: handleClickCta // emit code user input 注解 超过 5 个字符，弹 tooltip 非空校验 校验规则可以定制 （讨论） 注意一个需求，不在这个组件内部实现的，就是可以根据 localstorage 初始化 code（提供能力） 标题模块（collapse）输入 属性： title // sub-title content // 展开后显示的内容 输出 fold/unfold Mobile输入和输出和 desktop 类似，只是子组件不同，把 collapase 换成 modal，并且加了一个 trigger point 组件 SRV下图是 SRV 的组件安排 业务层业务层主要做两件事，获取列表以及兑换优惠券，这里仅仅规定 API 入参以及返回格式。 API 入参规则：必要参数： 1234567891011121314151617181920212223242526&#123; currency, language, platform amount, settlement_type, shoppingcart_guid_list, phone_number, supported_method_list, coupon_key, tickets, select_coupon_code_list(optional)&#125; API 返回规则：列表： Coupons: Array&lt;Coupon&gt; 兑换： Coupon Coupon 结构12345678910111213141516171819202122232425262728293031323334353637383940414243Coupon: &#123; usable, top_tag: &#123; // optional // API下发限定券标识，如srv限定圈，只支持一种标示 background_color, text_color, text &#125;, isbest: , top_tags: [], // 新增 discount_desc, end_time, end_date, code, special_desc, // for tooltip desc, // for tooltip reason， // for tooltip, optional bottom_link: &#123; // optional url, text &#125;&#125; 埋点点击 callapse 点击兑换按钮 兑换成功 选中优惠券（包括点击 以及兑换成功） 组件生命周期以及钩子组件初始化（组件 mounted） 获取列表之前 (请求发送之前) 获取列表之后（包含成功 失败） 手动输入兑换之后（包含成功失败） 选中优惠券 点击展开之后 组件 destory","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"vue-混合使用 vue2 和 vue3 的生命周期，执行顺序","slug":"vue-混合使用 vue2 和 vue3 的生命周期，执行顺序","date":"2022-04-07T15:33:31.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"vue-混合使用 vue2 和 vue3 的生命周期，执行顺序/","link":"","permalink":"https://laputaz.github.io/home/vue-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%20vue2%20%E5%92%8C%20vue3%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"背景vue3 默认情况并没有屏蔽 option api，如果混合使用 setup 以及生命周期会发生什么？谁的优先级会更高？ 测试直接上例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;script&gt; import &#123; computed &#125; from &#x27;vue&#x27;; import &#123; onBeforeMount &#125; from &#x27;vue&#x27;; import &#123; watch &#125; from &#x27;vue&#x27;; import &#123; onUpdated &#125; from &#x27;vue&#x27;; import &#123; onBeforeUpdate &#125; from &#x27;vue&#x27;; import &#123; onMounted &#125; from &#x27;vue&#x27;; import &#123; ref &#125; from &#x27;vue&#x27;; export default &#123; // setup setup() &#123; console.log(&#x27;setup&#x27;); // setup 中的数据 const msg = ref(&#x27;msg in setup&#x27;); // 挂载前 onBeforeMount(() =&gt; &#123; console.log(&#x27;onBeforeMount&#x27;); &#125;); // 挂载后 onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;); &#125;); // 更新前 onBeforeUpdate(() =&gt; &#123; console.log(&#x27;onBeforeUpdate&#x27;); &#125;); // 更新后 onUpdated(() =&gt; &#123; console.log(&#x27;onUpdated&#x27;); &#125;); // 点击方法 const handleClick = () =&gt; &#123; msg.value += 1; console.log(&#x27;clicked in setup&#x27;); &#125;; // setup 中的计算属性 const computedMsg = computed(() =&gt; msg.value + &#x27; in setup&#x27;); // setup 中的 watch watch(msg, (newVal) =&gt; console.log(newVal + &#x27;watch in setup&#x27;)); return &#123; msg, computedMsg, handleClick &#125;; &#125;, data() &#123; console.log(&#x27;data&#x27;); return &#123; // data 中的数据 msg: &#x27;msg in data&#x27;, &#125;; &#125;, // 创建前 beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;); &#125;, // 创建后 created() &#123; console.log(&#x27;created&#x27;); &#125;, // 挂载前 beforeMounted() &#123; console.log(&#x27;beforeMounted&#x27;); &#125;, // 挂载后 mounted() &#123; console.log(&#x27;mounted&#x27;); &#125;, // 更新前 beforeUpdate() &#123; console.log(&#x27;beforeUpdate&#x27;); &#125;, // 更新后 updated() &#123; console.log(&#x27;updated&#x27;); &#125;, // 方法 methods: &#123; handleClick() &#123; console.log(&#x27;clicked in methods&#x27;); &#125;, &#125;, watch: &#123; msg(newVal) &#123; console.log(newVal + &#x27;watch in option&#x27;); &#125;, &#125;, &#125;;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;click&lt;/button&gt; &#123;&#123; msg &#125;&#125;&lt;/template&gt; 首先可以看到，创建阶段，执行结果是： setup 最先执行; 然后是 vue2 中的三个创建周期函数：beforeCreate、data、created; 接下来是 setup 中的 onBeforeMount、vue3 的 onBeforeMount; 然后是 setup 中的 onMounted、vue2 中的 mounted; 接着看方法，点击按钮，触发的是 vue2 的 methods： 删除后会触发 setup 中的方法： 同时，从上图可以看到，不管是 setup 中还是 option 中的 watch 都会被执行。 最后把 data 删掉，点击按钮，会发现，组件更新先执行 onBeforeUpdate，然后是 vue2 中的 beforeUpdate，最后是 setup 中的 onUpdated、vue2 中的 updated。 结论整体而言，vue3 中的生命周期钩子函数会优先于 vue2 的 option api 执行。 那为什么 data、methods 中相同命名的变量、方法，会展示、绑定到界面，而不是 setup 中的 ref 或者方法呢？ 是因为 setup 先执行，然后 data、methods 后执行，后者会覆盖前者。 setup 中为什么没有 beforeCreate 和 created？ setup 最先执行，组件实例已经创建，beforeCreate 和 created 已经没有意义了。","categories":[],"tags":[{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"hook 编写总结","slug":"hook编写总结","date":"2022-01-05T10:13:05.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"hook编写总结/","link":"","permalink":"https://laputaz.github.io/home/hook%E7%BC%96%E5%86%99%E6%80%BB%E7%BB%93/","excerpt":"hook 的一些注意事项","text":"hook 的一些注意事项 Hookhook 来由： Hook 使你在无需修改组件结构的情况下复用状态逻辑。 Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。 Hook 使你在非 class 的情况下可以使用更多的 Vue/React 特性，不用到处 bind this。 React 相关使用规则 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。（React 靠的是 Hook 调用的顺序知道哪个 state 对应哪个 useState，只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。这就是为什么 Hook 需要在我们组件的最顶层调用，如果有条件判断，会导致 hook 无法对应返回的结果；（可通过 lint 插件避免）） 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中） Hook 是一种复用状态逻辑的方式，它不复用 state 本身。 API useState：对应 react 中的 state，传入初始 state，并返回一对值：当前状态和一个让你更新它的函数； setXxx 是异步的，所以 for 循环 setXxx 时，第二次及其后面获取的 xxx 的值是一样的，所以最终相当于执行了 1 次，如何解决； for 循环执行结果，然后在循环外执行一次 set； 箭头函数返回值的形式赋值，如：setCount(prevData =&gt; {return prevData+1}); 在 setXxx 时，hook 通过 Object.is 来对比当前值和新值，所以就算值一样，引用不一样也会重新渲染，所以最好避免复杂类型的值； 123456789101112131415161718192021222324252627282930313233343536import React, &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // 声明一个叫 “count” 的 state 变量。 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; // ... useEffect：告诉 React 在完成对 DOM 的更改后运行你的“effect”函数，React 会在每次渲染后调用这个函数 —— 包括第一次渲染的时候，可在组件中多次使用 useEffect；还可以通过返回一个函数来指定如何“清除”副作用。看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。 使用多个 Effect 实现关注点分离，把相关联业务的代码放一个 effect； 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。 如果这里用了 setInterval 去叠加某个变量，也会出现 useState 同样的问题，数据永远得到一次处理的结果，所以最好养成异步更新数据的习惯，setCount(prevData =&gt; {return prevData+1});； 123456789101112131415161718192021import React, &#123; useState,useEffect&#125; from &#x27;react&#x27;;function Component() &#123; const [a, setA] = useState(0);//定义变量a，并且默认值为0 //定义第1个useEffect，专门用来处理自动累加器 useEffect(() =&gt; &#123; let timer = setInterval(() =&gt; &#123;setA(a+1)&#125;,1000);// &lt;-- 请注意这行代码，暗藏玄机 return () =&gt; &#123; clearInterval(timer); &#125; &#125;, []);//此处第2个参数为[]，告知React以后该组件任何更新引发的重新渲染都与此useEffect无关 //定义第2个useEffect，专门用来处理网页标题更新 useEffect(() =&gt; &#123; document.title = `$&#123;a&#125; - $&#123;Math.floor(Math.random()*100)&#125;`; &#125;,[a]) return &lt;div&gt; &#123;a&#125; &lt;/div&gt;&#125;export default Component; useContext：获取组件之间的共享状态，方便组件的多层传递； 123456789101112131415161718192021222324import React,&#123; useContext &#125; from &#x27;react&#x27;const UserContext = React.createContext();const NewsContext = React.createContext();function AppComponent() &#123; return ( &lt;UserContext.Provider value=&#123;&#123;name:&#x27;puxiao&#x27;&#125;&#125;&gt; &lt;NewsContext.Provider value=&#123;&#123;title:&#x27;Hello React Hook.&#x27;&#125;&#125;&gt; &lt;ChildComponent /&gt; &lt;/NewsContext.Provider&gt; &lt;/UserContext.Provider&gt; )&#125;function ChildComponent()&#123; const user = useContext(UserContext); const news = useContext(NewsContext); return &lt;div&gt; &#123;user.name&#125; - &#123;news.title&#125; &lt;/div&gt;&#125;export default AppComponent; useReducer：Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的 dispatch 函数。 组件自己内部的简单逻辑变量用 useState、多个组件之间共享的复杂逻辑变量用 useReducer。 12345678910111213141516171819202122232425262728293031323334import React, &#123; useReducer &#125; from &#x27;react&#x27;;function reducer(state,action)&#123; //根据action.type来判断该执行哪种修改 switch(action.type)&#123; case &#x27;add&#x27;: //count 最终加多少，取决于 action.param 的值 return state + action.param; case &#x27;sub&#x27;: return state - action.param; case &#x27;mul&#x27;: return state * action.param; default: console.log(&#x27;what?&#x27;); return state; &#125;&#125;function getRandom()&#123; return Math.floor(Math.random()*10);&#125;function CountComponent() &#123; const [count, dispatch] = useReducer(reducer,0); return &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type:&#x27;add&#x27;,param:getRandom()&#125;)&#125;&#125; &gt;add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type:&#x27;sub&#x27;,param:getRandom()&#125;)&#125;&#125; &gt;sub&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type:&#x27;mul&#x27;,param:getRandom()&#125;)&#125;&#125; &gt;mul&lt;/button&gt; &lt;/div&gt;;&#125;export default CountComponent; useCallback：“勾住”组件属性中某些处理函数，创建这些函数对应在 react 原型链上的变量引用。useCallback 第 2 个参数是处理函数中的依赖变量，只有当依赖变量发生改变时才会重新修改并创建新的一份处理函数。 useCallback 可以将组件的某些处理函数挂载到 react 底层原型链上，并返回该处理函数的引用，当组件每次即将要重新渲染时，确保 props 中该处理函数为同一函数(因为是同一对象引用，所以===运算结果一定为 true)，跳过本次无意义的重新渲染，达到提高组件性能的目的。当然前提是该组件在导出时使用了 React.memo()。只要依赖变量不发生变化，那么重新渲染时就可以一直使用之前创建的那个函数，达到阻止本次渲染，提升性能的目的。但是如果依赖变量发生变化，那么下次重新渲染时根据变量重新创建一份处理函数并替换 React 底层原型链上原有的处理函数。 如果父组件中只有 1 个子组件，那其实完全没有必要使用 useCallback。只有父组件同时有多个子组件时，才有必要去做性能优化，防止某一个子组件引发的重新渲染也导致其他子组件跟着重新渲染。 12345678910111213import Button from &#x27;./button&#x27;; //引入我们自定义的一个组件&lt;Button&gt;//组件内部声明一个age变量const [age,setAge] = useState(34);//通过useCallback，将鼠标点击处理函数保存到React底层原型链中，并获取该函数的引用，将引用赋值给clickHandlerconst clickHandler = useCallback(() =&gt; &#123; setAge(age+1); &#125;,[age]);//由于该处理函数中使用到了age这个变量，因此useCallback的第2个参数中，需要将age添加进去//使用该处理函数，实为使用该处理函数的在React底层原型链上的引用return &lt;Button clickHandler=&#123;clickHandler&#125;&gt;&lt;/Button&gt; useMemo：“勾住”组件中某些处理函数的返回值，创建这些返回值对应在 react 原型链上的索引。当组件重新渲染时，需要再次用到这些函数返回值，此时不再重新执行一遍运算，而是直接使用之前运算过的返回值。useMemo 第 2 个参数是处理函数的变量依赖，只有当处理函数依赖的变量发生改变时才会重新计算并保存一次函数返回结果。第 1 个参数为我们定义的一个“包含复杂计算且有返回值的函数”，第 2 个参数为该处理函数中存在的依赖变量，请注意凡是处理函数中有的数据变量都需要放入 deps 中。如果处理函数没有任何依赖变量，可以传入一个空数组[]。 useCallback 是将某个函数“放入到 react 底层原型链上，并返回该函数的索引”，而 useMemo 是将某个函数返回值“放入到 react 底层原型链上，并返回该返回值的索引”。一个是针对函数，一个是针对函数返回值。 useCallback 中的 fn 主要用来处理各种操作事务的代码，例如修改某变量值或加载数据等。而 useMemo 中的 fn 主要用来处理各种计算事务的代码。 useCallback 中的函数是侧重“操作事务”，useMemo 中的函数是侧重“计算结果”，永远不要在 useMemo 的函数中添加修改数据之类的代码。 useMemo 并不需要子组件必须使用 React.memo。 “不必要的函数计算”中的函数计算必须是有一定复杂度的，例如需要 1000 个 for 循环才能计算出的某个值。如果计算量本身很简单，例如 1+2，那完全没有必要使用 useMemo，就直接每次重新计算一遍也无所谓。 useMemo 只是理论上帮你进行组件计算性能优化，但是 react 并不能保证 100%都是按照你的预期来执行的。比如说当你的网页处于离屏(休眠、挂起)等状态时，react 底层原型链也许就会释放(删除)之前保存的函数返回值。等到下次网页重新被唤醒时，重新计算一次。 关于 useMemo 第 2 个参数，和 useCallback 一样，也许在未来版本中 react 会智能识别，不需要要我们再手工传入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React,&#123;useState,useMemo&#125; from &#x27;react&#x27;function UseMemo() &#123; const [num,setNum] = useState(2020); const [random,setRandom] = useState(0); //通过useMemo将函数内的计算结果(返回值)保存到react底层原型链上 //totalPrimes为react底层原型链上该函数计算结果的引用 const totalPrimes = useMemo(() =&gt; &#123; console.log(&#x27;begin....&#x27;); //这里添加一个console.log，方便验证在重新渲染时是否重新执行了一遍计算 let total = 0; //声明质数总和对应的变量 //以下为计算num范围内所有质数个数总和的计算代码，不需要认真阅读，只需要知道这是一段“比较复杂的计算代码”即可 for(let i = 1; i&lt;=num; i++)&#123; let boo = true; for(let j = 2; j&lt;i; j++)&#123; if(i % j === 0)&#123; boo = false; break; &#125; &#125; if(boo &amp;&amp; i!==1)&#123; total ++; &#125; &#125; //复杂的计算代码到此结束 return total;//将质数总和作为返回值return出去 &#125;, [num]); const clickHandler01 = () =&gt; &#123; setNum(num+1); &#125; const clickHandler02 = () =&gt; &#123; setRandom(Math.floor(Math.random()*100)); //修改random的值导致整个组件重新渲染 &#125; return ( &lt;div&gt; &#123;num&#125; - &#123;totalPrimes&#125; - &#123;random&#125; &lt;button onClick=&#123;clickHandler01&#125;&gt;num + 1&lt;/button&gt; &lt;button onClick=&#123;clickHandler02&#125;&gt;random&lt;/button&gt; &lt;/div&gt; )&#125;export default UseMemo; useRef：“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。该引用在组件整个生命周期中都固定不变，该引用并不会随着组件重新渲染而失效。 获取真实 dom 对象，如 useRef(null)，指小写开头的类似原生标签的组件，不可以是自定义组件。 针对 JSX 组件，通过属性 ref={xxxRef} 进行关联。 针对 useEffect 中的变量，通过 xxxRef.current 进行关联。 1234567891011121314151617181920212223242526272829303132333435363738394041// 获取domconst canvasRef1 = useRef&lt;HTMLCanvasElement&gt;(null)const canvasRef2 = useRef&lt;HTMLCanvasElement&gt;()// 获取//先定义一个xxRef引用变量，用于“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象const xxRef = useRef(null);//针对 JSX组件，通过属性 ref=&#123;xxxRef&#125; 进行关联&lt;xxx ref=&#123;xxRef&#125; /&gt;//针对 useEffect中的变量，通过 xxxRef.current 进行关联useEffect(() =&gt; &#123; xxRef.current = xxxxxx;&#125;,[]);// React.forwardRef()包裹住要输出的组件，且将第2个参数设置为 ref 即可，import React from &#x27;react&#x27;const ChildComponent = React.forwardRef((props,ref) =&gt; &#123; //子组件通过将第2个参数ref 添加到内部真正的“小写开头的类似原生标签的组件”中 return &lt;button ref=&#123;ref&#125;&gt;&#123;props.label&#125;&lt;/button&gt;&#125;);/* 上面的子组件直接在父组件内定义了，如果子组件是单独的.js文件，则可以通过 export default React.forwardRef(ChildComponent) 这种形式 */function Forward() &#123; const ref = React.useRef();//父组件定义一个ref const clickHandle = () =&gt;&#123; console.log(ref.current);//父组件获得渲染后子组件中对应的DOM节点引用 &#125; return ( &lt;div&gt; &#123;/* 父组件通过给子组件添加属性 ref=&#123;ref&#125; 将ref作为参数传递给子组件 */&#125; &lt;ChildComponent label=&#x27;child bt&#x27; ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;clickHandle&#125; &gt;get child bt ref&lt;/button&gt; &lt;/div&gt; )&#125;export default Forward; useImperativeHandle：子组件中某些函数(方法)供父组件调用，本质上其实是子组件将自己内部的函数(方法)通过 useImperativeHandle 添加到父组件中 useRef 定义的对象中。可以通过 res.current.xxx 来访问或执行。前 2 个参数为必填项，第 3 个参数为可选项。 第 1 个参数为父组件通过 useRef 定义的引用变量； 第 2 个参数为子组件要附加给 ref 的对象，该对象中的属性即子组件想要暴露给父组件的函数(方法)；第 3 个参数为可选参数，为函数的依赖变量。凡是函数中使用到的数据变量都需要放入 deps 中，如果处理函数没有任何依赖变量，可以忽略第 3 个参数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 子组件import React,&#123;useState,useImperativeHandle&#125; from &#x27;react&#x27;function ChildComponent(props,ref) &#123; const [count,setCount] = useState(0); //子组件定义内部变量count //子组件定义内部函数 addCount const addCount = () =&gt; &#123; setCount(count + 1); &#125; //子组件通过useImperativeHandle函数，将addCount函数添加到父组件中的ref.current中 useImperativeHandle(ref,() =&gt; (&#123;addCount&#125;)); return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;addCount&#125;&gt;child&lt;/button&gt; &lt;/div&gt; )&#125;//子组件导出时需要被React.forwardRef包裹，否则无法接收 ref这个参数export default React.forwardRef(ChildComponent);// 父组件import React,&#123;useRef&#125; from &#x27;react&#x27;import ChildComponent from &#x27;./childComponent&#x27;function Imperative() &#123; const childRef = useRef(null); //父组件定义一个对子组件的引用 const clickHandle = () =&gt; &#123; childRef.current.addCount(); //父组件调用子组件内部 addCount函数 &#125; return ( &lt;div&gt; &#123;/* 父组件通过给子组件添加 ref 属性，将childRef传递给子组件， 子组件获得该引用即可将内部函数添加到childRef中 */&#125; &lt;ChildComponent ref=&#123;childRef&#125; /&gt; &lt;button onClick=&#123;clickHandle&#125;&gt;child component do somting&lt;/button&gt; &lt;/div&gt; )&#125;export default Imperative; useLayoutEffect：“勾住”挂载或重新渲染完成这 2 个组件生命周期函数。useLayoutEffect 使用方法、所传参数和 useEffect 完全相同。他们的不同点在于，你可以把 useLayoutEffect 等同于 componentDidMount、componentDidUpdate，因为他们调用阶段是相同的。而 useEffect 是在 componentDidMount、componentDidUpdate 调用之后才会触发的。 useLayoutEffect 对页面的某些修改调整可能会触发组件重新渲染。如果是对 DOM 进行一些样式调整是不会触发重新渲染的，这点和 useEffect 是相同的。优先使用 useEffect，useEffect 无法满足需求时再考虑使用 useLayoutEffect。 useLayoutEffect 先触发，useEffect 后触发。 useEffect 和 useLayoutEffect 在服务器端渲染时，都不行，需要寻求别的解决方案。 123456789101112131415161718192021import React,&#123;useState,useEffect,useLayoutEffect&#125; from &#x27;react&#x27;function LayoutEffect() &#123; const [count,setCount] = useState(0); useEffect(() =&gt; &#123; console.log(&#x27;useEffect...&#x27;); &#125;,[count]); useLayoutEffect(() =&gt; &#123; console.log(&#x27;useLayoutEffect...&#x27;); &#125;,[count]); return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; &#123;setCount(count+1)&#125;&#125;&gt;Click&lt;/button&gt; &lt;/div&gt; )&#125;export default LayoutEffect useDebugValue：React 开发调试工具中的自定义 hook 标签，让 useDebugValue 勾住的自定义 hook 可以显示额外的信息。函数第 1 个参数为我们要额外显示的内容变量。第 2 个参数是可选的，是对第 1 个参数值的数据化格式函数。 自定义 hook：将原来在组件中编写的相关 hook 代码抽离出组件，让 hook 相关代码独立存在，达到优化代码结构、相关 hook 代码可以重复使用的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// useInput文件import &#123;useState&#125; from &#x27;react&#x27;function useInput(initialValue) &#123; const [value,setValue] = useState(initialValue); //定义输入框对应的值value //定义reset函数，用来重置输入框 const reset = () =&gt; &#123; setValue(initialValue); &#125; //定义一个 bind 对象，该对象有 value 和 onChange 2个属性 const bind = &#123; value, onChange: eve =&gt; &#123; setValue(eve.target.value) &#125; &#125; return [value,reset,bind];//将输入框的值、重置输入框函数、定义的bind对象作为返回值 return 出去&#125;export default useInputimport React from &#x27;react&#x27;import useInput from &#x27;./useInput&#x27;;function LoginForm() &#123; const [usename,resetUsename,bindUsename] = useInput(&#x27;&#x27;); //定义用户名输入框相关的变量 const [password,resetPassword,bindPassword] = useInput(&#x27;&#x27;); //定义密码输入框相关的变量 const submitHandle = (eve) =&gt; &#123; eve.preventDefault(); //阻止form真正提交 alert(`usename:$&#123;usename&#125;\\rpassword:$&#123;password&#125;`); //通过alert，弹出用户名和密码的值 resetUsename(); //重置用户名输入框 resetPassword(); //重置密码输入框 &#125; //请特别留意用户名和密码输入框中的 &#123;...bindUsename&#125;和&#123;...bindPassword&#125; return ( &lt;form onSubmit=&#123;submitHandle&#125;&gt; &lt;label&gt;usename:&lt;/label&gt; &lt;input type=&#x27;text&#x27; &#123;...bindUsename&#125; /&gt; &lt;label&gt;password:&lt;/label&gt; &lt;input type=&#x27;password&#x27; &#123;...bindPassword&#125; /&gt; &lt;input type=&#x27;submit&#x27; value=&#x27;login&#x27; /&gt; &lt;/form&gt; )&#125;export default LoginForm; 12. Vue 相关优点 更好的逻辑复用 更灵活的代码组织 更好的类型推导 更小的生产包体积 不用到处 bind this 了 如何引入 composition api pnpm add @vue/composition-api； 如何注册； 12import VueCompositionAPI from &#x27;@vue/composition-api&#x27;Vue.use(VueCompositionAPI) APIcomposition api 和 vue3 一致； setup(props, context)：创建组件之前执行， 所以内部没有 this，访问不了组件中声明的任何属性或方法； props 是响应式的，所以不能用解构获取，会消除 prop 的响应性；非要解构，使用 toRefs 包一层； context 不是响应式，可以解构； attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。所以应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。与 props 不同，attrs 和 slots 是非响应式的。如果你打算根据 attrs 或 slots 更改应用副作用，那么应该在 onUpdated 生命周期钩子中执行此操作。 1234567891011121314151617181920export default &#123; props: &#123; title: String &#125;, setup(props, context) &#123; console.log(props.title) const &#123; title &#125; = toRefs(props) console.log(title.value) // Attribute (非响应式对象) console.log(context.attrs) // 插槽 (非响应式对象) console.log(context.slots) // 触发事件 (方法) console.log(context.emit) &#125;&#125; ref：用来定义响应式的字符串，数值，布尔、数组；定义的属性名称需要通过 变量.value 来修改； reactive：用来定义响应式的对象；直接 变量.属性 获取或修改； toRefs：解构响应式对象数据，让解构后的数据不丢失相应性； computed：计算属性； readonly：只读代理，对象的每一层结构都是只读； watchEffect：立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 停止监听可通过返回的函数 stop 掉； watch：监听回掉； 允许设置监听的数据（可设置多个，多个用数组），数据发生变化才执行回掉； 可访问状态变化前后的数据； 生命周期： beforeCreate/created -&gt; setup beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeUnmount -&gt; onBeforeUnmount unmounted -&gt; onUnmounted errorCaptured -&gt; onErrorCaptured renderTracked -&gt; onRenderTracked renderTriggered -&gt; onRenderTriggered provider/inject：多层嵌套组件数据传递； getCurrentInstance：获取组件实例； unref：返回 ref 的值； toRef：为响应式对象的属性创建 ref，并保留原属性的响应式； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const count = ref(0)watchEffect(() =&gt; console.log(count.value))// -&gt; 打印 0setTimeout(() =&gt; &#123; count.value++ // -&gt; 打印 1&#125;, 100)const stop = watchEffect(() =&gt; &#123; /* ... */&#125;)// 停止监听stop()// 同步调用watchEffect( () =&gt; &#123; /* ... */ &#125;, &#123; flush: &#x27;sync&#x27; &#125;)// 在组件更新前调用watchEffect( () =&gt; &#123; /* ... */ &#125;, &#123; flush: &#x27;pre&#x27; &#125;)const state = reactive(&#123; foo: 1, bar: 2&#125;)const fooRef = toRef(state, &#x27;foo&#x27;)fooRef.value++console.log(state.foo) // 2state.foo++console.log(fooRef.value) // 3 isProxy：检查一个对象是否为 reactive 或 readonly 创建的代理对象. isReactive：检查一个对象是否为 reactive 创建的响应式对象.如果这个对象是被 readonly 包装的 reactive 创建的对象, 也会返回 true. isReadonly：检查一个对象是否为 readonly 创建的只读代理对象. customRef：创建一个自定义的 ref, 可以显式地控制它的依赖跟踪和更新时机. 需要传入一个工厂函数. 这个函数接收 track 和 trigger 两个回调, 并返回一个设置了 get 和 set 的对象. markRaw：标记一个对象, 让这个对象不能被转换为代理对象. 返回值是它本身. shallowReactive：创建一个能跟踪自身属性变化的响应式的代理, 但不对内嵌对象进行深度响应式转换 (即暴露原始对象). shallowReadonly：创建一个只有自身属性只读的代理对象, 但不对内嵌对象进行深度只读转换 (即暴露原始对象). shallowRef：创建一个能够跟踪 .value 变化但却使其 value 非响应式的 ref. toRaw：返回 reactive 或 readonly 代理对象的原始对象. 这是一种应急用法, 可以在读取时不触发代理对象的访问/跟踪, 修改时不触发变更. 不建议永久持有转换后的原始对象. 请谨慎使用. 参考https://legacy.reactjs.org/docs/hooks-intro.html https://github.com/puxiao/react-hook-tutorial/blob/master/06%20useContext%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95.md","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"},{"name":"包管理","slug":"包管理","permalink":"https://laputaz.github.io/home/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"},{"name":"hook","slug":"hook","permalink":"https://laputaz.github.io/home/tags/hook/"}]},{"title":"vue-referral组件化","slug":"vue-referral组件化","date":"2022-01-04T15:36:42.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"vue-referral组件化/","link":"","permalink":"https://laputaz.github.io/home/vue-referral%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"referral组件化方案","text":"referral组件化方案 更新记录2021-6-2 暂时不用考虑通过配置展示组件 Overview旧的 referral banner https://docs.google.com/document/d/1Q5HFbfxmQsHNvaT–AKhdMuytENR7wanN5mrKakQ-1s/edit# 这次的需求 https://www.figma.com/file/ijyJNacQsmcCeGwf9UEIxO/AB-Test-Referral-Entrance-Post-Booking-Touchpoints?node-id=0%3A1 目前的 referral api https://docs.google.com/document/d/13J8nulRH685vAgfn4FgSYNynp22V8MvSu6FHO1x7Ppk/edit# Project diagram referral banner api 提供原始数据 configure data 提供如何展示 组件模版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// configure dataconst componentJson = &#123; meta: &#123; componentCode: &quot;post-review-referral&quot;, platform: &quot;node&quot;, // node email vue android ios scope: &quot;post-review&quot;, apiUrl: &quot;&quot;, &#125;, layout: &#123; direction: &quot;column&quot;, // row column mainAxisSpace: &quot;space-around&quot;, // flex-start | flex-end | center | space-between | space-around crossAxisAlignment: &quot;flex-start&quot;, // flex-start | flex-end | middle layoutType: &quot;container&quot;, // container item background: &quot;&quot;, sizeInfo: &#123; type: &quot;responsive&quot;, // responsive 时，value为宽高比 ratio: &quot;600/180&quot;, minHeight: 100, maxHeight: 200, &#125;, styles: &#123;&#125;, // box model + render related style, fontsize color ... itemList: [ &#123; itemType: &quot;text&quot;, sourceType: &quot;api&quot;, // api, i18n dataField: &quot;get.sub_title&quot;, layoutType: &quot;item&quot;, // container item background: &quot;&quot;, sizeInfo: &#123; type: &quot;static&quot;, // static 时，value为宽度 width: &quot;352px&quot;, // px / % height: &quot;72px&quot;, &#125;, styles: &#123;&#125;, // box model + render related style, fontsize color ... &#125;, &#123; itemType: &quot;button&quot;, sourceType: &quot;i18n&quot;, // api, i18n source: &quot;ctaText&quot;, layoutType: &quot;item&quot;, // container item background: &quot;&quot;, sizeInfo: &#123; type: &quot;static&quot;, // static 时，value为宽度 width: &quot;352px&quot;, // px / % height: &quot;72px&quot;, &#125;, styles: &#123;&#125;, // box model + render related style, fontsize color ... &#125; ], &#125;,&#125;; 1234567891011121314151617// raw data&#123; // 邀请用户，被邀请人下单成功后，自己能得到优惠描述 &quot;get&quot;: &#123; &quot;title&quot;: &quot;xxx&quot;, &quot;sub_title&quot;: &quot;xxxx&quot;, &quot;amount_desc&quot;: &quot;¥ 10.1 OFF&quot; &#125;, // 被邀请人，能得到的优惠描述 &quot;give&quot;: &#123; &quot;title&quot;: &quot;xxx&quot;, &quot;sub_title&quot;: &quot;xxxx&quot;, &quot;amount_desc&quot;: &quot;$123 OFF&quot; // 如果 en_US 后面会拼接 OFF，历史逻辑 先保留 &#125;, &quot;special_clause&quot;: &quot;xxxxxx&quot; // 中国用户特殊的展示逻辑，历史逻辑，保留&#125; 此需求包括 nodenewweb, email render, app(android/ios) 等不同平台，也可以兼容未来可能需要兼容的 vue，nuxt 等项目框架 Compatible with node new web service首先先介绍下 nodenewweb 服务的基本情况，为了方便描述，下面称这个服务为 new web 项目。 我们的组件化方案将在 koa 中引入 mkt 组件包并且注册组件，其中 mkt 组件包提供所需要的 html string generator，然后在想要引用 mkt 组件的模版中引入组件模版，下面我们详细说一下在 new web 中如何集成 mkt 组件。 hello world123456789101112// hbs_helpervar referralBanner = require(&#x27;../../../../mkt-components/referral-banner&#x27;)// 注册组件hbs.registerHelper(&#x27;referralBanner&#x27;, function() &#123; return referralBanner&#125;)//email_review.html&lt;div class=&quot;review_top&quot;&gt;&lt;/div&gt;&lt;div class=&quot;review_box&quot;&gt;&lt;/div&gt;// 引用组件&#123;&#123;&#123;referralBanner&#125;&#125;&#125; define props12345678910111213141516171819202122232425// referral-banner-component.jsfunction renderReferralBanner(scope, outerReferralData) &#123; return ` &lt;div class=&quot;review_bottom&quot; style=&quot;line-height: 1; height: 100px; background: #dfdfdf;&quot;&gt; this is for referal banner 这个banner在&lt;span&gt;$&#123;scope&#125;&lt;/span&gt;显示 恭喜你 由于你定了活动$&#123;outerReferralData&#125;，现在邀请好友吧 &lt;/div&gt; &lt;style&gt; .review_bottom &#123; font-size: 22px; &#125; &lt;/style&gt;`;&#125;;module.exports = renderReferralBanner// hbs_helperhbs.registerHelper(&#x27;referralBanner&#x27;, function(scope, outerReferralData) &#123; return referralBanner(scope, outerReferralData)&#125;)//email_review.html&lt;div class=&quot;review_top&quot;&gt;&lt;/div&gt;&lt;div class=&quot;review_box&quot;&gt;&lt;/div&gt;// 引用组件&#123;&#123;&#123;referralBanner &#x27;completeReview&#x27; booking_data.activity_name&#125;&#125;&#125; 这里我们的组件需要外界提供参数，scope 来确定是在哪里显示的 feferral banner, 以及活动名字, 最终的显示效果。 inte with JSON为了提供未来的灵活性和根据 api 下发数据以及展示，从而真正的减少代码发布，通过 admin 管理新的需求，我们需要根据 JSON 来确定如何展示数据。 mweb/web对 mweb 和 web 分别提供组件 Compatible with email renderer serviceemail renderer 和 new web 类似，邮件客户端解析样式的能力比较弱，前端经常需要用 table 布局，需要把 flex 布局解析成客户端可以理解的 table。 Compatible with app这部分暂时不在这个文档里面讨论 Project strcture针对 node 层场景做 playground，待完善 优化方向问：目前针对 new web 或者 nuxtnodenewweb 服务，需要写两套代码，探索一套代码编译生成不同包， 答： 一个问题是，提供给 new web 的是一个 html string provider（返回 html string 的函数）， 提供给 nuxtnodenewweb 的是一个 vue component，两者有很大的不同。vue 的语法比 handlebars 强大非常多 比如 new web 包的占位符主要是组件的入参 vue component 包的占位符可能是入参，还有可能是 computed, method 等各种形式 举例在 vue component 包的模版可能是 12345678910hello &#123;computedVariabl&#125;props: &#123; scope&#125;,computed: &#123; computedVariabl() &#123; return scope + &#x27;computedVariable&#x27; &#125;&#125; 这样在 new web 服务中实际上无法识别除了入参之外的其他参数的（只能识别到 props） 所以暂时得针对不同的服务写不同的代码 还有一种可能的方案是，我们限制项目中 vue component 的能力，比如我们规定不能使用 computed 123456789// vue componenthello &#123;scope&#125;props: &#123; scope&#125;,// 不能在模版中使用props以外的变量// new webhello $&#123;scope&#125; 这样的话我们的代码就可以在 new web 和 vue 中同时运行，但是这样会减少很多 vue 的功能和灵活度 如何在 new web 项目中对外通信 如何减少样式冲突？","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"俄语笔记(二)：俄语的调型","slug":"俄语笔记-俄语的调型","date":"2022-01-02T18:23:46.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"俄语笔记-俄语的调型/","link":"","permalink":"https://laputaz.github.io/home/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0-%E4%BF%84%E8%AF%AD%E7%9A%84%E8%B0%83%E5%9E%8B/","excerpt":"мой брат говорит по-русски. А твой брат?","text":"мой брат говорит по-русски. А твой брат? мой брат говорит по-русски. А твой брат?我兄弟说俄语。你兄弟呢？ 概念 调心，一句话里面有变化和转折的地方。 调型一常用于陈述句。调心一般在最后一个单词的重读音上。调心前高后低。如： 调型二语调下降。 场景一：常用于疑问句。调心放在疑问词上。 场景二：常用在呼语上。如下面的 мама 场景三：常用在强调词。如下图的 стоп 和 опасно。 调型三常用在没有疑问词的疑问句。调心在想要提问的词的重音上。先扬后抑的感觉，语调快速挑上去，再快速下降。 调心刚好在最后时，就不用降调了。 调型四常用在有对比意味的疑问句中。调心前部是平常语调，调心先降后升。 А тебя? А меня? А вас? А тебя как зовут? 你？我？你叫什么？ 调型五一般用在 как какой сколько 等开头的感叹句中，表示对事物的评价，大多表示赞赏。 第一个调心在表示特征或者评价程度的词上面用升调。 как какой сколько 第二个调心在具有什么特征或者评价的词上用降调。（形容的定语或者对象，形容词、名词） погода 好人卡： 事务性疑问句语调 - 用调型四多见于公事性的问话，比如填写登记表，出入要求出示证件，询问对方姓名民族职业等等，显得正式、委婉。 句末语段和非句末语段的调型一个语段是一个调型完整的读音单位。一个陈述句包含两个以上语段时，最后的语段就叫做句末语段，其他语段就是非句末语段。 句末语段常用调型一，表示结束了。 非句末语段恶意用一三四表达。 四更正式，用于广播独白。一三更口语化。 列举语调在读有列举成分的陈述句时，一二三四都可以用，但只能用其中一种。 反问句语调用调型三","categories":[],"tags":[{"name":"俄语笔记","slug":"俄语笔记","permalink":"https://laputaz.github.io/home/tags/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0/"}]},{"title":"实现：百度 lowcode 框架 amis 框架封装","slug":"实现-百度lowcode框架amis框架封装","date":"2021-12-22T16:59:34.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"实现-百度lowcode框架amis框架封装/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-%E7%99%BE%E5%BA%A6lowcode%E6%A1%86%E6%9E%B6amis%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/","excerpt":"简单记录一下百度 lowcode 框架 amis 的封装历程。","text":"简单记录一下百度 lowcode 框架 amis 的封装历程。 什么是 lowcode前端真的太卷了，总是会出现一些莫名其妙的新概念、新名词。 但仔细看往往会发现，其实不是什么新技术，而是旧的思想焕发新生。 lowcode 指的是低代码开发，是通过配置或者图形化，来生成程序。 在上家公司做的拖拽生成页面的项目，也算是 lowcode 了。 对于前端来说，很主要的一个应用就是通过配置生成界面。 为什么要用 lowcode 开发前端admin 团队，主要维护内部系统。 内部系统的需求，往往都是增删改查数据。 例如一个库存系统，主要页面就是 =&gt; 列表页，查询记录，详情页，增加一个条目，编辑一个条目，删除一个条目。 此模式的的页面，占总页面的比例很大。 并且因为功能相似，代码较为重复，会耗费很多无意义的开发时间。 这种页面的常见模式一般是: 12列表页：表单+按钮+表格详情页：表单+按钮 把这种模式的页面抽象起来，变成用配置描述的形式，如： 12345678910111213141516171819202122232425262728&#123; // 页面标题 title: &#x27;xxx&#x27;, // 表单 form: &#123; // 提交的url url: &#x27;http://xxx.com/post&#x27;, // 表单项 items: [ &#123; type: &#x27;input&#x27;, field: &#x27;name&#x27; &#125;, &#123; type: &#x27;button&#x27;, action: &#x27;submit&#x27; &#125; ] &#125;, table: &#123; sortable: true, columns: [ &#123; name: &#x27;cloumn1&#x27;, prop: &#x27;prop1&#x27; &#125; ] &#125;&#125; 通过配置的形式，快速生成 vue 组件，最后生成页面，可以减少开发时间。 后期文档完善后，甚至可以让产品同学直接参与配置页面。 当功能成熟以后，也可以作为一种新的约束、规范，避免设计出奇奇怪怪的交互。 但这也不是没有缺点。 所有的工具，能力都是有边界的，lowcode 没有办法顾及所有形式的页面。 复杂的的场景还是需要单独开发的。 选型lowcode 其实已经有一些成熟的框架了，例如百度的 amis, 例如 umijs/sula。 鉴于 amis 的 star 数量远远超过其他，社区也比较完善： 由百度团队维护 大量内置组件（100+）（内容丰富） 支持自定义组件来拓展 （拓展能力强） 经历了长时间的实战考验 （bug 少，使用人数多） 所以选择了 amis。 目前团队使用的技术栈是 vue, 但 amis 是基于 react 开发的，这就需要经过一层转换了。 利用高阶组件的原理，可以将 amis 封装转换成 vue 可用的组件。 实现目标最终需要实现的效果是：暴露一个函数，入参为 json 配置，输出一个 vue 组件。 123456renderer(json, options) &#123; // process amis here .... // return vue component return vueComponent&#125; 思路如下图 amisRender() 会生成一个 React 组件 我们在 React 组件上层包裹一层 Wrapper 组件（Vue） 最后实现一个 renderer() 方法，再对第 2 步的 Vue 组件做一层包装，返回新的 Vue 组件 第一步：实现 Wrapper 组件（Vue） html 模板。我们定义一个 Vue 组件的模板，包含一个元素，元素节点引用名称为 ’amis‘。 123456&lt;template&gt; &lt;div class=&quot;amis-page&quot;&gt; &lt;!-- 元素节点引用名称为 ’amis‘ --&gt; &lt;div ref=&quot;amis&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 引入 amis 相关文件以及 React 123456789101112&lt;script&gt; // React import React from &#x27;react&#x27; import ReactDOM from &#x27;react-dom&#x27; // amis 依赖的样式文件 import &#x27;@fortawesome/fontawesome-free/css/regular.css&#x27; import &#x27;@fortawesome/fontawesome-free/css/fontawesome.css&#x27; // 引入 amis import &#123; render as renderAmis &#125; from &#x27;amis&#x27; // amis 样式文件 import AmisStyle from &#x27;amis/lib/themes/antd.css&#x27;&lt;/script&gt; 组件接受一个 json 串，因此定义一个 prop，名为 schema 123export default &#123; props: [&#x27;schema&#x27;],&#125; 在组件 mounted 后，我们开始使用 react 挂载 amis。 12345export default &#123; mounted() &#123; this.mountReactComponent() &#125;,&#125; mountReactComponent 方法具体写法 1234567891011121314151617181920212223242526272829303132333435363738export default &#123; methods: &#123; mountReactComponent() &#123; // 获取当前Vue实例 let $vm = this // 定义 amis 需要的参数 let passedProps = [ // 参数一，json配置 this.schema, // 参数二，一些amis支持的配置，主要是配置需要传入的业务数据 &#123; locale: this.amisLocale, // locale: &quot;en-US&quot;, // 一些可能用到的参数 data: &#123; userInfo: $vm.userInfo, &#125;, &#125;, // 参数三，同样是一些amis支持的配置 &#123; theme: &#x27;antd&#x27;, // 主题 fetcher: () =&gt; &#123; // 这里可以在请求之前做一些操作 // 例如设置自定义请求头 // 例如设置 amisGetRespIntercept 请求、响应拦截器等等 &#125;, // 用来覆盖请求方法 jumpTo: (to /*目标地址*/, action /* action对象*/) =&gt; &#123;&#125;, // 用来覆盖跳转方法 // ... // ... // ... &#125;, ] // 关键 ------------------------------------------------------------------------- // 关键 ------------------------------------------------------------------------- // 挂载 React 组件，挂载元素是 this.$refs.amis ReactDOM.render(&lt;div&gt;&#123;renderAmis(...passedProps)&#125;&lt;/div&gt;, this.$refs.amis) &#125;, &#125;,&#125; 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div class=&quot;amis-page&quot;&gt; &lt;!-- 元素节点引用名称为 ’amis‘ --&gt; &lt;div ref=&quot;amis&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // React import React from &#x27;react&#x27; import ReactDOM from &#x27;react-dom&#x27; // amis 依赖的样式文件 import &#x27;@fortawesome/fontawesome-free/css/regular.css&#x27; import &#x27;@fortawesome/fontawesome-free/css/fontawesome.css&#x27; // 引入 amis import &#123; render as renderAmis &#125; from &#x27;amis&#x27; // amis 样式文件 import AmisStyle from &#x27;amis/lib/themes/antd.css&#x27; export default &#123; methods: &#123; props: [&#x27;schema&#x27;], mounted() &#123; this.mountReactComponent() &#125;, mountReactComponent() &#123; // 获取当前Vue实例 let $vm = this // 定义 amis 需要的参数 let passedProps = [ // 参数一，json配置 this.schema, // 参数二，一些amis支持的配置，主要是配置需要传入的业务数据 &#123; locale: this.amisLocale, // locale: &quot;en-US&quot;, // 一些可能用到的参数 data: &#123; userInfo: $vm.userInfo, &#125;, &#125;, // 参数三，一些amis支持的配置 &#123; theme: &#x27;antd&#x27;, // 主题 fetcher: () =&gt; &#123; // 这里可以在请求之前做一些操作 // 例如设置自定义请求头 // 例如设置 amisGetRespIntercept 请求、响应拦截器等等 &#125;, // 用来覆盖请求方法 jumpTo: (to /*目标地址*/, action /* action对象*/) =&gt; &#123;&#125;, // 用来覆盖跳转方法 // ... // ... // ... &#125;, ] // 关键 ------------------------------------------------------------------------- // 关键 ------------------------------------------------------------------------- // 挂载 React 组件，挂载元素是 this.$refs.amis ReactDOM.render( &lt;div&gt;&#123;renderAmis(...passedProps)&#125;&lt;/div&gt;, this.$refs.amis ) &#125;, &#125;, &#125;&lt;/script&gt; 以上是 Vue 组件的包装，但只是简化的代码，实际情况并没有那么简单。我们还需要加入： 权限拦截 多语言 弹窗，confirm 等组件 实现 fetcher 中的请求方法自定义 … 这些部分涉及业务逻辑，在这里我就不写了。 第二步：实现 renderer 函数。Vue 组件实现完成后，接下来实现 renderer 包裹层。 这里使用了 vue-compose 这个库，这个库可以实现类似 vue.extend 的功能 vue-compose 提供的 compose 方法，接受一个 vue 组件或者类 vue 对象，生成一个新的 vue 组件。 123456789101112131415161718import &#123; compose, withProps &#125; from &#x27;vue-compose&#x27;import BaseComponent from &#x27;./baseComponent.vue&#x27; // 上一步实现的Vue组件import &#123; amisWrapper &#125; from &#x27;./amisWrapper.js&#x27;// 暴露的函数const renderer = (schema, opts) =&gt; // vue-compose 接受一个 vue 组件，加入一些参数，生成一个新的 vue 组件。 compose( withProps(&#123; schema() &#123; // 这里增加了一层 amisWrapper 包裹，用来对传入的json做一层转换（可选） return JSON.parse(amisWrapper.call(this, schema, opts)) &#125;, &#125;) )(BaseComponent)// 暴露 renderer 函数export &#123; renderer &#125; 使用经过上面的两步封装，已经可以正常使用了。 先按照 amis 的规范，写一份 json 配置文件。 这里用 JSON.stringify 序列化了，是为了防止出现 json 格式错误： 其中： title 是页面标题 body 是页面内容，类型是 form 表单 initApi 是用来初始化表单的 api controls 是表单项，可以使 input, select, 或者纯文案 table 作为表单项的一部分 action 是表单的操作按钮，按钮有一系列行为，例如页面跳转，或者请求接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// my-schema.js// 详见 amis 官网export default JSON.stringify(&#123; title: &#x27;Experiment Preview&#x27;, body: &#123; type: &#x27;form&#x27;, mode: &#x27;horizontal&#x27;, initApi: &#x27;/v1/campaignexperimentsrv/experiments/$id&#x27;, controls: [ &#123; type: &#x27;tpl&#x27;, name: &#x27;experiment_tag&#x27;, tpl: &#x27;$&#123;experiment_tag&#125;&#x27;, label: &#x27;Experiment Tag&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;start_date&#x27;, label: &#x27;Start Date&#x27;, tpl: &#x27;$&#123;start_date&#125;&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;end_date&#x27;, label: &#x27;End Date&#x27;, tpl: &#x27;$&#123;end_date&#125;&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;traffic_split&#x27;, label: &#x27;Traffic Split&#x27;, tpl: &#x27;Experiment: $&#123;traffic_split&#125; %, Control: $&#123;traffic_split|minus:100|abs&#125; %&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;budget&#x27;, label: &#x27;Budget&#x27;, size: &#x27;md&#x27;, tpl: &#x27;$&#123;budget&#125;&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;budget_manual&#x27;, label: &#x27;Budget Manual&#x27;, size: &#x27;md&#x27;, tpl: &#x27;$&#123;budget_manual&#125;&#x27;, className: &#x27;font-bold&#x27;, required: true, visibleOn: &#x27;this.budget === &quot;manual&quot;&#x27;, &#125;, &#123; type: &#x27;tpl&#x27;, name: &#x27;kpi&#x27;, label: &#x27;KPI&#x27;, size: &#x27;md&#x27;, tpl: &#x27;$&#123;kpi&#125;&#x27;, className: &#x27;font-bold&#x27;, required: true, &#125;, &#123; type: &#x27;divider&#x27;, &#125;, &#123; type: &#x27;static-tpl&#x27;, label: &#x27;-&#x27;, tpl: &#x27;Showing 1-20 campaigns out of total $&#123;number_experiments&#125; of experiment campaigns&#x27;, &#125;, &#123; type: &#x27;table&#x27;, name: &#x27;experiments&#x27;, label: &#x27;-&#x27;, columns: [ &#123; name: &#x27;base.name&#x27;, label: &#x27;Base Campaign&#x27;, &#125;, &#123; name: &#x27;experiment.name&#x27;, label: &#x27;Experiment Campaign&#x27;, &#125;, ], &#125;, ], actions: [ &#123; type: &#x27;button&#x27;, label: &#x27;Cancel&#x27;, actionType: &#x27;url&#x27;, blank: false, url: &#x27;/mktautomation/experiment-tool/experiment-list&#x27;, &#125;, ], &#125;,&#125;) 接下来，找到项目的 router 路由，引入 json 和 renderer 函数使用 renderer(json) 生成 vue 组件，并作为 router 的 component 传入。 123456789101112131415161718192021// 引入函数import &#123; renderer &#125; from &#x27;../renderer&#x27;import schema from &#x27;./my-schema&#x27;// 路由配置export default &#123; path: &#x27;my-tool&#x27;, name: &#x27;my_tool&#x27;, children: [ /** * 详情 */ &#123; path: &#x27;my-list&#x27;, name: &#x27;my_list&#x27;, component: renderer(schema), // 生成的Vue组件直接传给路由 meta: &#123; title: &#x27;my List&#x27;, &#125;, &#125;, ],&#125; 使用 lowcode 的缺点在于配置项异常繁杂，需要一定的时间成本来学习配置项。 所以在初期，需要投入的开发时间甚至多于直接写代码的时间。 但从长久来看，只要配置稳定，上手之后仍然是可以节省很多时间的。 以上","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://laputaz.github.io/home/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}]},{"title":"js-admin权限设计","slug":"js-admin权限设计","date":"2021-10-04T15:48:14.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js-admin权限设计/","link":"","permalink":"https://laputaz.github.io/home/js-admin%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/","excerpt":"admin 的权限设计方案","text":"admin 的权限设计方案 当前权限系统设计（RBAC）Admin 系统采用了一套 Role Based Access Control（RBAC）设计方案，其中 Access 是代码中实际进行权限判断的信息，Role 是为了便捷的分配一组权限而设置的。 当前问题：权限定义 权限用于控制页面和功能的交互，但粒度标准不一致，且权限之间关系没有考虑在内 角色分配 角色描述不清晰，难以被理解 申请 申请流程不标准 申请人不清楚该申请的角色 申请人申请的角色缺少审批&amp;管控 只有 Camila 可以进行账户管理，工作量大 新功能权限/角色创建 权限和角色定义模糊，创建的思路不统一 新功能权限的创建比较随意，没有规范流程 权限和角色的创建人(开发)和使用人(需求方)分割，导致创建后难以分配和管理 权限系统理解 admin 权限系统没有在公司内形成一致的理解，权限/角色概念不清晰 其他 新用户/离职权限管理 ref: 需求列表 主要改动 规范权限/角色概念， 添加 用户组 概念， 添加 权限管理人 角色 规范申请权限，人事变动，上线新功能的权限管理流程 整理现有权限/角色，规范 开发/用户/PM/管理人 责任划分 建立 权限管理人 白名单 完善 admin 权限管理功能， 添加几个新的功能页面 未来期望场景权限申请流程：除了 Camila 之外建立代理机制，可以让每个模块/业务团队单独分配角色 在新的申请流程里面， 申请人只需要找到对应权限管理人申请既可 添加新权限/角色流程： 由 PM 在设计需求的时候同时设计，然后同步给需求方以及开发， 开发按照 PM 设计的需求开发对应的权限 需求上线时，新角色分配给权限管理员，然后由权限管理员分配角色给用户组或用于 新责任划分 权限代理人： 拥有团队的权限，拥有一些权限可以自己分配，可以拥有用户组的管理能力，负责在团队有新的人员/权限的时候进行分配，权限管理人的权限变动可以其他管理人或者 PM PM：对应业务部分相关权限的负责人，上线新需求的时候按标准设计新的角色和权限并给到对应业务组和开发，对已有权限进行维护和整理。 admin 开发： 开发负责角色的对应权限的开发，以及在角色制定的时候进行 review 业务团队/用户： 业务团队在人事变动和业务改动的情况下寻求权限管理人去管理对应权限 用户组管理人： 用户组管理人可以管理用户组，这个角色可能是权限管理员，也可以是管理员分配 权限相关设计方案权限（Access） 权限的作用 权限是代码中实质的管控目标。用户在 Admin 页面中是否有查看和操作权限，完全由权限来控制。但是对于用户而言权限是透明的，通常用户知道自己拥有什么角色，不必知道自己有什么权限。 创建职责 对于新开发的功能或模块，PM 提交权限设计，Admin 团队评审。 设计标准 通常页面访问和页面内需要做访问控制的最小粒度功能，可以被设计为一个权限。例如一个页面中含有一张表格，可以对表格中的记录进行增删改查，则对应的潜在权限为：页面访问权限（控制展示页面入口）、表格查看权限、表格中记录的操作权限：删除、添加、修改。如果需要针对表格中的内容进行进一步的限制，用户根据自己的权限只能访问符合特定条件的记录，例如只能访问特定国家地区的记录，则这一类权限控制不在这一部分，我们将另辟章节讨论。 1. 权限类型：Admin系统权限是前端权限，既按前端使用思维设计 1. 命名规范 1. 采取类似目录层级形式的命名方式，属于同一模块、同一页面的权限，阅读名字可知 1. 通过名称能看出去权限的大致类型（页面、操作、内容等），用词多用xxx_page, manage, view, cancel, delete 等。 1. 权限分类：页面（目录）访问权限 和 页面内权限（例如功能权限）&amp;amp; 内容权限 1. 权限关系：页面内权限继承页面访问权限，例如页面中某个功能提交权限自动继承页面访问权限 1. 权限粒度 - 权限不跨页面 - 设计时页面访问和页面内操作尽量分开，避免权限过大需要拆分 订单模块的权限示例： 权限名 描述 booking/booking_tasks_page booking 模块 booking tasks 页面的访问权限 booking/booking_tasks_page/manage booking 模块 booking tasks 页面内 tasks 管理权限 booking/order_summary_page/fraud_recovery/manage booking 模块 order summary 页面里 fraud 恢复的管理权限 审计和维护 维护职责：Admin 系统开发人员 权限相对变动少，需要定期评估的有： 1. 定期报告检查和清理未使用权限 1. 收集反馈拆分过大权限、或添加缺失的权限控制 1. 根据内审团队提供的权限关系表，审核是有账号同时有用有冲突的两个权限（有些权限因为业务原则，不能被同一账户同时拥有） 角色（Role） 角色的作用 角色是向账户分配权限的最小单位，角色是一组权限的集合。我们不直接向账户分配权限，而是向其分配角色。通常权限多且散碎，角色一组相关权限整理到一起，需求方只需理解到角色的含义。 创建职责 PM 根据产品交互流程/操作流创建角色，Admin 系统开发人员 review 设计标准 在我们设计中，角色与用例（Use Case）直接相关，包含一个用例中所有步骤涉及的一组权限。 1. 角色类型：是功能角色，而不是用户职位。例如角色是财务对账单审核者，而不是财务总监 1. 命名规范 - 与Access的目录式名称不同，权限名称字符串中词语用下划线&amp;#39;_&amp;#39;连接 - 能看出所属模块（模块命名空间） - 避免使用用户职位名称（如LOC PM），应该用系统角色名称（LOC Request Manager) - 名称中建议使用manager/editor/viewer/operator等尾缀 1. 角色粒度 - 角色不跨模块 - 角色是按照用例的交互流程来设定，完成一个用例中所有操作需要的权限可以设为一个角色（完备性） - 多数情况下用例的设置比较自然且显而易见，但也有写情况下，用例可大可小，是否进一步拆分用例原则为，如果理论上一个用例中有部分操作与整体操作需要进行不同的权限控制，则应该拆分用例，并设置不同角色。例如，有些数据表的相关用例只有两个，即view和manage。但有些业务场景需要对manage部分进行进一步拆分，例如需要拆出一个create用例仅仅负责插入记录，然后manage进行所有的管理操作。 订单模块的角色示例： 角色名称 对应权限 booking_booking_tasks_viewer booking/booking_tasks_page booking_booking_tasks_manager booking/booking_tasks_page booking/booking_tasks_page/manage booking_fraud_recovery_viewer booking/order_summary_page booking/order_summary_page/fraud_recovery/view booking_fraud_recovery_manager booking/order_summary_page booking/order_summary_page/fraud_recovery/view booking/order_summary_page/fraud_recovery/manage 审计和维护 维护职责：相关模块的 PM 角色作为权限和用户中间一层抽象，变化会比较多，尤其是考虑到设计的标准本身很难严格细致： 定期报告检查和清理未使用角色 定期检查过大过小角色，看是否有拆分和合并的可能 定级检查角色查看是否其中含有互相冲突的权限（有些权限因为业务原则，不能被同一账户同时拥有） 账户相关设计方案账户（User Account） 账户的作用 用来登录 Admin 系统，最终所有角色分配的对象，以及权限管控对象。 创建职责 klk 员工：员工自行创建。使用 klk 账户初次登录 Admin 系统，会自动创建 Admin 系统账户。 非 klk 员工：Camila 和账户所有者。Camila 加白名单，账户所有者初次登录 Admin 系统创建账户。 设计标准 难点是能否约束尽可能多的账户都有所属部门信息。对于有所属部门信息的账户，就可以由部门的权限管理员对其进行部分权限管理（分配用户组）。 审计和维护 账户的审计和维护主要是指关闭账户操作。 维护职责：Camila 和各部门权限管理人员 主要工作内容： 按部门定期出报告或者有页面可以查询到 部门内账户情况，审查是否所有账户需要关闭 关闭时需要清除所有的权限 非 LOOK 员工账户关闭时需要移出白名单 ？关闭账户操作最终由各部门权限管理员执行，还是 Camila 执行？ 用户组（User Group) 用户组的作用 按岗位职责，定义一组常用的角色，便捷的分配给账户 部门权限管理员有权限将部门内用户，加入到部门里的所拥有的用户组 创建职责 各部门权限管理员，根据团队内岗位和职责定义用户组。 设计标准 用户组类型：是用户职位，而不是系统角色。例如职位是翻译项目经理，而不是翻译请求管理者 命名规范：尽量使用职位进行命名 用户组关系：用户组属于部门（部门信息不完善的过渡期内，用户组属于部门权限管理员），部门有层级关系，上级部门拥有下属部门的所有用户组；以职位常用为标准，将一组角色分配给用户组，这些角色可以跨功能模块。 用户组粒度：用户组不能跨部门，例如两个部门都需要项目经理，但是需要两个不同用户组 审计和维护 维护职责：各部门权限管理人员 维护内容分为三块： 定期报告，将不再需要相关权限的用户，移除相应用户组 定期报告，检查是否需要拆分、合并、新建、删除用户组 定期报告，检查是否需要调整用户组的角色，调整用户组角色时可能也要相应调整对应用户的角色。例如某个角色并非用户组通用，只有少数用户需要，从中移除后需要为少数用户单独加上这些角色 部门（Department/Division) 部门的作用 约束部门权限管理员能管理的用户组，所有的用户组都归属于某个部门 约束用户组可被分配给的用户，所有用户（或有特例）都有部门信息，所有部门都有权限管理员，后者可为前者分配用户组 创建职责 从 workday 中传入，从 workday 的部门层级中挑选某一级或者某几级作为 Admin 权限系统的部门。 初期通过 RaaS，每日更新 后期通过 API 实时获取 设计标准 部门类型：用户从 HR 角度的部门信息，部门权限管理员类似于 BLM 部门关系： 部门有指定的权限管理员（可多值） 用户组属于部门 用户属于部门，部门有层级关系 部门有权限管理员有权分配本部门的用户组给本部门的用户 通过审批流程，Camila 有权限分配任意用户组给任意用户 审计和维护 维护职责：各部门权限管理人员 有了部门之后可以做一些相关审计： 本部门用户拥有的非本部门用户组报告 非本部门用户拥有的本部门用户组报告 分阶段计划Step 1 - 项目开展的前提——整理现有权限和角色（订单模块）在这一步，制定权限和角色的设计标准，按这个标准清理现有权限和角色，并加上合理的描述。 主要变化有： 订单模块将会使用新的权限&amp;角色定义 有了一套新的标准 ，后续 PM 和 Admin 系统开发都要按规范设计角色和权限 有一套 guideline , 以后权限申请请求都有统一的格式，Camila 也知道判断哪些人有权提交申请表。更重要的是有了部门权限管理员这个角色，后面很多事情可以由这个角色完成。 初步整理权限管理人名单 Step 2 - 增加模块这一步逐渐完成 admin 系统已有权限角色的整理&amp;迁移 Step3 - 新增用户组部门权限管理员基于部门内的职位/职责来整理出用户组，用户组包含职位/职责的常用的一组角色。 部门权限管理员可以替组内成员申向 Camila 请加入属于本部门的用户组。 新建用户组页面, 各部门权限管理员有查看权限, Camila 有管理权限。 主要变化有： 这样部门权限管理员就可以根据员工的职位/职责申请一个或者多个用户组，如果用户组覆盖不到的角色再单独申请。虽然还是要经过 Camila，但是有了用户组，可以更高效的给用户申请权限。 Step4 - 自助在线分配用户组部门权限管理员可以自助将用户加入/移除自己所拥有的用户组。同时为员工申请权限也可以通过页面提交，审批也在页面中进行。 主要变化有： 大部分的权限开通请求到不了 Camila 这边，部门权限管理员通过将用户加入/移出其管理的用户组就可以实现。 Step5 - 在线提交权限申请、和用户组变更申请之前虽然部门权限管理员可以为员工提交权限申请，但是申请是通过申请表发送。审批也是 Camila 线下进行，然后手动在 Admin 系统中操作。 另外Step3 - 新增用户组中，如果部门权限管理员需要修改用户组（增删用户组、增删用户组中角色），都需要通过线下申请流程。 这一阶段支持两种申请通过线上提交和审核，审核后自动生效。 主要变化： 除非特殊情况，Camila 不再收到线下的申请。大部分工作转为线上。 Step6 - 强化部门概念，建立部门实体截至目前，部门只是账户的一个可选属性。根据设计，用户归属于部门、用户组归属于部门，权限管理员对部门行使管理权限而不是用户组。 一个缺点是，无法根据部门进行控制，例如一个部门权限管理员，可以将其拥有的用户组分配给其他部门的人，或者可以为非本部门员工提交申请。 这里通过联通 Workday，引入员工部门信息，并将用户组纳入部门。 主要变化： 角色申请和用户组内成员管理更可控，所有跨部门的申请都需要经过 Camila。 Camila 可以更高效的在线审核申请。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}]},{"title":"前端包管理工具对比","slug":"前端包管理工具对比 copy","date":"2021-08-09T10:13:05.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"前端包管理工具对比 copy/","link":"","permalink":"https://laputaz.github.io/home/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%20copy/","excerpt":"前端包管理工具总结","text":"前端包管理工具总结 1 包管理工具1.1 npm作用npm 是随同 NodeJS 一起安装的包管理工具，允许用户下载或上传包或命令行程序供开发者使用； npm install 流程执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤: 将依赖包的版本区间解析为某个具体的版本号 下载对应版本依赖的 tar 包到本地离线镜像 将依赖从离线镜像解压到本地缓存 将依赖从缓存拷贝到当前目录的 node_modules 目录 常用命令npm init -y 直接生成默认配置 npm -v 版本查看 npm list 查看已安装包 带上[–depth 0] 不深入到包的支点 npm info jquery 查看版本 npm install 包名@版本号 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装淘宝镜像 npm search 搜索词 -g 用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式 npm update [-g] 更新模块 npm run 执行脚本 npm publish 发布模块 npm dedupe 合并重复依赖，减少重复 问题（3 版本之前） 依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下，会造成安装失败或删除 node_modules 失败。 大量重复的包被安装，node_moudles 体积超级大。比如跟 foo 同级目录下有一个 baz，两者都依赖于同一个版本的 lodash，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。 模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。 PS：3 版本及其后的和 yarn 的问题一致； 包调试方案npm/yarn linknpm link 用于连接本地项目和本地 npm 模块，使得可以在本地进行模块测试； 具体用法： 项目和模块在同一个目录下，可以使用相对路径：npm link ../module 项目和模块不在同一个目录下 cd 到模块目录，npm link，进行全局 link cd 到项目目录，npm link 模块名(package.json 中的 name) 解除 link：npm unlink 模块名 原理：在全局包路径中创建一个软链（Symlinked）指向对应的 npm 包，然后在项目中通过软链将全局的软链指向到 node_modules 的对应包中； 此方案缺点： 影响 node_modules 中原本的依赖包; 软链接和文件系统引发的其他各种奇怪的问题； webpack 在进行编译的时候无法编译软链接的依赖库。 相对路径或者绝对路径使用// import { Button } from ‘good-ui’ // 为了调试，强行改成了绝对或者相对路径 import { Button } from ‘C:/codes/good-ui/dist’ 此方案缺点：需要频繁改业务代码，这既麻烦又危险（路径有可能进行修改，在 git 提交代码的时候，引用路径忘记修正回来则其他开发者无法正常使用）。 yalc模拟 npm 发布，并将包缓存本地，下载时也是模拟 npm install，所以不会存在相关依赖库丢失，只是模拟发布和下载不会真的推包； 使用方法： 需要发包的项目中执行：yarn build &amp;&amp; yalc publish 使用包的项目中执行：yalc add 包名 其他概念dependencies 与 devDependencies 之间的区别：dependencie 配置当前程序所依赖的其他包。devDependencie 配置当前程序所依赖的其他包，只会下载模块，而不下载这些模块的测试和文档框架 包版本概念：^表示第一位版本号不变，后面两位取最新的；~表示前两位不变，最后一个取最新；*表示全部取最新 lock 文件：npm5 通过添加 lock 文件来记录依赖树信息，进行依赖锁定,从而唯一确定 node_modules 的结构,这样处理可以保证团队成员使用同一份 node_modules 依赖结构。 1.2 yarn快速、可靠、安全的依赖管理工具。 安装npm install –global yarn 作用 速度快：Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。如果你以前安装过某个包，再次安装时可以在没有任何互联网连接的情况下进行。 超级安全：在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 确定性：不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装。 网络性能：Yarn 有效地对请求进行排队处理，避免发起的请求如瀑布般倾泻，以便最大限度地利用网络资源。 相同的软件包：从 npm 安装软件包并保持相同的包管理流程。 网络弹性：重试机制确保单个请求失败并不会导致整个安装失败。 扁平模式：将依赖包的不同版本归结为单个版本，以避免创建多个副本。所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。 问题 NPM 分身：依赖结构的不确定性。只提升 package.json 里面排在前面的包的重复引用包，其他版本的不提升； 扁平化算法本身的复杂性很高，耗时较长。 幽灵依赖或幻影依赖：项目中仍然可以非法访问 package.json 没有声明过依赖的包，因为部分包被提升了； 常用命令 命令 慕课释义 yarn add 添加依赖 yarn audit 对已安装的软件包执行漏洞审核 yarn autoclean 从程序包依赖项中清除并删除不必要的文件 yarn bin 显示依赖 bin 文件夹的位置 yarn cache 管理用户目录中的依赖缓存 yarn check 验证当前项目中程序包依赖项 yarn config 管理依赖配置文件 yarn create 创建 Yarn 工程 yarn dedupe 删除重复的依赖 yarn generate-lock-entry 生成 Yarn 锁文件 yarn global 在全局安装依赖 yarn help 显示 Yarn 的帮助信息 yarn import 迁移当前依赖的项目 package-lock.json yarn info 显示有关依赖的信息 yarn init 初始化工程并创建 package.json 文件 yarn install 用于安装项目的所有依赖项 yarn licenses 列出已安装依赖的许可证及源码 url yarn link 链接依赖文件夹 yarn list 列出已安装的依赖 yarn login 存储您在 registry 上的用户名和 email yarn logout 清除你在 registry 上用户名和 email yarn outdated 列出所有依赖项的版本信息 yarn owner 展示依赖作者 yarn pack 创建依赖项的压缩 gzip yarn policies 规定整个项目中执行 Yarn 的版本 yarn publish 将依赖发布到 npm 注册表 yarn remove 删除依赖 yarn run 运行定义的程序脚本命令 yarn tag 在依赖上添加，删除或列出标签 yarn team 管理组织中的团队，并更改团队成员身份 yarn test 运行程序的 test 命令 yarn upgrade 将指定依赖升级为最新版本 yarn upgrade-interactive 更新过期依赖的简便方法 yarn version 展示依赖版本信息 yarn versions 展示所有依赖项版本信息 yarn why 显示有关为什么安装依赖的信息 yarn workspace Yarn 的工作区信息 yarn workspaces Yarn 的所有工作区信息 1.3 pnpm快速的，节省磁盘空间的包管理工具； 安装npm install –global pnpm 作用 快速：pnpm 比其他包管理器快 2 倍； 高效：node_modules 中的文件为复制或链接自特定的内容寻址存储库； 支持 monorepos：pnpm 内置支持单仓多包； 严格：pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包； 原理node_modules 并不是扁平化结构，而是目录树结构，同时还有个.pnpm 目录，.pnpm 以平铺的形式存储着所有的包，并以组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称) 结构存储；由于它只会根据项目中的依赖生成，并不存在提升，所以它不会存在之前提到的幻影依赖问题； pnpm 资源在磁盘上的存储位置为.pnpm-store 的文件夹中，Mac/linux 中默认会设置到{home dir}&gt;/.pnpm-store/v3；windows 下会设置到当前盘的根目录下，比如 C（C/.pnpm-store/v3）、D 盘（D/.pnpm-store/v3）。由于每个磁盘有自己的存储方式，所以 Store 会根据磁盘来划分。 如果磁盘上存在主目录，存储则会被创建在 /.pnpm-store；如果磁盘上没有主目录，那么将在文件系统的根目录中创建该存储。 例如，如果安装发生在挂载在 /mnt 的文件系统上，那么存储将在 /mnt/.pnpm-store 处创建。 Windows 系统上也是如此。可以在不同的磁盘上设置同一个存储，但在这种情况下，pnpm 将复制包而不是硬链接它们，因为硬链接只能发生在同一文件系统同一分区上。如图可以看到在使用 pnpm 对项目安装依赖的时候，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。 常用命令 pnpm store prune 删除不被引用的包 pnpm add xxx 添加包 –save-prod, -P：安装到dependencies –save-dev, -D：安装到devDependencies –save-optional, -O：安装到optionalDependencies –save-peer：安装到peerDependencies和devDependencies中 –global：安装全局依赖。 –workspace：仅添加在 workspace 找到的依赖项。 pnpm remove xxx 删除某个包 pnpm install 安装所有依赖 pnpm list 以一个树形结构输出所有的已安装 package 的版本及其依赖。添加参数–json 后会输出 JSON 格式的日志。 pnpm run xxx 跑脚本； 其他概念inode ：是描述文件/目录属性的数据库，例如元数据和硬盘上的物理位置. 它们本质上是完整地址的数字等价物。使用 inode，操作系统可以检索有关文件的信息，例如权限和数据在硬盘驱动器上的物理位置，以访问文件。如果文件从一个文件夹移动到另一个文件夹，该文件将被移动到硬盘驱动器上的不同位置，其 inode 值将随之自动更改。 硬连接：硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。hark link 只能用于文件不能用于目录； 软连接：另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。目录使用软连接； peerDependencies的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。 pnpm v3 链接图： 2 Monorepomonorepo 就是把多个工程放到一个 git 仓库中进行管理，因此他们可以共享同一套构建流程（更改代码、发包）、代码规范也可以做到统一，特别是如果存在模块间的相互引用的情况，查看代码、修改 bug、调试等会更加方便。 3 基于 lerna 搭建 monorepolerna 是一个管理工具，用于管理包含多个软件包（package）的 js 项目，优化了使用 git 和 npm 管理多包存储库的工作流。 3.1 工作的两种模式lerna 默认使用的是集中版本，所有的 package 共用一个 version。如果希望不同的 package 拥有自己的版本，可以使用Independent模式 Fixed/Locked mode (default)vue,babel 都是用这种，在 publish 的时候,会在 lerna.json 文件里面”version”: “0.1.5”，依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号。 Independent modelerna init –independent 初始化项目。 lerna.json 文件里面”version”: “independent”, 每次 publish 时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改。 3.2 解决了哪些问题？规范问题和简化流程； 自动解决 packages 之间的依赖关系 可采用 Independent 模式，通过 git 检测文件改动，自动发布，； 根据 git 提交记录，自动生成 CHANGELOG 统一整个工程化，比如 eslint 规则检查、prettier 自动格式化代码、提交代码，代码检查 hook、遵循 semver 版本规范 3.3 指令总览 指令 解释 链接(英文) lerna publish 在当前项目中发布包注意: Lerna 永远不会发布标记为 private 的包（package.json 中的”private“: true） 前往 lerna version 更改自上次发布以来的包版本号 前往 lerna bootstrap 将本地包链接在一起并安装剩余的包依赖项 前往 lerna list 列出本地包 前往 lerna changed 列出自上次标记发布以来发生变化的本地包 前往 lerna diff 自上次发布以来的所有包或单个包的区别 前往 lerna exec 在每个包中执行任意命令 前往 lerna run 在包含该脚本中的每个包中运行 npm 脚本 前往 lerna init 创建一个新的 Lerna 仓库或将现有的仓库升级到 Lerna 的当前版本 前往 lerna add 向匹配的包添加依赖关系 前往 lerna clean 从所有包中删除 node_modules 目录 前往 lerna import 将一个包导入到带有提交历史记录的 monorepo 中 前往 lerna link 将所有相互依赖的包符号链接在一起 前往 lerna create 创建一个新的由 lerna 管理的包 前往 lerna info 打印本地环境信息 前往 3.4 搭建 lerna 项目 安装 lerna：npm install –global lerna 初始化项目：git init lerna-repo &amp;&amp; cd lerna-repo 初始化 lerna：lerna init；得到文件夹 lerna-repo/ packages/ package.json lerna.json 创建子应用：lernam create 子应用名称； 4 基于 pnpm 搭建 monorepo 调整目录结构如下 1234567891011121314151617# app├── packages│ ├── pkg1│ │ ├── package.json│ │ └── pnpm-lock.yaml│ ├── pkg2│ │ ├── package.json│ │ └── pnpm-lock.yaml│ ├── pkg3│ │ ├── package.json│ │ └── pnpm-lock.yaml│ └── app│ ├── package.json│ └── pnpm-lock.yaml├── package.json├── pnpm-lock.yaml└── pnpm-workspace.yaml 配置 pnpm-workspace.yaml，让 pnpm 知道都有哪些 workspace。 12345678# ./pnpm-workspace.yamlpackages: # root directory - &quot;.&quot; # all packages in subdirs of packages/ - &quot;packages/**&quot; # exclude packages that are inside test/ directories - &quot;!**/test/**&quot; # &#x27;!&#x27; means exclude 配置执行脚本，如执行某个包的 dev 指令，pnpm run –filter @package/app dev 批量执行命令，如对所有的包进行 lint：pnpm run –filter=&quot;@app/*&quot; lint 复用同仓库下的代码：假设 app 依赖于&#112;&#107;&#103;&#x31;&#64;&#x31;&#46;&#x35;&#46;&#48;和&#x70;&#x6b;&#103;&#x32;&#64;&#49;&#46;&#x35;&#46;&#x30;，而后两者均依赖于&#112;&#107;&#x67;&#x33;&#64;&#x31;&#x2e;&#53;&#x2e;&#48;。常规的做法是直接使用 npm 上的版本。但是如果想直接用当前正在开发中的&#x70;&#107;&#103;&#51;&#64;&#x31;&#46;&#x35;&#46;&#49;，而又还没有发布到 npm 上， 就很难办了。总不能 import xxx from “../../pacakge/pkc3/xxx”吧。这个时候 workspace 就派上了用场，可以这样给 pkg1 写依赖；在设置依赖版本的时候推荐用 workspace: *，就可以保持依赖的版本是工作空间里最新版本，不需要每次手动更新依赖版本。 123456// packages/pkg1/package.json&#123; &quot;dependencies&quot;: &#123; &quot;@laffery/pkg3&quot;: &quot;workspace:1.5.1&quot;, &#125;&#125; 5 TurborepoTurborepo 是一个为 monorepo 而生的极快的构建系统。目的是为了解决大型 monorepo 项目构建速度缓慢的一大痛点。turbo 的核心是永远不会重新构建已经构建过的内容。turbo 会把每次构建的产物与日志缓存起来，下次构建时只有文件发生变动的部分才会重新构建，没有变动的直接命中缓存并重现日志。turbo 拥有更智能的任务调度程序，充分利用空闲 CPU，使得整体构建速度更快。另外，turbo 还具有远程缓存功能，可以与团队和 CI/CD 共享构建缓存。 优势 增量构建：缓存构建内容，并跳过已经计算过的内容，通过增量构建来提高构建速度 内容 hash：通过文件内容计算出来的 hash 来判断文件是否需要进行构建 云缓存：可以和团队成员共享 CI/CD 的云构建缓存，来实现更快的构建 并行执行：在不浪费空闲 CPU 的情况下，以最大并行数量来进行构建 任务管道：通过定义任务之间的关系，让 Turborepo 优化构建的内容和时间 约定式配置：通过约定来降低配置的复杂度，只需要几行简单的 JSON 就能完成配置 turbo 通过「智能缓存」与「任务调度」，极大的提升了构建速度，节省了计算资源。并且 turbo 配置非常简单，侵入性小，可以渐进式的采用。相信未来 turbo 会成为 monorepo 工具链上的重要一环。 搭建项目 将 Turborepo 添加到项目最外层的 devDependecies 中，npm install turbo -D 在 package.json 中增加 Turborepo 的配置项 12345678910111213141516171819202122// package.json 将想要&quot;涡轮增压&quot;的命令添加到管道中 管道定义了 npm 包中 scripts 的依赖关系，// 并且为这些命令开启了缓存。这些命令的依赖关系和缓存设置会应用到 monorepo 中的各个包中&#123; &quot;turbo&quot;: &#123; &quot;pipeline&quot;: &#123; &quot;build&quot;: &#123; &quot;dependsOn&quot;: [&quot;^build&quot;], &quot;outputs&quot;: [&quot;.next/**&quot;] &#125;, &quot;test&quot;: &#123; &quot;dependsOn&quot;: [&quot;^build&quot;], &quot;outputs&quot;: [] &#125;, &quot;lint&quot;: &#123; &quot;outputs&quot;: [] &#125;, &quot;dev&quot;: &#123; &quot;cache&quot;: false &#125; &#125; &#125;&#125; build 和 test 这两个任务具有依赖性，必须要等他们的依赖项对应的任务完成后才能执行，所以这里用^来表示。 对于每个包中 package.json 中的 script 命令，如果没有配置覆盖项，那么 Turborepo 将缓存默认输出到 dist/** 和 build/**文件夹中。可以通过 outputs 数组来设置缓存的输出目录，示例中将缓存保存到.next/**文件夹中。Turborep 会自动将没个 script 的控制台 log 缓存到.turbo/turbo-.log 目录中，不需要自己手动去指定。 dev 这个任务通过 cache 设置为 false 来禁用这个命令的缓存功能。 6 参考资料npm link 的使用 【一库】yalc: 可能是最好的前端 link 调试方案（已经非常谦虚了） Yarn 命令 lerna 管理前端模块最佳实践 lerna 指令参考地址（汉化） Lerna 中文教程详解 Hard links and Symbolic links （硬链接 VS 符号链接） Linux 软连接和硬链接 都 2022 年了，pnpm 快到碗里来！ 将 pnpm 与 Lerna 结合使用 如何评价 turborepo 这个 Monorepos 解决方案？ https://juejin.cn/post/7048234698048274469#heading-5","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"npm","slug":"npm","permalink":"https://laputaz.github.io/home/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"https://laputaz.github.io/home/tags/yarn/"},{"name":"包管理","slug":"包管理","permalink":"https://laputaz.github.io/home/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"回顾-admin项目梳理","slug":"回顾-admin项目梳理","date":"2021-07-18T10:13:05.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"回顾-admin项目梳理/","link":"","permalink":"https://laputaz.github.io/home/%E5%9B%9E%E9%A1%BE-admin%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86/","excerpt":"旧的 admin 项目结构梳理","text":"旧的 admin 项目结构梳理 项目梳理admin 团队由于业务需要或者职能的转变, 项目经历过几次更迭 old admin 成立以来一直到现在的古老 admin 系统 new admin 新的 admin 系统 mspa 更加独立的 admin 系统 low code 提供高复用方案 old admin 目录结构及运行流程梳理old admin 技术栈老旧且庞大混杂, 包含了node层(koa) / handlebars / jquery / element-ui 1.x / bootstrap / gulp 混杂 webpack 这里不会写出所有的细节, 类似于 koa-compress / koa-proxy / koa-router 等不会列举出来, 只写出最主要的流程 代码处理 使用 gulp + webpack 开始编译代码 12gulp dev # for dev hmrgulp build # for prod dev / build 命令在 gulpfile.js 文件中定义的, 其中 gulp 会启动 webpack 处理文件 1234567891011121314gulp.task( &#x27;dev&#x27;, [ &#x27;conf_gen&#x27;, // 生成 config 环境url配置 &#x27;js:locales&#x27;, // 处理多语言文件 &#x27;css&#x27;, // 处理css ], function () &#123; // ... // ... gulp.start(&#x27;webpack:js:dev&#x27;); // 启动 webpack // ... &#125;); 主要的 webpack 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// webpack.config.js// git-revision-webpack-plugin 在代码中注入当前的 commit 信息module.exports = &#123; entry: &#123; index: &#123;&#125;, // 登录, 新的mspa storage: &#123; // 每个模块的入口 storage_add: [&#x27;pages/storage/storage_add.js&#x27;], // ... &#125;, setting: &#123;&#125;, act: &#123;&#125;, credit_mgt: &#123; credit_mgt: [&#x27;pages/credit-mgt/main.js&#x27;], &#125;, // ... &#125;, output: &#123; chunkFilename: &#x27;js/[name].[chunkhash].js&#x27;, filename: &#x27;js/[name].bundle.js&#x27;, publicPath: get_public_path_desktop(), path: __dirname + &#x27;/s/dist/desktop/&#x27;, // 打包到 s/dist 目录下 // /s/dist/desktop/ dev // //admin.klook.com/s/dist/desktop/ prod &#125;, module: &#123;&#125;, // 处理 vue / scss / md 等文件的 load resolve: &#123; alias: &#123; // 一些路径的别名 src: &#x27;web/s/src&#x27;, desktop: &#x27;src/desktop&#x27;, &#125;, &#125;, plugins: [ // 插件 new webpack.ProvidePlugin(&#123; $: &#x27;jquery&#x27;, // 注入一些全局变量 ADMIN_API: &#x27;admin_api&#x27;, &#125;), ], optimization: &#123; vendors: &#123; // extract 3-party modules for better cache name: &#x27;vendors&#x27;, filename: &#x27;js/vendors.bundle.js&#x27;, &#125;, iview: &#123; // iview here name: &#x27;iview&#x27;, filename: &#x27;js/iview.bundle.js&#x27;, &#125;, commons: &#123; // 其他的文件 name: &#x27;commons&#x27;, filename: &#x27;js/commons.bundle.js&#x27;, chunks: &#x27;initial&#x27;, // minChunks: 10, &#125;, &#125;, // 分chunk&#125;; 运行 dev 时以 app.js 为入口启动 node 服务 1node app.js --port=1122 # --harmony flag 可以让旧版本的 node 支持 es6 app.js 中的流程 123456789101112131415var compress = require(&#x27;koa-compress&#x27;); // gzip压缩var logger = require(&#x27;koa-logger&#x27;); // 打印请求var koa = require(&#x27;koa&#x27;); // koavar proxy = require(&#x27;koa-proxy&#x27;); // 请求代理转发var web_all_init = require(&#x27;./handlers/web_all.js&#x27;).init; // 入口方法// koa 实例var app = (module.exports = koa());// 初始化web_all_init(app);// 获取 --port=1122 端口参数var port = argv.p || argv.port || 1122;app.listen(port); web_all.js 中的流程 12345678910111213141516171819202122var nav_config = require(&quot;./nav_config.js&quot;).nav_config; // 菜单栏设置var koa_hbs = require(&quot;koa-hbs&quot;); // handle-bars 处理插件// 入口function init(app, opt) &#123; // 静态资源路径 opt.static_root = opt.static_root || path.join(webroot, &quot;s/dist&quot;); // ... // ... // 路由, 匹配 mobile.js desktop.js 中配置的路由 app.use(create_web_all(mobile_handler, desktop_handler)); // _render this._render = function(tpl, locales) &#123; // ... // ... // 注入一些全局变量到 window 下 _session: &#123;&#125;, _permission: &#123;&#125;, this.render(tpl, locals); &#125;&#125; desktop.js 中间件中的流程 123456789101112131415// 匹配路径, 渲染相应的html文件router.get( [&#x27;/api/partner_new_version&#x27;, &#x27;/api/new_partner&#x27;], web_comm.auth_klk, // 公共鉴权 web_comm.auth_klk_roles( // 角色鉴权 `$&#123;role_map[&#x27;API&#x27;][&#x27;API-PARTNER-BROWSE&#x27;]&#125;` ), function* () &#123; // 返回渲染页面 yield this._render(&#x27;pages/api/index&#x27;, &#123; title: &#x27;api&#x27;, &#125;); &#125;); 在返回的 html 中, 会用 hbs 手动写入引入的 js 文件, 以 3 中的 pages/api/index 为例 1234567891011121314151617181920212223&#123;&#123;!&lt; layout &#125;&#125;&lt;!-- 标题 --&gt;&#123;&#123;#contentFor &quot;title&quot;&#125;&#125;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&#123;&#123;/contentFor&#125;&#125;&lt;!-- 主内容 --&gt;&#123;&#123;#contentFor &#x27;main-content&#x27;&#125;&#125; &#123;&#123;&#123;&#123;raw-helper&#125;&#125;&#125;&#125;&lt;div id=&quot;app&quot;&gt; &#123;&#123;#if (eq extra_info [])&#125;&#125; &lt;div&gt;&lt;/div&gt; &#123;&#123;#else&#125;&#125; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &#123;&#123;/contentFor&#125;&#125; &lt;!-- handlebars mustache 语法 引入script --&gt; &#123;&#123;#contentFor &quot;script_self&quot;&#125;&#125; &lt;script src=&quot;&#123;&#123;s &#x27;/s/dist/desktop/js/api_index.bundle.js&#x27;&#125;&#125;&quot;&gt;&lt;/script&gt; &#123;&#123;/contentFor&#125;&#125; &lt;/div&gt;&lt;/div&gt; 如果是新的 vue spa 流程, 会以 “pages/admin_spa” 为统一入口 1234&lt;div id=&quot;app&quot; /&gt;&#123;&#123;#contentFor &quot;script_self&quot;&#125;&#125;&lt;script src=&quot;&#123;&#123;s &#x27;/s/dist/desktop/js/admin_spa.bundle.js&#x27;&#125;&#125;&quot;&gt;&lt;/script&gt;&#123;&#123;/contentFor&#125;&#125; 其中 bundle : /s/dist/desktop/js/admin_spa.bundle.js 的打包入口在 webpack 的 entry 中指定, 为 admin_spa.js (main.js) 123456// admin_spa.js 中正常地初始化 vue spa 即可new Vue(&#123; store, router, el: &#x27;#app&#x27;,&#125;); 每个模块, 如库存/商户/活动/财务, 都将是独立的 spa 部署123# deploy.shgulp buildpm2 start app.js new admin 目录结构这个工程没什么好说, 基于 vue-admin-template 目录结构, 其他业务线, 只要在 modules 下新增自己的模块就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129- build —— 项目构建文件目录 - index.js —— 入口文件- conf —— 项目配置目录- dist —— 项目打包输出目录- docs —— 文档目录- mock —— mock 服务目录- node_modules —— npm 包目录- public —— 公共文件目录- src —— 开发源文件目录 - modules —— 业务模块 - demo —— demo 模块，展示所有如 业务模版、全局组件 等的效果**_（optional）_** - layouts - list - list_1.vue - list\\_[num].vue - [business_name] - components - [component_name] - index.vue - [module_name] (Top-level) —— 一级业务模块 - **\\_**************\\*\\*\\*****************\\_\\*\\* - **_⬇️⬇️⬇️ 开发人员关注 ⬇️⬇️⬇️_** - modules **_(optional)_** - [module_name] (Second-level) —— 二级业务模块 - modules - [module_name] (More-level) —— 更多级业务模块 - (其余同 Top-level 目录)…… - routes —— 路由 - index.js —— 入口文件 - components —— 组件（处于一级模块目录下时，对于一级模块目录下所有子模块来说，是全局组件目录；处于其它层级模块目录下时，为其所在模块的局部组件目录。）**_（optional）_** - [component_name] —— 任一组件目录 - index.vue —— 任一组件入口文件 - index.css/scss/...... —— 任一组件样式文件 - templates —— 模板**_（optional）_** - index.html - pages —— 业务页面 - [page_name].vue - styles —— 样式**_（optional）_** - [page_name].css/scss/...... —— vue 对应样式文件 - images —— 图片**_（optional）_** - [image_name].jpg/jpeg/png/...... - store —— 状态管理(vuex)**_（optional）_** - index.js —— 入口文件 - getters.js —— getter 定义文件 - mutation-consts.js —— mutation 方法常量文件 - api —— 接口实例**_（optional）_** - index.js —— 入口文件 - api_url.js —— 接口路径文件 - utils —— 工具函数**_（optional）_** - index.js —— 入口文件 - conf —— 模块配置**_（optional）_** - index.js —— 入口文件 - .eslintignore —— eslint 忽略文件（局部）**_（optional）_** - .eslintrc.js —— eslint 配置文件（局部）**_（optional）_** - **_⬆️⬆️⬆️ 开发人员关注 ⬆️⬆️⬆️_** - **\\_**************\\*\\*\\*****************\\_\\*\\* - assets —— 全局资源 - styles —— 样式 - [style_name].css/scss/...... - images —— 图片 - [image_name].jpg/jpeg/png/...... - fonts —— 字体 - [font_name].eot/ttf/woff/woff2/svg/...... - components —— 全局组件 - [component_name] —— 任一全局组件目录 - index.vue —— 任一全局组件入口文件 - index.css/scss/...... —— 任一全局组件样式文件 - index.js 入口文件 - conf —— 开发相关配置 - index.js —— 入口文件 - const.js —— 全局常量定义文件 - …… - icons —— 图标文件目录（svg） - layouts —— 业务模版 - components —— 组件目录 - [business_name] —— 任一业务模版目录 - index.vue —— 入口文件 - pages —— \b 默认提供页面 - 404.vue - root.vue - router —— 全局路由 - index.js —— 入口文件 - services —— 服务 - api —— 接口服务 - index.js —— 入口文件 - axios.js —— axios 实例封装文件（interceptors 开发等） - lang —— 多语言 - index.js —— 入口文件 - [lang].js —— 多语言文案文件 - store —— 全局状态管理(vuex) - modules —— 模块目录 - index.js —— 入口文件 - getters.js —— getter 定义文件 - mutation-consts.js —— mutation 方法常量文件 - styles —— 全局样式目录 - utils —— 工具函数目录 - index.js —— 入口文件 - [util_module_name].js —— 任一工具函数模块入口文件 - App.vue —— \b 应用入口 vue 文件 - main.js —— 应用入口 js 文件 - permission.js —— 权限控制文件- static —— 静态文件目录 **_(optional)_**- tests —— 项目测试目录- ********\\*\\********* 我是分割线 ********\\*\\*********- .commitlintrc.js —— commitlint 配置文件- .editorconfig —— IDE 代码风格配置文件- .env.development —— 环境脚本文件- .env.production —— 环境脚本文件- .env.staging —— 环境脚本文件- .eslintignore —— eslint 忽略文件（全局）- .eslintrc.js —— eslint 配置文件（全局）- .gitignore —— git 忽略文件- .jsdoc.json —— jsdoc 配置文件- .travis.yml —— Travis CI 文件- babel.config.js —— babel 配置文件- jest.config.js —— jest 单元测试配置文件- package.json- postcss.config.js —— postcss 配置文件- README.md- tsconfig.json —— typescript 配置文件- vue.config.js —— vue-cli 配置文件- …… 部署, 产线运行目录下的 deploy.sh 即可, deploy.sh包含 checkout/install/build命令 (该项目依赖于 old admin 提供的 node 服务) mspa (multi single page)由于 new admin 也集成了各个业务线的代码, 越来越难于维护 并且 admin 团队后续将偏向于成为提供基础能力的团队, 业务开发将分散到各个vertical团队 (各个垂直业务团队, 如租车, hotel, airport transfer, ttd 等等) 于是提供 mspa 的开发模式. admin 团队提供以下能力: 123456789admin-cli # vue 项目脚手架 - 类 @vue/cliadmin-cli-service # 项目脚手架工具 - 类 @vue/cli-serviceadmin-ui # ui 组件库admin-utils # 常用工具函数库admin-login # 提供 google 登录功能admin-permission # 提供 admin 权限验证admin-layout # 提供统一的布局........ 各个业务团队使用 admin-cli 以及相关的库自行搭建项目 使用 node 编写接口, 在部署时, 上传每个 app 的 router, 集成展示 由于大家都是独立工程, 有需要可以自行部署至单独域名 统一托管到aws的cdn上 low code由于 admin 开发, 会出现大量的重复工作, 例如表单+表格的页面模式, 在 admin 占比非常大 于是使用业界方案 sula 或者 baidu/amis , 提供 low code 方案 该方案仅限于普通的通过配置生成界面, 希望做到更高的可拓展性和可拔插性 持续中","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}]},{"title":"实现：组件封装和高阶组件-弹窗","slug":"实现-组件封装和高阶组件-弹窗封装","date":"2021-05-22T16:59:48.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"实现-组件封装和高阶组件-弹窗封装/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E5%92%8C%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E5%BC%B9%E7%AA%97%E5%B0%81%E8%A3%85/","excerpt":"最近看的组件封装和高阶组件的相关概念，做一下简单的总结。","text":"最近看的组件封装和高阶组件的相关概念，做一下简单的总结。 高阶组件是什么在说高阶组件之前，有一个概念是高阶函数。简单地说，高阶函数也就是传入一个函数，最后返回一个新函数。那么高阶组件，就是函数接收一个组件，返回新的组件，并对组件做一层包装拓展。在 vue 中，vue 单文件会被转换为对象，template 部分会被转换为对象中的 render 函数。所以思路就是对该对象进行一些处理。有点像装饰器模式。 恶心的弹窗组件每次在写 admin 页面的时候，总是会出现这样的代码，以 elementUI 为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;el-dialog :visible.sync=&quot;visible1&quot; :title=&quot;title1&quot;&gt; &lt;my-com /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog :visible.sync=&quot;visible2&quot; :title=&quot;title2&quot;&gt; &lt;my-com /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog :visible.sync=&quot;visible3&quot; :title=&quot;title3&quot;&gt; &lt;my-com /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog :visible.sync=&quot;visible4&quot; :title=&quot;title4&quot;&gt; &lt;my-com /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; // 我的组件，展示在弹窗内部 import MyCom from &#x27;my-com&#x27; export default &#123; data() &#123; return &#123; // 控制显示隐藏 visible1: false, visible2: false, visible3: false, visible4: false, // 标题 title1： &#x27;title1&#x27;, title2： &#x27;title2&#x27;, title3： &#x27;title3&#x27;, title4： &#x27;title4&#x27; &#125; &#125;, &#125;&lt;/script&gt; 这样写非常重复，并且在状态很多的时候，管理起来会很恶心。 visible，title 这一类变量，其实属于弹窗自身的内部属性，如果在代码的其他地方没有使用，那么最好是隐藏在弹窗组件中，没必要暴露出来。 我们希望只关心弹窗内部的组件部分（my-com），而不是每次都做一些繁复的无用的代码拷贝。 组件封装常见的做法，是将弹窗再封装一层，将 my-com 作为插槽的内容。如: my-dialog.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;el-dialog :visible.sync=&quot;visible&quot;&gt; &lt;slot /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; // 我的组件，展示在弹窗内部 import MyCom from &#x27;my-com&#x27; export default &#123; props: [&#x27;visible&#x27;], data() &#123; return &#123; visible: true, &#125; &#125;, methods: [ open() &#123; this.visible = true &#125; ], &#125;&lt;/script&gt; 使用： 1234567891011&lt;template&gt; &lt;my-dialog ref=&quot;dialog&quot;&gt; &lt;my-com&gt; &lt;/my-dialog&gt;&lt;/template&gt;&lt;script&gt; import MyCom from &#x27;my-com&#x27; export default &#123; components: &#123; MyCom &#125; &#125;&lt;/script&gt; 这时有一个问题，el-dialog 被我们包含在组件内部了，如果要为其添加一些属性怎么办，例如前面的 title。 一种方法是增加 props my-dialog.vue 123456789101112131415&lt;template&gt; &lt;!-- 增加 title --&gt; &lt;el-dialog :visible.sync=&quot;visible&quot; :title=&quot;title&quot;&gt; &lt;slot /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 增加 title props: [&#x27;visible&#x27;, &#x27;title&#x27;], &#125;&lt;/script&gt; 缺点是灵活性较差，每新增一个属性就需要改一次组件、增加一个 prop。 更好的办法是使用 $attrs、$props、$listener 等。其中： $attrs 包含了 dom 上所有属性 $props 包含了已经在 props 上声明的属性 $listeners 包含了所有事件属性 my-dialog.vue 123456789101112131415&lt;template&gt; &lt;!-- 增加 title --&gt; &lt;el-dialog :visible.sync=&quot;visible&quot; v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt; &lt;slot /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 增加 title props: [&#x27;visible&#x27;], &#125;&lt;/script&gt; 如果不想把从父组件传递的参数或事件全都传递给原组件，需要做部分筛选，可以使用计算属性 computed： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;!-- 增加 title --&gt; &lt;el-dialog :visible.sync=&quot;visible&quot; v-bind=&quot;dialogAttr&quot; v-on=&quot;dialogListeners&quot;&gt; &lt;slot /&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;el-button&gt;Confirm&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 增加 title props: [&#x27;visible&#x27;], computed: &#123; dialogProps() &#123; // 只取 title 绑定到 el-dialog const &#123; title &#125; = this.$attrs return &#123; title, &#125; &#125;, dialogListeners() &#123; // 只取 close 事件绑定到 el-dialog const &#123; close &#125; = this.$listeners return &#123; close, &#125; &#125;, &#125;, &#125;&lt;/script&gt; 但还有一种使用场景，我们希望使用起来更加简洁，类似于 elementUI 的 this.$confirm。如果没有 elementUI, 或者项目中已经有一个实现好的弹窗了，这种情况怎么基于现有组件，实现类似于 this.$confirm 的调用呢。 基于现有弹窗实现 this.$dialog这种实现形式称为 HOC 高阶组件。假设我们已经有一个弹窗组件（用 elementUI 的 el-dialog 为例）。 首先，引入弹窗组件。 123// ? !多个实例需要销毁import &#123; Button as ElButton, Dialog as ElDialog &#125; from &#x27;element-ui&#x27;import Vue from &#x27;vue&#x27; 定义弹窗的几种状态，确定，关闭，和取消。 123456789// 实例let instancelet promise// 每种操作对应的结果const statusMap = &#123; confirm: &#x27;resolve&#x27;, close: &#x27;reject&#x27;, cancel: &#x27;reject&#x27;,&#125; 定义一个方法，这个方法接收两个参数： 一是弹窗组件 二是额外配置项 该方法接收弹窗组件，并在其基础上，包裹了一层，添加了新的方法，如 open,cancel 等等。 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 接受一个组件和配置const hoc = function (com, options) &#123; return &#123; name: &#x27;MyDialog&#x27;, // 声明子组件 components: &#123; com &#125;, // 显示隐藏 data() &#123; return &#123; visible: false, loading: false &#125; &#125;, methods: &#123; // 打开 ref open() &#123; this.visible = true &#125;, // 关闭 ref close() &#123; this.visible = false promise &amp;&amp; promise.reject() &#125;, // handler 类 confirm handler() &#123; this.visible = true return new Promise((resolve, reject) =&gt; (promise = &#123; resolve, reject &#125;)) &#125;, // 处理 确认 or 取消 _action(type, beforeAction) &#123; // type === &#x27;confirm&#x27; &amp;&amp; (this.loading = true) const done = () =&gt; &#123; this._hide(type) &#125; // 如果有 before-close | before-confirm, 先执行, 并且必须在方法中调用 done if (typeof beforeAction === &#x27;function&#x27;) &#123; beforeAction(done) &#125; else &#123; done() &#125; &#125;, // 关闭弹窗 _hide(type) &#123; this.visible = false this.loading = false if (promise) &#123; promise[statusMap[type]](this.$refs.child) return &#125; // 触发事件 this.$emit(type) &#125;, &#125;, // 渲染函数 render() &#123; // ... &#125;&#125; 由于我们没办法在 js 中写 template 标签，这个时候 render 函数就派上用场了。（也可以用 JSX） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 接受一个组件和配置const hoc = function (com, options) &#123; return &#123; name: &#x27;MyDialog&#x27;, // 声明子组件 components: &#123; com &#125;, // ... // ... // ... // ... // 渲染函数 render(h) &#123; const _this = this // props const args = &#123; props: &#123; ...(options || &#123;&#125;), ...this.$attrs, visible: this.visible, &#125;, on: &#123; ...this.$listeners, &#x27;update:visible&#x27;: (val) =&gt; (_this.visible = val), // visible.sync &#125;, scopedSlots: this.$scopedSlots, ref: &#x27;dialog&#x27;, &#125; // footer const footer = h(&#x27;div&#x27;, &#123; slot: &#x27;footer&#x27; &#125;, [ h( ElButton, &#123; on: &#123; click: () =&gt; _this._action(&#x27;cancel&#x27;, args.props[&#x27;before-cancel&#x27;]), &#125;, &#125;, &#x27;Cancel&#x27; ), h( ElButton, &#123; props: &#123; type: &#x27;primary&#x27;, loading: _this.loading, &#125;, on: &#123; click: () =&gt; _this._action(&#x27;confirm&#x27;, args.props[&#x27;before-confirm&#x27;]), &#125;, &#125;, &#x27;Confirm&#x27; ), ]) return h(ElDialog, args, [ h(com, &#123; props: options?.props, ref: &#x27;child&#x27;, &#125;), footer, ]) &#125;, &#125;&#125; 挂载方法，将生成的弹窗挂载到指定的位置，如果没有指定位置，将插入到 body 中。 其中 Vue.extend 方法，会接受一个组件，并返回该组件的构造器。 12345678910111213141516171819202122// 用于挂载const dialogService = function (com, options) &#123; // 如果传入了 props const DialogConstructor = Vue.extend(hoc.call(this, com, options)) // 新实例 instance = new DialogConstructor() // 选择挂载的目标 =&gt; dom or body let target = document.body // 如果是选择器 if (typeof options.el === &#x27;string&#x27;) &#123; target = document.querySelector(options.el) || target &#125; // 如果是 dom if (options.el instanceof HTMLElement) &#123; target = options.el &#125; // 挂载 instance.$mount() target.appendChild(instance.$el) instance.visible = true return instance&#125; 这里提供两种输出， 一是 MyDialog 组件实例， 二是 $dialog 方法。 1234567891011121314151617181920// dialog 服务const $dialog = function (component, options = &#123;&#125;) &#123; return dialogService.call(this, component, options)&#125;// confirm 方法$dialog.confirm = function (component, options = &#123;&#125;) &#123; return $dialog(component, options).handler()&#125;// componentsconst MyDialog = hoc()/** * ? export what * 1. 直接可用的 component * 2. 生成 component 的函数 * 3. $dialog */export &#123; $dialog, MyDialog &#125; 最后，提供一个 install 方法，方便用 Vue.use() 安装到全局 Vue 的原型上。 1234567//! 使用方式: $dialog 使用需要挂载到 Vue 实例, 以获取 thisexport default &#123; // for register install(Vue) &#123; Vue.prototype.$dialog = $dialog &#125;,&#125; 这样，就可以直接调用 this.$dialog，而不需要在模板中写新元素了。","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://laputaz.github.io/home/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}]},{"title":"俄语笔记(一)：俄语字母和基础语法","slug":"俄语笔记-俄语字母和基础语法","date":"2021-04-20T21:42:20.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"俄语笔记-俄语字母和基础语法/","link":"","permalink":"https://laputaz.github.io/home/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0-%E4%BF%84%E8%AF%AD%E5%AD%97%E6%AF%8D%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"俄语字母（русский алфавит）是西里尔字母的变体，用以表达俄语的元音和辅音。 先洗洗脑 Вечер бродит Кали́нка - 卡林卡（雪花球） 字母表简单写了一个网站，可以看到所有俄语中使用的西里尔字母： https://laputaz.github.io/rrrussian-alphabet/ 俄语字母 俄语一共有 33 个字母 字母表。 大写：а б в г д е ё ж з и й к л м н о п р с т у ф х ц ч ш щ ъ ы ь э ю я 小写：а б в г д е ё ж з и й к л м н о п р с т у ф х ц ч ш щ ъ ы ь э ю я 就着字母歌，听听看 有 10 个元音字母（注意，й 不是元音，拼读时读作/j/，和英语中 yes /jes/的 y 拼读音一样）： а е ё и о у ы э ю я 虽然有 10 个元音字母，但实际元音还是 6 个。 а o у э и ы 剩余 4 个元音字母是和 й 拼写出来的 а-я(йа) о-ё(йо) у-ю(йу) э-е(йэ) 21 个辅音字母 б в г д ж з й к л м н п р с т ф х ц ч ш щ 其中，有 6 组成对的清浊辅音 п-б т-д к-г с-з ф-в ш-ж 9 个不成对的清浊辅音 й л м н р х ц ч щ 2 个无音符号（不发音，本身的作用是隔音）： ъ ь 复习一些基础概念这里的概念跟英语是一样样的: 清浊辅音 清浊辅音的区别在于，声带是否振动 音节 一个音节一定包含一个元音。 一个元音可以单独是一个音节，也可以与一个或几个辅音构成音节。 一个单词有几个元音，就有几个音节。 重音 使一个音节读长音，一个单词只有一个重音。 俄语语法 - 拼读规律 元音 а о 的弱化 非重读音节，弱化成 /ʌ/，例如： она =&gt; /ʌ/наЗто мама =&gt; Зт/ʌ/ мама 浊辅音清化 / 清辅音浊化 （仅适用于成对的清浊辅音） 浊辅音在词尾，需要清化。 аб =&gt; ап ав =&gt; аф ад =&gt; ат аз =&gt; ас аг =&gt; ак аж =&gt; аш 清辅音前的浊辅音发成清辅音（后者为准原则） ав(ф)тобус 公共汽车останов(ф)ка 停止 浊辅音前的清辅音发成浊辅音（后者为准原则） фут(д)бол 足球баскет(д)бол 篮球вок(г)зал 火车站 但是，有例外，在以下浊辅音前，清辅音不需要浊化。 м н л в р （美女李芙蓉） 软辅音和硬辅音 硬辅音：当辅音字母和 а o у э ы 相拼 软辅音：当辅音字母和 я ё ю е и 相拼（简单而言，和 й 相拼） 永远的硬辅音：ж ш ц (记：ж、ц 和 й 相拼会很奇怪，而 ш 如果和 й 相拼就变成 щ 了) 永远的软辅音：ч щ (记：他们本身就带了 й 音) 元音 я е 的弱化非重读音节时，读成介于 и е 之间的音。如： е(ие)да 食物ве(ие)сна 春天че(ие)ловек 小伙子я(ие)зык 语言ме(ие)ста 地点пя(ие)ти 五 г 的特殊读音 ого、его 中，发成 в 音 старог(в)о 旧的ег(в)о 他的 在少数单词中， г 会读成 х 的音 мяг(х)кий 柔软 前置词，前置词要和后面的单词连读 в на，表示在…里面、去哪里 в России =&gt; 在俄罗斯на почту =&gt; 去邮局 辅音连缀，都读出来就对了，中间不要穿插元音。 ктобуква 辅音连缀 тс дс 读成 ц （тц дц 也读成 ц） городс(ц)кой 城市的детс(ц)кий 儿童的учитс(ц)я 学习 辅音连缀 стл стн здн 中的 т д 不发音 счастливый 幸福的，快乐的известный 有名的праздник 节日 辅音连缀 сч 读作 щ счастливый 幸福的，快乐的 辅音连缀 сж зж сш зш 读成 ж ш расшифровка 解密 非重读音节 е 在 ж ш ц 弱化成 ы （и 好像也是） же(ы)на 妻子ше(ы)стой 第六 ъ ь 无音符号的作用 ъ 之前的辅音读成硬辅音，除非永软 бя - бъя 后者分开读 б 读成硬辅音 ь 之前的辅音读成软辅音，除非永硬 бя - бья 后者分开读 б 读成软辅音，与 бя 相比有一点间隔 俄语语法 - 词性 形容词词尾有阴性阳性中性和复数 俄语语法 - 变格俄语中一共有六个格位，与中文不一样，俄语语序可以交换。 包括单复数六格：主格（1 格）、属格（2 格）、与格（3 格）、宾格（4 格）、工具格（5 格）和前置格（6 格）。 太多了，补充中。。。","categories":[],"tags":[{"name":"俄语笔记","slug":"俄语笔记","permalink":"https://laputaz.github.io/home/tags/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0/"}]},{"title":"实现：websocket 在项目中的使用-订单锁定","slug":"实现-websocket在项目中的使用","date":"2021-03-12T13:35:28.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"实现-websocket在项目中的使用/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-websocket%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"从前在订单模块用到了 websocket，记录一下。","text":"从前在订单模块用到了 websocket，记录一下。 场景admin 订单详情模块存在一个页面，叫做 fraud order list。也就是退款订单页面。 大概长这样： 点击操作按钮会出现弹窗的表单， 填写完保存: 问题： 页面不是只有一个人在操作的，同一段时间内，如果有不同的人打开弹窗，巴拉巴拉填完，后面保存的操作会覆盖前面保存的操作。 解决方案websocket 是在这个场景就是一个很好的解决方法。 首先，在订单的操作栏增加一个 lock 按钮：当我要编辑这笔订单时，点击 lock 按钮，通知到服务端。 服务端接受到消息，将订单锁定的状态存储起来。 再推送到所有客户端浏览器，让这个订单变成已锁定，隐藏所有按钮，不能再编辑。 这样，一个订单，在同一个时间段内，只能有一个人在处理。 实现客户端部分代码。用 vue 编写。这里用了一个 reconnecting-websocket 库，他封装了原生的 websocket，并且可以实现断开后自动重连。（有一些场景，例如网络断开一段时间，或者 node 服务需要重新发布，或者挂掉重启，这个时候是需要重新连接的。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;!-- 订单列表 --&gt; &lt;div v-for=&quot;order in orderList&quot;&gt; &lt;!-- 点击后锁定 --&gt; &lt;el-button @click=&quot;lockOrder&quot; /&gt; &lt;!-- 其他按钮, 如果是锁定的，则不展示 --&gt; &lt;el-button @click=&quot;edit&quot; v-if=&quot;all_lock_data.includes(order)&quot;&gt; 操作 &lt;/el-button&gt; &lt;el-dialog&gt; &lt;!-- 保存，这时解锁订单 --&gt; &lt;el-button @click=&quot;save() &amp;&amp; unlockOrder()&quot; /&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入 import ReconnectingWebSocket from &#x27;reconnecting-websocket&#x27; export default &#123; methods: &#123; // 初始化 initWebsocket() &#123; // 连接接口 const socket = new ReconnectingWebSocket(&#x27;/websocket/lock_fruad_order&#x27;) this.socket = socket // 建立连接 socket.onopen = function (event) &#123; console.info(&#x27;websocket connection established&#x27;) &#125; /** * data 格式 * [ * order_id: 订单编号 * is_locked: 是否锁定 * account_name: 操作人 * ] */ this.socket.onmessage = function (event) &#123; let data = JSON.parse(event.data) // 记录lock的数据 $vm.all_lock_data = data &#125; // 关闭 this.socket.onclose = function (event) &#123; console.error(&#x27;[close] Connection died&#x27;) &#125; // 出错 this.socket.onerror = function (error) &#123; console.error(`[error] $&#123;error.message&#125;`) &#125; &#125;, // 点击锁定 lockOrder(order) &#123; const data = JSON.stringify([ isLock: true, order_number: order.order_number, account_name: window.KLK_PAGE_DATA._session.account.account_name ]); this.socket.send(data); &#125;, // 保存后取消锁定 unlockOrder(order) &#123; const data = JSON.stringify([ isLock: false, order_number: order.order_number, account_name: window.KLK_PAGE_DATA._session.account.account_name ]); this.socket.send(data); &#125; &#125;, created() &#123; // 初始化 this.initWebsocket() &#125;, &#125;&lt;/script&gt; 上面就是客户端的写法，比较简单，再看看服务端。服务端用的是 koa。为了防止服务崩溃，发布或者重启，这里将锁定的订单都存在 redis 持久化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const Koa = require(&#x27;koa&#x27;)const websockify = require(&#x27;koa-websocket&#x27;)const KoaRouter = require(&#x27;koa-router&#x27;)const redis = require(&#x27;redis&#x27;)const app = new Koa()const router = KoaRouter()const rds = redis.createClient()// 使koa实例支持 websocketapp = websockify(app)// redis的对应的数据key prefixconst RDS_PREFIX = &#x27;fruad_order_lock:&#x27;// 定义一个方法，用于广播function broadcastAllData($ws) &#123; // 根据 key prefix 找到所有数据 rds.keys(`$&#123;RDS_PREFIX&#125;*`, (err, res) =&gt; &#123; if (err) &#123; console.log(err) &#125; let keys = res if (keys &amp;&amp; keys.length) &#123; rds.mget(keys, function (err, res) &#123; if (err) &#123; console.log(err) &#125; let values = res let data = keys.reduce( (acc, key, index) =&gt; (&#123; ...acc, [key.replace(RDS_PREFIX, &#x27;&#x27;)]: values[index], &#125;), &#123;&#125; ) // 广播 $ws.broadcast(JSON.stringify(data)) &#125;) &#125; else &#123; // 未找到，广播 $ws.broadcast(JSON.stringify(&#123;&#125;)) &#125; &#125;)&#125;// 当收到客户端链接router.get( &#x27;/websocket/lock_fruad_order&#x27;, function* (next) &#123; // 做一些鉴权的操作，比如登录失效了，则不允许处理 let has_auth = yield web_comm.has_auth.call(this) // 根据 this 上下文中的 cookie，判断登陆态 if (!has_auth) &#123; // 未登录，直接断开 this.websocket.close(1003, &#x27;Auth Error&#x27;) return &#125; else &#123; // 否则下一步 yield next &#125; &#125;, // 下一个中间件 function* (next) &#123; let $ws = this.websocket // 收到 lock message $ws.on(&#x27;message&#x27;, function (message) &#123; // print message from the client let [isLock, order_number, name] = JSON.parse(message) let KEY = `$&#123;RDS_PREFIX&#125;$&#123;order_number&#125;` let updateHandler = function (err, res) &#123; if (err) &#123; console.log(err) &#125; broadcastAllData($ws) &#125; // 将数据存到 redis if (isLock) &#123; rds.setex(KEY, 10 * 60, name, updateHandler) &#125; else &#123; // 解除锁定时，删除 key rds.del(KEY, updateHandler) &#125; &#125;) // send a message to our client broadcastAllData($ws) // yielding `next` will pass the context (this) on to the next ws middleware yield next &#125;)app.use(router.routes()) 以上。","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"实现","slug":"实现","permalink":"https://laputaz.github.io/home/tags/%E5%AE%9E%E7%8E%B0/"},{"name":"websocket","slug":"websocket","permalink":"https://laputaz.github.io/home/tags/websocket/"}]},{"title":"俄语笔记(三)：如何拥有斯拉夫口音的英语","slug":"俄语笔记-如何拥有斯拉夫口音的英文","date":"2021-02-25T10:31:51.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"俄语笔记-如何拥有斯拉夫口音的英文/","link":"","permalink":"https://laputaz.github.io/home/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0-%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E6%96%AF%E6%8B%89%E5%A4%AB%E5%8F%A3%E9%9F%B3%E7%9A%84%E8%8B%B1%E6%96%87/","excerpt":"俄罗斯口音说英语很有意思，加上最近关注了个俄罗斯 up 主叫鲍里斯。总结一波。","text":"俄罗斯口音说英语很有意思，加上最近关注了个俄罗斯 up 主叫鲍里斯。总结一波。 先洗脑鲍里斯是 youtube 上的一个俄罗斯 up 主，操一口纯正的斯拉夫英语。 规律 H 疯狂用喉咙，吐痰音 12H(吐痰)ello，my friend.H(吐痰)ow are you doing? L 时疯狂内卷舌头，但不是弹舌 1lol(卷舌)lipop R 疯狂弹舌 rrrrr(ррррр) ，例如: 12fr(ррррр)iend 朋友comr(ррррр)ade 同志 T K 用爆破音 д/d/ г/g/ 12Mother t(д)old me to lay the t(д)able for br(ррррр)eakfast. -&gt; T =&gt; д /d/you will c(г)ome to no harm. -&gt; K =&gt; г /g/ W 念成俄语 В (/v/)，其实相当于国人把 玩（wan）儿(er) 说成了 玩（va）儿 (er) 1w(в/v/)ater /ou/ 发成 /uo/ 或者 /o/。 英语里面的 o， 有时候发音更像 /ou/，例如 o/ou/cean（海）。 俄语里面更偏向原生的 /o/，但是拼写起来会写成 /uo/， 如 хорошо（好）=&gt; шо /shuo/ 或者 /sho/ 12no /nuo/ no /nuo/ no /nuo/不 不 不 TH 念成 Z 12345This is the one major drawback of the new system.读成This is =&gt; zis is 音节说的很清晰，没有轻音 1234567 \\This is my friend. (正常英语fri会重读)读成\\ \\ \\ \\zis is my friend. （俄语每个音节都重） 重音的位置 俄语很喜欢把重音放在第二位，或者倒数第二位如： 123Michigan (密歇根州) /ˈmɪʃəgən/俄语：/mɪ&#x27;ʃəgən/ （第二位） 相似的字母，误读成俄语字母，例如：x /s/ =&gt; х /h/ 12345Texas /ˈtɛksəs/读成T(д)e(е弱化为ие)x(俄语х/h/)as /ˈdihэs/ 一些常用的称呼，替换成俄文 12grandmother =&gt; бабушка /ba&#x27;bushga/aunt =&gt; Тётя /jiojie/ Tip：如何用英语、俄语口音说中文 直接在 google 翻译，选择英译俄，输入中文，再播放出来！","categories":[],"tags":[{"name":"俄语笔记","slug":"俄语笔记","permalink":"https://laputaz.github.io/home/tags/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0/"}]},{"title":"组件库的封装以及集成storybook展示","slug":"组件库的封装以及集成storybook展示","date":"2021-02-10T17:57:08.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"组件库的封装以及集成storybook展示/","link":"","permalink":"https://laputaz.github.io/home/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%9B%86%E6%88%90storybook%E5%B1%95%E7%A4%BA/","excerpt":"","text":"背景admin 新旧平台组件管理不够清晰, 部分组件散布在各个业务模块代码下, 不便管理, 没有统一的 list, 不熟悉的话容易出现重复开发, 也会造成 admin 工程越来越庞大; 目标组件抽离, 结合 storybook, 让组件状态可视化, 便于组件管理和复用, 同时也方便设计的同事参考. 建立 admin 组件库 建立 admin storybook - 可独立运行, 也可暴露文档至 klk-story展示 现状 已对 admin 组件做了 初步梳理 (待补充) 在admin项目中编写了部分 story, 需要抽离出来. 文档: Admin Storybook 初步方案klk-story 工程提供了一套开发方式, 将组件库放在 klk-story 工程下开发, 同时 story 文档也在klk-story下编写. 但 admin 方面希望可以做到分开独立维护, 初步的方案是新建一个独立的工程, 将组件库 (admin-ui) 和 story (admin-story) 封装成两个包, 发布到knpm , 独立于 klk-storybook 项目. klk-story 可以通过安装 admin-story 文档包来集中展示 story 文档, 这样 admin 可以有一套自身可独立运行的storybook, 也方便根据 admin 自身的需求做独立扩展 . 初步实现 建立一个 lerna 工程, 包含 admin-ui &amp;&amp; admin-story admin-ui 为组件库工程, packages下管理vue组件, 最后将组件打包为lib下的 js 文件输出. admin-story 是一个独立的 storybook 工程, 依赖于 admin-ui 组件库; 适配了mdx编写方式, 也适配了klk-story的 md 的编写方式, 打包输出是 lib 文件夹, 包含了需要在klk-story的 story 文档 发布到 knpm doc klk-story集成: npm 安装 @klk/admin-story, 在klk-story 的stories目录下配置 admin 的 stories ; ( admin-story 每次更新版本之后, 需要部署 klk-storybook 以同步最新组件文档) 效果 补充另外可能，组件在knpm发布初期本地调试可能会麻烦，这里可能用到类似npm-link之类的工具降低调试成本。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}]},{"title":"回顾：组件库样式问题整理","slug":"css-组件库样式问题整理","date":"2021-02-04T15:03:42.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"css-组件库样式问题整理/","link":"","permalink":"https://laputaz.github.io/home/css-%E7%BB%84%E4%BB%B6%E5%BA%93%E6%A0%B7%E5%BC%8F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"记在封装组件库时，遇到的样式问题","text":"记在封装组件库时，遇到的样式问题 背景组件库使用 element-ui 2.13.0, 最后会将组件样式和element-ui中使用到的组件的样式, 打包成一个 css 文件. 现象 在旧平台(element: 1.3) 引入组件库以及样式 可以看到, 组件库中element-ui 2.13.0的 checkbox 样式, 影响了旧平台中的checkbox 希望达到的效果让组件库中涉及element-ui 组件的样式, 只作用于组件库中的组件 尝试过的方法 方式一: 组件引入element 组件样式时, 增加 scoped 123456789101112131415&lt;template&gt; &lt;Checkbox :label=&quot;test&quot;&gt; Checkbox Here &lt;/Checkbox&gt;&lt;/template&gt;&lt;script&gt;// 引入 element 的 el-checkboximport Checkbox from &quot;element-ui/lib/checkbox&quot;;export default &#123; components: &#123; Checkbox &#125;&#125;;&lt;/script&gt;&lt;!-- 引入 element el-checkbox 样式, 增加scoped --&gt;&lt;style src=&quot;element-ui/lib/theme-chalk/checkbox.css&quot; scoped&gt;&lt;/style&gt; problem: 这种方式, 将样式引入写在父组件了, 但 &lt;style scoped&gt; 仅仅会影响到当前组件, 会为当前组件的 dom 节点增加data-v-xxx属性, 并为所有 css 样式增加 [data-v-xxx] 属性选择器, 如下图: 方式二: 组件库在编写组件时, 最外层增加namespace 1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- 命名空间 admin-ui --&gt; &lt;div class=&quot;admin-ui&quot;&gt; &lt;Checkbox :label=&quot;test&quot;&gt; Checkbox Here &lt;/Checkbox&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入 element 的 el-checkboximport Checkbox from &quot;element-ui/lib/checkbox&quot;;export default &#123; components: &#123; Checkbox &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;!--引入 element el-checkbox 样式/字体文件, 增加命名空间 .admin-ui --&gt;.admin-ui &#123; $--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;; @import &quot;~element-ui/packages/theme-chalk/src/base.scss&quot;; &lt;!-- el-checkbox 的样式 --&gt; @import &quot;~element-ui/packages/theme-chalk/src/checkbox.scss&quot;;&#125;&lt;/style&gt; problem: 当遇到会插入到 body的组件(例如弹出框 el-popover)时, 命名空间不生效 方式三 : scoped + deep 12345678910111213141516171819202122&lt;template&gt; &lt;Checkbox :label=&quot;test&quot;&gt; Checkbox Here &lt;/Checkbox&gt;&lt;/template&gt;&lt;script&gt;// 引入 element 的 el-checkboximport Checkbox from &quot;element-ui/lib/checkbox&quot;;export default &#123; components: &#123; Checkbox &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;!--或者 /deep/ --&gt;::v-deep &#123; &lt;!--引入字体样式--&gt; $--font-path: &quot;~element-ui/lib/theme-chalk/fonts&quot;; @import &quot;~element-ui/packages/theme-chalk/src/base.scss&quot;; &lt;!--引入 element el-checkbox 样式--&gt; @import &quot;~element-ui/lib/theme-chalk/checkbox&quot;;&#125;&lt;/style&gt; problem: 该方法本质上会生成: [data-v-xxx] .el-checkbox &#123;&#125;,相当于 [data-v-xxx]为命名空间[Emm] 对于 el-datepicker 等生成弹出框并插入body的组件同样不生效, el-select可以将弹出框限制不插入body, 而 el-datepicker 不行. 需梳理哪一些组件提供了 append-to-body 的 props append-to-body prop针对方式三, 只要将弹出框限制不插入到 body 即可 只要在源码中引入了 El-popover 或者 element-ui/src/utils/vue-popover mixin 的组件均包含 append-to-body 有一些组件虽然支持 append-to-body = false, 但是并没有在官方文档中体现 , 不排除会有问题出现, 或者升级之后 append-to-body 可能被去除(固定 element 版本即可) 相关的组件以及插入到 body 的 prop: popper-append-to-body: el-select el-autocomplete append-to-body: el-cascader el-datepicker el-popover el-color-picker (! not work) **** el-drawer el-dropdown (!需要加在子级 el-dropdown-menu, 但展示有问题, 需设置 style=&quot;width:max-content&quot;) el-timepicker el-tooltip el-dialog (默认 false) model-append-to-body: el-dialog Other problems 组件内部的 show-tooltip ? 解决方法: tooltip 样式设置为全局 ok, 因为 element1.4 与 2.13 样式是相同的 element 组件内部引用了其他组件, 例如 el-pagination 内使用了 el-select, 无法修改 append-to-body ? 解决方法: 增加自定义类名, 并手动设置 dropdown 样式 1234567891011121314151617181920&lt;Pagination popper-class=&quot;custom-popper&quot;/&gt;&lt;style lang=&quot;scss&quot;&gt; .custom-popper &#123; // 引入 select 样式 @import &#x27;~element-ui/lib/theme-chalk/select&#x27;; // 设置 dropdown 样式 &amp;.el-select-dropdown &#123; position: absolute; z-index: 1001; border: 1px solid #e4e7ed; border-radius: 4px; background-color: #fff; -webkit-box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1); box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1); -webkit-box-sizing: border-box; box-sizing: border-box; margin: 5px 0; &#125; &#125;&lt;/style&gt; $message / $confirm / $notification ? 解决方法: 不使用该类提示, 抛出事件, 由外部处理. 第三方库样式 ? 解决方法: 增加命名空间即可. 组件引入顺序引起的样式冲突, 如 select 中的 scroll__wrap, 如果 select 放在 cascader 后引入, 会影响 cascader 的样式 解决方法: 目前发现 cascader 会受影响, 将 cascader 放在最后引入 dart-sass 打包的字体乱码? 解决方法: 换成 node-sass ✔️, 在 vue-cli 增加以下配置: 12345678// npm i node-sass -Dcss: &#123; loaderOptions: &#123; sass: &#123; implementation: require(&#x27;node-sass&#x27;) &#125; &#125; &#125; 打包后@font-face 样式有问题, 会变成, ::v-deep没有成功解析 : 1234567@font-face&#123; ::v-deep &#123; font-family:element-icons; src:url(fonts/element-icons.535877f5.woff); ..... &#125;&#125; 暂用正则替换 ::v-deep解决: packages/admin-ui/build/fix-deep.js","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"},{"name":"问题","slug":"问题","permalink":"https://laputaz.github.io/home/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"webpack：webpack 使用笔记","slug":"js基础-webpack使用笔记","date":"2020-12-24T11:09:39.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-webpack使用笔记/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-webpack%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"webpack 的使用总结","text":"webpack 的使用总结 目录 为什么要用构建工具 构建工具的演变 主要配置项 一些常用配置 一些进阶配置 案例：使用 webpack 打包基础库 webpack 配置设计 webpack 构建速度和体积优化 为什么要用构建工具 转换 ES6 的语法 转换 JSX css 预处理器、前缀补全 代码压缩混淆 图片、字体等资源的处理 构建工具的演变由于 requirejs/seajs 等模块化的概念不断催生，前端模块化编写方式越来越复杂 主要使用的构建工具 grunt =&gt; gulp =&gt; webpack / rollup grunt 本质上是一个 task runder，将构建过程分为一个个任务，解析 html/css/js 等。但会将每个任务的结果存到本地磁盘，导致打包速度比较慢，磁盘 IO 的操作。 gulp 也是任务流，但是每一步构建的结果不会存放到本地磁盘，而是放在内存中，速度比较快。 webpack rollup 适合纯 js 的比较小的库，速度快，配置方便。 主要配置项123456789101112131415module.exports = &#123; entry: &#x27;./src/index.js&#x27;, // 入口 output: &#x27;./dist/main.js&#x27;, // 输出 mode: &#x27;production&#x27;, // 环境 // loader module: &#123; rules: [&#123; test: /\\.txt$/, use: &#x27;raw-loader&#x27; &#125;], &#125;, // 插件 plugins: [ new HtmlwebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, &#125;), ],&#125; entry 打包文件入口。 1234567891011// 单入口module.exports = &#123; entry: &#x27;./src/search.js&#x27;,&#125;// 多入口module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, search: &#x27;./src/search.js&#x27;, &#125;,&#125; output 打包文件的输出。 123456module.exports = &#123; output: &#123; path: path.join(__dirname, &#x27;dist&#x27;), // 输出目录 filename: &#x27;[name].js&#x27;, // 输出文件名称（entry 中指定的key名称） &#125;,&#125; loader webpack 开箱即用只支持 JS 和 JSON 两种文件类型，通过 Loader 去支持其它文件类型并且把它们转化成有效的模块，并且可以添加到依赖图中。 12345678module: &#123; rules: [ &#123; test: /.js$/, use: &#x27;babel-loader&#x27;, &#125;, ]&#125; 常用的 loader plugin 插件⽤于 bundle ⽂文件的优化，资源管理理和环境变量量注⼊入，作⽤于整个构建过程。 常用的插件 mode mode ⽤用来指定当前的构建环境是:production、development 还是 none。 一些常用配置解析 ES6借助 babel-loader + .babelrc，将 es6 语法转换成 es5 的语法，兼容旧的浏览器。 webpack 12345678module: &#123; rules: [ &#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, &#125;, ]&#125; .babelrc 1234567&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, // preset 就是预设，是一系列 babel 插件的集合 &quot;@babel/preset-react&quot; //react 语法解析 ], &quot;plugins&quot;: [&quot;@babel/proposal-class-properties&quot;] // babel 插件&#125; 解析 css css-loader 用于加载 .css 文件，转换成 commonjs 对象，这样就可以在代码中 import 或者 require 文件了。 style-loader 将样式通过 &lt;style&gt; 标签插⼊入到 head 中。 less-loader / sass-loader 转换 less 或者 scss 语法。 12345678module: &#123; rules: [ &#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;], // 从右往左解析 &#125;, ]&#125; 解析图片、字体 file-loader 用于处理图片、字体等文件。 12345678module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#x27;file-loader&#x27;, &#125;, ]&#125; url-loader 也可以用于处理图片、字体等文件，并且可以设置较小的资源自动转换成 base64，以减少 http 资源请求。 12345678910111213module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [&#123; loader: &#x27;url-loader&#x27;, options: [ limit: 10240 // 单位是字节。小于10k的图片，会转换成 base64 ] &#125;], &#125;, ]&#125; 解析 .vuevue loader 会解析 vue 文件，将 &lt;template&gt; 的内容转换为字符串，插入到 vue 的 template 属性中，并将生成的 js、css 交给下一步 babel-loader 和 css-loader 等去处理。 123456789101112131415161718192021222324252627module.exports = &#123; mode: &#x27;development&#x27;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, &#125;, // 它会应用到普通的 `.js` 文件 // 以及 `.vue` 文件中的 `&lt;script&gt;` 块 &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, &#125;, // 它会应用到普通的 `.css` 文件 // 以及 `.vue` 文件中的 `&lt;style&gt;` 块 &#123; test: /\\.css$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, ], &#125;, plugins: [ // 请确保引入这个插件来施展魔法 new VueLoaderPlugin(), ],&#125; 文件监听 webpack –watch =&gt; 当文件有更新时，会自动构建，但不会刷新浏览器，需要手动。 webpack 会轮询判断文件的最后编辑时间是否变化，某个文件发⽣了变化，并不会⽴刻告诉监听者，而是先缓存起来，等 aggregateTimeout 时间后再执行。 123456789101112module.export = &#123; //默认 false，也就是不开启 watch: true, // 只有开启监听模式时，watchOptions才有意义 wathcOptions: &#123; // 默认为空，不监听的文件或者文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行，默认300ms aggregateTimeout: 300, //判断文件是否发生变化，是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次 poll: 1000, &#125;,&#125; 热更新 方法一：webpack-dev-server 插件，有三个优势： 不刷新浏览器 不输出文件，放在内存中，没有磁盘 IO package.json 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js --open&quot;&#125;, webpack.config 1234567module.exports = &#123; plugins: [new webpack.HotModuleReplacementPlugin()], devServer: &#123; contentBase: &#x27;./dist&#x27;, hot: true, &#125;,&#125; 方法二：webpack-dev-middleware 中间件。适⽤于灵活的定制场景，需要自己实现服务器（WDM 将 webpack 输出的⽂件传输给服务器）。 使用 express 123456789101112const express = require(&#x27;express&#x27;)const webpack = require(&#x27;webpack&#x27;)const webpackDevMiddleware = require(&#x27;webpack-dev- middleware&#x27;)const app = express()const config = require(&#x27;./webpack.config.js&#x27;)const compiler = webpack(config)app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath &#125;))app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!\\n&#x27;)&#125;) 热更新原理 启动阶段： 经过 webpack compiler 打包文件； 打包好后，将编译好的 bundle 传输给 bundle sever，bundle sever 是一个服务，让浏览器可以正常访问； 更新阶段： 当文件发生更新时，webpack compiler 打包文件； 代码发送到 HMR server，得知那些模块发生了改变； HMR server 通知 HMR runtime，通常以 json 数据传输，HMR runtime 更新浏览器代码，不需要刷新浏览器。 文件指纹文件指纹一般用来做版本管理，对于没有修改的文件，可以继续取浏览器缓存。例如, 让 index.html 入口的 response header 设置为 cache-control: no-cache, 不允许缓存， 其他 js 文件设置缓存 cache-control: xxx。 Hash：和整个项目的构建相关，只要项⽬文件有修改，整个项⽬构建的 hash 值就会更更改。 Chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值。 Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变。 1234567891011121314151617181920212223module.exports = &#123; output: &#123; // 文件 path: path.join(__dirname, &#x27;dist&#x27;), filename: &#x27;[name]_[chunkhash:8].js&#x27;, &#125;, module: &#123; rules: [ &#123; test: /.(png|jpg|gif|jpeg)$/, use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; // 图片 name: &#x27;[name]_[hash:8].[ext]&#x27;, &#125;, &#125;, ], &#125;, ], &#125;,&#125; 常用占位符： html / css / js 压缩 js 压缩: 内置了 uglifyjs-webpack-plugin 插件，不需要额外处理（当然也可以手动加一些配置）。 html 压缩：html-webpack-plugin，可以把空格、换行符、注释等都处理掉。1234567891011121314151617plugins: [ //多页多入口时，一个 html 页面加一次 new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;src/index.html&#x27;), filename: &#x27;index.html&#x27;, // 打包出来的文件名 chunks: [&#x27;index&#x27;], // 指定打包出来的 html 要写入哪些 chunks inject: true, // css 等会注入到 html 里面去 minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false, &#125;, &#125;),] css 压缩：optimize-css-assets-webpack-plugin，同时使⽤用 cssnano123456plugins: [ new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(&#x27;cssnano&#x27;), &#125;),] 一些进阶配置自动清理构建目录每次构建的时候不会清理⽬录，造成构建的输出⽬录 output 文件越来越多，使用 clean-webpack-plugin 清理，默认会清理 output 指定的输出目录。 1plugins: [new CleanWebpackPlugin()] css 前缀由于市面上存在不同的浏览器渲染内核，需要为一些 css 属性增加前缀做兼容。如： 123456.box &#123; -moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; postCss 是一个后处理器，结合 autoprefixer，生成需要的浏览器 css 前缀。 123456789101112131415161718192021222324module.exports = &#123; module: &#123; rules: [ &#123; test: /.less$/, use: [ &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#123; loader: &#x27;postcss-loader&#x27;, options: &#123; plugins: () =&gt; [ require(&#x27;autoprefixer&#x27;)(&#123; // 支持最新的两个版本，1% 的使用比例，ios7以上，参考 caniuse.com browsers: [&#x27;last 2 version&#x27;, &#x27;&gt;1%&#x27;, &#x27;ios 7&#x27;], &#125;), ], &#125;, &#125;, ], &#125;, ], &#125;,&#125; 移动端 px 转换成 rem移动设备尺寸太多了，如果使用媒体查询实现布局会编写很多套，会比较麻烦。使用 rem ，参考标准是根元素的 font-size。 root element font-size。使用 px2rem-loader 自动转换成 rem。 使用 px2rem-loader 自动转换成 rem 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ &#123; test: /.less$/, use: [ &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#123; loader: &#x27;px2rem-loader&#x27;, options: &#123; remUnit: 75, remPrecision: 8, // 8 位小数 &#125;, &#125;, ], &#125;, ], &#125;,&#125; 利用手机淘宝的库：lib-flexible, 自动设置根元素的 font-size 资源内联将 css 和 js 代码内联到 html，意义： 代码层⾯： 页面框架的初始化脚本 上报相关打点 css 内联，避免页面闪动 请求层⾯面: 减少 HTTP ⽹络请求数 小图⽚或者字体内联 (url-loader) html / js 内联： 12345raw-loader 内联 html// 如 meta 信息&lt;script&gt;$&#123;require(&#x27;raw-loader!babel-loader!./meta.html&#x27;)&#125;&lt;/script&gt;raw-loader 内联 JS&lt;script&gt;$&#123;require(&#x27;raw-loader!babel-loader!../node_modules/lib-flexible&#x27;)&#125;&lt;/script&gt; css 内联： 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ &#123; loader: &#x27;style-loader&#x27;, options: &#123; insertAt: &#x27;top&#x27;, // 样式插入到 &lt;head&gt; singleton: true, //将所有的style标签合并成一个 &#125; &#125;, &#125;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;, ], &#125;, ], &#125;,&#125; 多页面打包方案 每个⻚面对应一个 entry，⼀个写 html-webpack-plugin（缺点:每次新增或删除⻚面需要改 webpack 配置） 动态获取 entry 和设置 html-webpack-plugin 数量。利用 glob.sync。1entry: glob.sync(path.join(__dirname, &#x27;./src/*/index.js&#x27;)) source-mapsource-map 的作用是通过 source map 定位到源代码，开发环境开启，线上环境关闭，线上排查问题的时候可以将 sourcemap 上传到错误监控系 提取公共资源每个页面（多页非单页）可能会使用相同的模块，不需要重复打包了。 12345678910111213141516171819module.exports = &#123; optimization: &#123; splitChunks: &#123; // webpack4 chunks: &#x27;async&#x27;, // async 只会处理 import() 异步引入的库， initial 是正常同步引入的库， all是所有的库 minSize: 30000, // 抽离的包最小大小，小于这个大小将不会抽离 maxSize: 0, // 抽离的包最大大小 minChunks: 1, // 最小引用的次数，比如包被引用了两次 automaticNameDelimiter: &#x27;~&#x27;, name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, &#125;, &#125;, &#125;, &#125;,&#125; Tree shakingwebpack 借鉴了 rollup。用于擦除无用代码： 代码不会被执行，不可到达 代码执⾏的结果不会被用到 代码只会影响死变量(只写不读) 例如： 123if (false) &#123; console.log(&#x27;这段代码永远不会执行&#x27;)&#125; 必须是 es6 import 语法。原理利用了 ES6 模块的特点： 只能作为模块顶层的语句句出现 import 的模块名只能是字符串串常量量 import binding 是 immutable 的 像 import() 动态引入的代码，只能在执行的时候才知道有没有用到，不能运用。 代码擦除: uglify 阶段删除⽆用代码 scope hoisting打包后的 es5 代码,为了模拟模块作用域，会存在大量的闭包。 存在问题： ⼤量作⽤域包裹代码，导致体积增大(模块越多越明显) 运行代码时创建的函数作⽤域变多，内存开销变大 解决原理:将所有模块的代码按照引用顺序放在一个函数作⽤域里，然后适当的重命名一些变量以防⽌变量名冲突。通过 scope hoisting 可以减少函数声明代码和内存开销。 webpack mode 为 production 默认开启。 动态引入脚本懒加载，使得初始下载的代码更小。 ES6: 动态 import() (⽬前还没有原⽣支持，需要 babel 转换) .babelrc:123&#123; &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;],&#125; 优化构建时的命令显示 设置 stat 使用 friendly-errors-webpack-plugin (stats 设置成 errors-only) 1234module.exports = &#123; plugins: [new FriendlyErrorsWebpackPlugin()], stats: &#x27;errors-only&#x27;,&#125; echo$ 可以输出是否打包出错。 compiler 在每次构建结束后，会在 plugin 触发 done 的钩子，所以可以监听 done 捕获： 12345678910111213141516module.exports = &#123; plugins: [ function () &#123; this.hooks.done.tap(&#x27;done&#x27;, (stats) =&gt; &#123; if ( stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf(&#x27;- -watch&#x27;) == -1 ) &#123; console.log(&#x27;build error&#x27;) process.exit(1) &#125; &#125;) &#125;, ],&#125; 案例：使用 webpack 打包基础库实现⼀个⼤整数加法库的打包，效果: 压缩版本和非压缩版本（分别用于开发和产线） ⽀持 AMD/CJS/ESM 模块引⼊ 目录结构 模块语法 暴露 webpack 配置： 1234567891011121314151617181920212223const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)module.exports = &#123; entry: &#123; &#x27;large-number&#x27;: &#x27;./src/index.js&#x27;, &#x27;large-number.min&#x27;: &#x27;./src/index.js&#x27;, &#125;, output: &#123; filename: &#x27;[name].js&#x27;, library: &#x27;largeNumber&#x27;, libraryTarget: &#x27;umd&#x27;, libraryExport: &#x27;default&#x27;, &#125;, mode: &#x27;none&#x27;, // 去掉默认压缩，改用 terser-webpack-plugin 压缩 optimization: &#123; minimize: true, minimizer: [ new TerserPlugin(&#123; include: /\\.min\\.js$/, &#125;), ], &#125;,&#125; 新增入口文件，判断不同环境使用的入口： 12345if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; module.exports = require(&#x27;./dist/large-number.min.js&#x27;)&#125; else &#123; module.exports = require(&#x27;./dist/large-number.js&#x27;)&#125; package.json 配置，将 index 设置为 入口， prepublish 钩子设置打包。 12345678910&#123; &quot;name&quot;: &quot;large-number&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;大整数加法打包&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;prepublish&quot;: &quot;webpack&quot; &#125;&#125; webpack 配置设计 webpack 构建速度和体积优化 在 node 中使用 webpack 回调查看打包结果 使用 speed-measure-webpack-plugin 分析打包速度 使用 webpack-bundle-analyzer 查看打包结果 多进程/多实例构建 =&gt; thread-loader / HappyPack 多进程并行压缩代码 =&gt; parallel-uglify-plugin / uglifyjs-webpack-plugin 开启 parallel 参数 / terser-webpack-plugin 开启 parallel 参数 增加构建缓存（提升二次构建速度） babel-loader 开启缓存 terser-webpack-plugin 开启缓存 使用 cache-loader 或者 hard-source-webpack-plugin","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"webpack","slug":"webpack","permalink":"https://laputaz.github.io/home/tags/webpack/"}]},{"title":"js基础：require和import到底有什么区别","slug":"js基础-require和import到底有什么区别","date":"2020-12-07T15:33:31.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-require和import到底有什么区别/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-require%E5%92%8Cimport%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"requirerequire 是 commonjs 的语法。module.exports 导出一个对象或者基础值。并且该对象会被缓存在 require.cache。下一次 require 时，会从缓存读取，不会重新执行。 1234567891011121314151617// module.jslet num = 1;// 2秒后改变为 22setTimeout(() =&gt; &#123; num = 22;&#125;, 200);module.exports = num;// index.jslet obj = require(&#x27;./module1.js&#x27;);console.log(obj); // 1setTimeout(() =&gt; &#123; // 两秒后仍然输出 1 console.log(obj); // 1&#125;, 2000); **有一些文章说，commonjs 模块输出的，是值的拷贝，我是不同意的**，浅拷贝，如下: 1234567891011121314151617// module.jslet obj = &#123; a: 1 &#125;;// 2秒后改变为 22setTimeout(() =&gt; &#123; obj.a = 22;&#125;, 200);module.exports = obj;// index.jslet obj = require(&#x27;./module1.js&#x27;);console.log(obj); // 1setTimeout(() =&gt; &#123; // 两秒后输出 22 console.log(obj); // 22&#125;, 2000); 如果真的是一份拷贝值，暴露的值即使是引用类型，也不应该会变。 浅拷贝 1234567891011121314// module.jslet obj = &#123; a: 1 &#125;;module.exports = obj;// index.jslet obj = require(&#x27;./module.js&#x27;);setTimeout(() =&gt; &#123; delete require.cache[require.resolve(&#x27;./module.js&#x27;)]; let obj1 = require(&#x27;../review/module.js&#x27;); // 两秒后输出 false console.log(obj === obj1, &#x27;index&#x27;); // false&#125;, 2000); 如果在外部改变 require 模块暴露的值，模块内是会生效的。 1234567891011121314151617181920212223242526// module.jslet obj = &#123; a: 1 &#125;;// 被加上了 b 属性setTimeout(() =&gt; &#123; console.log(obj, &#x27;100&#x27;);&#125;, 100);// 2秒后改变为 22setTimeout(() =&gt; &#123; obj.a = 22;&#125;, 200);module.exports = obj;// -------------------------// index.jslet obj = require(&#x27;./module.js&#x27;);obj.b = 1;setTimeout(() =&gt; &#123; // 两秒后输出 22 console.log(obj, &#x27;index&#x27;); // 22&#125;, 2000); 我们只能说，commonjs 会输出初始执行的结果（不管有没有缓存。即使没缓存，再执行一遍模块，输出结果也是一样的）。如果输出的值包含了引用类型，那更改一样会生效。这是 js 本身的特性，和 commonjs 没什么关系。 除非重新调用 module.exports，去更新模块暴露的值，并且重新执行 require： 12345678910111213141516let obj = &#123; a: 1 &#125;;setTimeout(() =&gt; &#123; obj.a = 22; // 重新调用 module.exports module.exports = 2;&#125;, 200);module.exports = obj;// index.jslet obj = require(&#x27;./module1.js&#x27;);console.log(obj); // &#123; a: 1 &#125;setTimeout(() =&gt; &#123; // 重新引用 console.log(require(&#x27;./module1.js&#x27;)); // 2&#125;, 2000); importimport 是 es6 的语法。当使用非 default 暴露时，被引用模块中改变暴露值，引用方可以获取到变化（动态输出绑定）。 1234567891011121314151617// module.jslet num = 1;setTimeout(() =&gt; &#123; num = 22;&#125;, 200);export &#123; num &#125;;// index.jsimport &#123; num &#125; from &#x27;./module.js&#x27;;// 先输出 1console.log(num);setTimeout(() =&gt; &#123; // 两秒后输出 22 console.log(num);&#125;, 2000); 使用 default 暴露，行为和 commonjs 一致 123456789101112131415161718// modlet num = 1;setTimeout(() =&gt; &#123; num = 2;&#125;, 1000);export default num;export &#123; num &#125;;// index.jsimport mod, &#123; num &#125; from &#x27;./mod.js&#x27;;console.log(mod, num); // 1 1setTimeout(() =&gt; &#123; console.log(mod, num); // 1 2&#125;, 2000); export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。 对于 CommonJS： 1234567891011// module.jsmodule.exports = &#123; value: 1 &#125;;// main.jsconst module = require(&#x27;./module&#x27;);console.log(module.value); // 输出 1module.value = 2;// other.jsconst moduleAgain = require(&#x27;./module&#x27;);console.log(moduleAgain.value); // 输出 2 这里，module 的导出是共享的引用，更改会影响其他地方。 对于 ES6 模块： 1234567891011// module.jsexport let value = 1;// main.jsimport &#123; value &#125; from &#x27;./module&#x27;;console.log(value); // 输出 1value = 2; // 本地修改，会报错。除非 value 是对象，然后改 value 的属性// other.jsimport &#123; value &#125; from &#x27;./module&#x27;;console.log(value); // 输出 1，导出的值不会受外部修改影响 在 ES6 中，导出的值是按引用绑定的，但在导入处不能直接修改它的值。要想修改导出的变量，通常需要在原模块中提供一个函数来进行修改。 CommonJS 和 ES6 模块 是两种不同的模块系统，前者是动态的，后者是静态的，前者常用于 Node.js，后者被现代前端开发广泛采用。 导出机制：CommonJS 允许导出对象的动态引用，ES6 模块更偏向于静态分析和编译期优化。 值传递和拷贝：两者都是通过引用导出，类似浅拷贝，但 ES6 模块在导入后不能直接修改导入值，CommonJS 可以直接修改对象。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：WebComponents 和 ShadowDOM","slug":"js基础-WebComponents和ShadowDOM","date":"2020-11-23T16:04:37.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-WebComponents和ShadowDOM/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-WebComponents%E5%92%8CShadowDOM/","excerpt":"WebComponents 和 ShadowDOM","text":"WebComponents 和 ShadowDOM 组件化存在的问题HTML 和 CSS 是如何阻碍前端组件化的，一个简单的例子： 1234567&lt;style&gt; p &#123; background-color: brown; color: cornsilk; &#125;&lt;/style&gt;&lt;p&gt;I am river&lt;/p&gt; 问题： CSS 是影响全局的 任何地方都可以直接读取和修改 DOM WebComponentWebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和 HTML templates（HTML 模板） 影子 DOM影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。 实现例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;!-- 一：定义模板 二：定义内部CSS样式 三：定义JavaScript行为 --&gt; &lt;template id=&quot;river-t&quot;&gt; &lt;style&gt; p &#123; background-color: brown; color: cornsilk; &#125; div &#123; width: 200px; background-color: bisque; border: 3px solid chocolate; border-radius: 10px; &#125; &lt;/style&gt; &lt;div&gt; &lt;p&gt;I am river&lt;/p&gt; &lt;p&gt;I am river&lt;/p&gt; &lt;/div&gt; &lt;script&gt; function foo() &#123; console.log(&#x27;inner log&#x27;) &#125; &lt;/script&gt; &lt;/template&gt; &lt;script&gt; class River extends HTMLElement &#123; constructor() &#123; super() //获取组件模板 const content = document.querySelector(&#x27;#river-t&#x27;).content //创建影子DOM节点 const shadowDOM = this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;) //将模板添加到影子DOM上 shadowDOM.appendChild(content.cloneNode(true)) &#125; &#125; customElements.define(&#x27;river&#x27;, River) &lt;/script&gt; &lt;river&gt;&lt;/river&gt; &lt;div&gt; &lt;p&gt;I am river&lt;/p&gt; &lt;p&gt;I am river&lt;/p&gt; &lt;/div&gt; &lt;river&gt;&lt;/river&gt; &lt;/body&gt;&lt;/html&gt; 首先，使用 template 属性来创建模板。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。 其次，我们需要创建一个 River 的类。在该类的构造函数中要完成三件事：查找模板内容；创建影子 DOM；再将模板添加到影子 DOM 上。 最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的。 以上在没有 webcomponent 的时候，通过 react 和 vue 基于当前的前端特性去实现组件化，他们之间是互相影响和借鉴的，最终 react 和 vue 也会向 webcomponent 标准的方向演进。但是现在由于 webcomponent 的浏览器支持还不是太好，所以现阶段它们还是会并存的。Vue，React 是从开发者层面解决了组件化的问题，提高了效率。WebComponent 是从浏览器引擎实现层面解决了组件化的问题。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"实现：跨域的解决方法与demo","slug":"js基础-跨域与解决方法","date":"2020-09-29T11:32:38.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-跨域与解决方法/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"跨域的解决方式，写一下 demo。代码： https://github.com/laputaz/cross-origin-demo","text":"跨域的解决方式，写一下 demo。代码： https://github.com/laputaz/cross-origin-demo 通过 jsonp 跨域 跨域资源共享（CORS） document.domain + iframe 跨域 location.hash + iframe postMessage 跨域 nginx 代理跨域 nodejs 中间件代理跨域 WebSocket 协议跨域 jsonp原理是通过 script 标签允许跨域的特性。前端生成 script 标签，src 为请求的 url，前端定义好 callback 函数，并把 callback 函数名传到后端。后端生成 callback(res) 的形式，设置 content-type 为 javascript，使得浏览器接收到响应后当成 javascript 执行。 前端： 123456789101112131415161718192021222324252627282930&lt;div&gt;JSONP&lt;/div&gt;原生:&lt;p class=&quot;inner&quot;&gt;&lt;/p&gt;Jquery:&lt;p class=&quot;inner1&quot;&gt;&lt;/p&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; // 1. 原生实现 ---------------------------------------------------- // 创建 script const script = document.createElement(&#x27;script&#x27;) script.type = &#x27;text/javascript&#x27; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &#x27;http://localhost:3000/jsonp?callback=handleCallback&#x27; // 回调执行函数, 从参数中拿到结果 function handleCallback(res) &#123; document.querySelector(&#x27;.inner&#x27;).innerHTML = JSON.stringify(res) &#125; window.handleCallback = handleCallback document.head.appendChild(script) // --- // 2.jquery 实现 ---------------------------------------------------- $.ajax(&#123; url: &#x27;http://localhost:3000/jsonp?callback=handleCallback&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;, // 请求方式为jsonp jsonpCallback: &#x27;handleCallback&#x27;, // 自定义回调函数名 &#125;).done(function (data) &#123; document.querySelector(&#x27;.inner1&#x27;).innerHTML = JSON.stringify(data) &#125;)&lt;/script&gt; koa 实现服务端： 1234567891011router.get(&#x27;/jsonp&#x27;, (ctx, next) =&gt; &#123; // 取得 callback 函数名 const callbackFunc = ctx.request.query.callback // 需要返回的结果 const res = &#123; name: &#x27;river&#x27; &#125; // 返回 ctx.response.body = `$&#123;callbackFunc&#125;($&#123;JSON.stringify(res)&#125;)` // 设置为javascript类型的返回 ctx.response.headers[&#x27;content-type&#x27;] = &#x27;text/javascript;charset=UTF-8&#x27; next()&#125;) 效果： jsonp 的缺点在于只能实现 get 请求 CORS再说一次，跨域是浏览器的限制，cors 是浏览器读取服务端响应头，判断 Access-Control-xxx 相关的字段，再决定能否跨域 跨域的情形（简单请求）： 在涉及到 CORS 的请求中，我们会把请求分为简单请求和复杂请求。 规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。 简单请求的判断方式： 请求方法：GET、POST、HEAD 除了以下的请求头字段之外，没有自定义的请求头 Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width Content-Type 的值只有以下三种(Content-Type 一般是指在 post 请求中，get 请求中设置没有实际意义) text/plain multipart/form-data application/x-www-form-urlencoded 复杂请求的例子： 在请求头加入自定义的 headers: {custom:1} 123456789&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.22.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; // 访问 axios.get(&#x27;http://localhost:3000/cors&#x27;, &#123; headers: &#123; custom: 1, &#125;, &#125;)&lt;/script&gt; 后端代码 123456789101112router.options(&#x27;/cors&#x27;, (ctx, next) =&gt; &#123; console.log(&#x27;This is a response, methods: options&#x27;) ctx.response.body = 1 ctx.status = 500 next()&#125;)router.get(&#x27;/cors&#x27;, (ctx, next) =&gt; &#123; console.log(&#x27;This is a response, methods: get&#x27;) ctx.response.body = 1 next()&#125;) 可以看到，会发送一个 options 请求。 并且，只要预检不通过，真正的请求是不会被发送的，从服务端的日志可以看到，只接受到了 options 上图预检返回的状态码是 500。那预检怎么样才算通过呢？状态码 200？并不是，需要是状态码 200，并且，响应头带有 Access-Control-xxxx 等字段。把上面服务端代码改成： 12345678910111213141516router.options(&#x27;/cors&#x27;, (ctx, next) =&gt; &#123; console.log(&#x27;This is a response, methods: options&#x27;) ctx.response.body = 1 ctx.status = 200 // 允许的源 ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) // 允许的请求头 ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;custom&#x27;) next()&#125;)router.get(&#x27;/cors&#x27;, (ctx, next) =&gt; &#123; console.log(&#x27;This is a response, methods: get&#x27;) ctx.response.body = 1 next()&#125;) 可以看到，options 预检通过了，get 请求已经正常发出了。 但因为跨域被屏蔽了。这个时候服务端可以正常响应，表现得状态码也是服务端返回的状态码。但是响应信息被浏览器屏蔽了。没办法获取。 一些常用的 CORS 头 123456789101112131415161718192021222324252627282930313233343536373839404142434445app.use(async (ctx, next) =&gt; &#123; // 允许来自所有域名请求 ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) // 这样就能只允许 http://localhost:8080 这个域名的请求了 // ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;); // 设置所允许的HTTP请求方法 ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;OPTIONS, GET, PUT, POST, DELETE&#x27;) // 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段. ctx.set( &#x27;Access-Control-Allow-Headers&#x27;, &#x27;x-requested-with, accept, origin, content-type，custom&#x27; ) // 服务器收到请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 // Content-Type表示具体请求中的媒体类型信息 ctx.set(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;) // 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。 // 当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;; ctx.set(&#x27;Access-Control-Allow-Credentials&#x27;, true) // 该字段可选，用来指定本次预检请求的有效期，单位为秒。 // 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证 // 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证 ctx.set(&#x27;Access-Control-Max-Age&#x27;, 300) /* CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段： Cache-Control、 Content-Language、 Content-Type、 Expires、 Last-Modified、 Pragma。 */ // 需要获取其他字段时，使用Access-Control-Expose-Headers， // getResponseHeader(&#x27;myData&#x27;)可以返回我们所需的值 //https://www.rails365.net/articles/cors-jin-jie-expose-headers-wu ctx.set(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;myData&#x27;) await next()&#125;) 注意，正常情况下，每次发送跨域复杂请求，都会发 options 预检，我们可以设置 Access-Control-Max-Age: 3000，单位毫秒。即在规定时间内不用再发送预检请求了。节省流量。 document.domain + iframe 跨域仅限主域相同，子域不同的跨域应用场景。两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。 父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &#x27;domain.com&#x27; var user = &#x27;admin&#x27;&lt;/script&gt; 子窗口：(http://child.domain.com/b.html) 1234&lt;script&gt; document.domain = &#x27;domain.com&#x27; // 获取父窗口中变量 alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user)&lt;/script&gt; location.hash + iframe 在父页面：iframe.src = iframe.src + ‘#user=admin’; 在子页面：window.onhashchange = function () {} postMessage + iframe/window.open在不同的端口起两个页面 在页面一设置一个 iframe，指向页面二，并隐藏 12345678910111213141516171819202122232425262728&lt;div&gt;index&lt;/div&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;http://127.0.0.1:8081/src/postMessage/index1.html&quot; style=&quot;display: none&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&#x27;iframe&#x27;) iframe.onload = function () &#123; var data = &#123; name: &#x27;river&#x27;, &#125; // 通过iframe向domain2传送跨域数据 iframe.contentWindow.postMessage( JSON.stringify(data), &#x27;http://127.0.0.1:8081&#x27; ) &#125; // 接受domain2返回数据 window.addEventListener( &#x27;message&#x27;, function (e) &#123; alert(&#x27;data from 8081 ---&gt; &#x27; + e.data) &#125;, false )&lt;/script&gt; 在页面二接受，并返回 1234567891011121314151617&lt;div&gt;index1&lt;/div&gt;&lt;script&gt; // 接收domain1的数据 window.addEventListener( &#x27;message&#x27;, function (e) &#123; alert(&#x27;data from 8080 ---&gt; &#x27; + e.data) var data = JSON.parse(e.data) if (data) &#123; data.number = 16 // 处理后再发回 8080 window.parent.postMessage(JSON.stringify(data), &#x27;*&#x27;) &#125; &#125;, false )&lt;/script&gt; 效果： 子页面（页面二）收到了来自父页面（页面一）的信息： 子页面处理数据后返回，父页面收到了子页面的信息。 这么看来，如果页面一需要调用页面二的域的接口，就可以通过这种方式做了。 nginx 代理跨域 首先配置 nginx 指向 index.html 配置 /nginx-api 接口代理到 localhost:3000 nginx 配置： 123456789101112server &#123; listen 8080; server_name localhost; location / &#123; # 配置页面指向的地址 root /Users/river/Documents/workspace/cross-origin-demo/src/nginx/; index index.html; &#125; location /nginx-api &#123; # 配置请求转发 proxy_pass http://localhost:3000; #反向代理 &#125;&#125; 前端请求： 123456&lt;div&gt;nginx-test&lt;/div&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.22.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; // 访问 axios.get(&#x27;/nginx-api&#x27;)&lt;/script&gt; node 服务端（localhost:3000） 12345router.get(&#x27;/nginx-api&#x27;, (ctx, next) =&gt; &#123; console.log(&#x27;This is a response, methods: get&#x27;) ctx.response.body = &#x27;转发成功&#x27; next()&#125;) 效果： nodejs 中间件代理跨域也就是在 node 中间层请求接口再返回，不演示了。。 WebSocket 协议跨域WebSocket 实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。原生 WebSocket API 使用起来不方便，使用 Socket.io，它封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。 客户端: socket.io-client 12345678910111213141516171819202122232425&lt;div&gt;user input：&lt;input type=&quot;text&quot; /&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.socket.io/4.2.0/socket.io.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io(&#x27;http://localhost:3000&#x27;) // 连接成功处理 socket.on(&#x27;connect&#x27;, function () &#123; // 监听服务端消息 socket.on(&#x27;message&#x27;, function (msg) &#123; console.log(&#x27;data from server: ---&gt; &#x27; + msg) &#125;) // 监听服务端关闭 socket.on(&#x27;disconnect&#x27;, function () &#123; console.log(&#x27;Server socket has closed.&#x27;) &#125;) &#125;) document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function () &#123; if (this.value === &#x27;close&#x27;) &#123; socket.close() &#125; socket.send(this.value) &#125;&lt;/script&gt; 服务端：koa + socket.io 1234567891011121314151617181920212223const Koa = require(&#x27;koa&#x27;)const app = new Koa()// router.jsconst server = require(&#x27;http&#x27;).createServer(app.callback())// corsconst io = require(&#x27;socket.io&#x27;)(server, &#123; cors: &#123; origin: &#x27;*&#x27;, &#125;,&#125;)// socket连接io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; socket.on(&#x27;message&#x27;, (msg) =&gt; &#123; console.log(&#x27;message: &#x27; + msg) io.emit(&#x27;message&#x27;, msg) &#125;) socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;user disconnected&#x27;) &#125;)&#125;)server.listen(3000)console.log(&#x27;Server is running at port 3000...&#x27;) 效果","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"实现：HTTP缓存的使用及 demo","slug":"js基础-HTTP缓存的使用demo","date":"2020-09-25T17:22:33.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-HTTP缓存的使用demo/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8demo/","excerpt":"用 koa 来 demo 一下 HTTP 缓存的使用。","text":"用 koa 来 demo 一下 HTTP 缓存的使用。 代码在这里 https://github.com/laputaz/bower-cache-demo 介绍HTTP 缓存一般分为两类：强制缓存（也称本地缓存）和协商缓存（也称弱缓存）。 本地缓存浏览器发送请求前，会先去缓存里查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器。否则，进入下一步。 协商缓存当强缓存没有命中时，浏览器一定会向服务器发起请求。服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。如果命中，服务器会返回 304 响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从浏览器缓存文件中获取这个资源。如果本地缓存和协商缓存都没有命中，则从直接从服务器加载资源。 战前准备先起一个基础项目 12345678910111213141516// app.js 入口const Koa = require(&#x27;koa&#x27;)const app = new Koa()const routes = require(&#x27;./routes.js&#x27;).routesapp.use(routes)// 公共，均返回文件const base = async (ctx) =&gt; &#123; ctx.response.type = &#x27;text/html&#x27; ctx.response.body = `&lt;h1&gt;Hello, $&#123;ctx.path.slice(1)&#125;&lt;/h1&gt;`&#125;// 对于任何请求，app将调用该异步函数处理请求：app.use(base)// 在端口3000监听:app.listen(3000) 12345678// router.jsconst Router = require(&#x27;koa-router&#x27;)const router = new Router()// 这里边写路由// router.get(&#x27;test-expires&#x27;, (ctx) =&gt; &#123;&#125;)exports.routes = router.routes() 12# 跑它nodemon app.js 强制缓存 - Expires Expires 响应头包含日期/时间(格林威治时间 GMT）在此时间之后，缓存过期。无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。Expires 是 HTTP1.0 出现的， 优先级低于 Cache-Control。 Expires 有 3 个弱点。 服务器端的时钟必须和客户端一致。 最小的颗粒度为 s。 由于是一个绝对的时间值，所以必须时常更新它的值。 格式 1Expires: Sun, 26 Sep 2021 16:28:00 GMT 实现 123router.get(&#x27;test-expires&#x27;, (ctx) =&gt; &#123; ctx.set(&#x27;Expires&#x27;, &#x27;Sun, 26 Sep 2021 16:39:00 GMT&#x27;)&#125;) 效果 再次打开可以看到，读的是 disk cache 磁盘缓存。 强制缓存 - Cache-ControlCache-Control 是 HTTP1.1 提出的。提供了比 Expires 更精细的缓存时间，毫秒级。以及可以设置不缓存。 常用值： 可缓存性 public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control 的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定(名字容易误导) no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 到期 max-age=xxx 毫秒：缓存内容将在 xxx 秒后失效 指定 no-cache 或 max-age=0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。 格式 1234Cache-Control: max-age=20000 // 20s后过期Cache-Control：no-cache // 会缓存，但是否使用需要请求服务器确认Cache-Control：no-store // 不允许所有缓存Cache-Control: private // 只有浏览器可缓存，代理服务器不行 效果 再次打开可以看到，读的是 disk cache 磁盘缓存。 协商缓存 - Last-Modified / If-Modified-SinceIf-Modified-Since 则是客户端发起该请求时，携带上一次响应头返回的 Last-Modified 值，告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。 未设置的情况，响应头没有 Last-Modified，请求头当然也没有 If-Modified-Since 响应头设置 Last-Modified，并第一次请求, 此时请求头当然也没有 If-Modified-Since，这时，文件已经被浏览器缓存了。 1234567// last-modifiedrouter.get(&#x27;/test-last-modified&#x27;, (ctx, next) =&gt; &#123; ctx.set(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;) // 设置 Last-Modified ctx.set(&#x27;Last-Modified&#x27;, &#x27;Sun, 26 Sep 2021 21:39:03 GMT&#x27;) next()&#125;) 下一次请求，可以看到，请求头已经有 If-Modified-Since 了 请求过来时，服务端会对请求头中的 If-Modified-Since 与文件修改时间作对比，这就是代码上控制了。这里假设文件没过期，返回 304。 12345678910111213// last-modifiedrouter.get(&#x27;/test-last-modified&#x27;, (ctx, next) =&gt; &#123; ctx.set(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;) // 对请求头中的 If-Modified-Since 与文件修改时间做对比, 这里不写了 if (true) &#123; // 发现文件时间未更新，返回 304，让浏览器读缓存。 ctx.response.status = 304 &#125; else &#123; // 发现文件时间已更新，更新 Last-Modified ctx.set(&#x27;Last-Modified&#x27;, &#x27;Sun, 28 Sep 2021 21:39:03 GMT&#x27;) &#125; next()&#125;) 协商缓存 - Etag / If-None-MatchLast-Modified 与 Expires 一样，是基于绝对时间的，一样存在客户端和服务端可能时间不一致的问题。 Etag 与 Last-Modified 使用类似，只是不使用时间作为标识，而是使用一个标记。 未设置的情况，响应头没有 Etag，请求头当然也没有 If-None-Match 响应头设置 Etag，并第一次请求, 此时请求头当然也没有 If-None-Match。这时，文件已经被浏览器缓存了。 1234567// etagrouter.get(&#x27;/test-etag&#x27;, (ctx, next) =&gt; &#123; ctx.set(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;) // 设置 Etag ctx.set(&#x27;Etag&#x27;, &#x27;1234&#x27;) next()&#125;) 下一次请求，可以看到，请求头已经有 If-None-Match 了 请求过来时，服务端会对请求头中的 If-None-Match 该资源在服务器的 Etag 值作对比，这就是代码上控制了。这里假设文件没过期，返回 304。 123456789101112// etagrouter.get(&#x27;/test-etag&#x27;, (ctx, next) =&gt; &#123; ctx.set(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;) // 对请求头中的 If-None-Match 与文件标识作对比, if (true) &#123; // 发现文件时间未更新，返回 304，让浏览器读缓存。 ctx.response.status = 304 &#125; else &#123; // 发现文件时间已更新，更新 Etag ctx.set(&#x27;Etag&#x27;, &#x27;1234&#x27;) &#125;&#125;) 以上强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存。强制缓存生效时，在 devtool 看到的结果是 200。协商缓存则是 304。","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"实现","slug":"实现","permalink":"https://laputaz.github.io/home/tags/%E5%AE%9E%E7%8E%B0/"},{"name":"网络","slug":"网络","permalink":"https://laputaz.github.io/home/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"js基础：实现类算法笔记","slug":"js基础-实现类算法笔记","date":"2020-09-24T17:52:42.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-实现类算法笔记/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"实现类算法","text":"实现类算法 迭代器的实现","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"算法","slug":"算法","permalink":"https://laputaz.github.io/home/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js基础：算法笔记","slug":"js基础-算法笔记","date":"2020-09-24T17:52:42.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-算法笔记/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"最近复习了一下算法，决定记录一下。算法并不是不能记忆。很多时候会发现即使理解了，也写不出来。其实有大量大量的模板，可以进行记忆，形成快速反应，再进行修改。","text":"最近复习了一下算法，决定记录一下。算法并不是不能记忆。很多时候会发现即使理解了，也写不出来。其实有大量大量的模板，可以进行记忆，形成快速反应，再进行修改。 复杂度即输入为 n 时，需要计算的次数： 在坐标轴的对比： 大 O 符号（Big O notation）是用于描述函数渐进行为的数学符号。更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。在数学中，它一般用来刻画被截断的无穷级数尤其是渐近级数的剩余项； bigO 的规则是用最简单的式子来表示趋势的，所以不要纠结例如双循环是 n(n-1) 而不是 n^2 。因为 n(n-1) =&gt; n^2 - n, n^2 是这个式子的主导部分，作为表示法，即 O(n2)。 当数据规模很大的时候，效率的差距还是很明显的。 原理实现类此类算法通常是需要让你实现、复现已有的功能： 迭代器实现 - 让 obj 支持 for of 123456789101112131415161718192021const obj = &#123; a: 1, b: 2, c: 3 &#125;;// 为对象赋予 Symbol.iterator 迭代器方法obj[Symbol.iterator] = function () &#123; const _this = this; const keys = Object.keys(_this); let index = 0; return &#123; next() &#123; return &#123; value: _this[keys[index++]], done: index &gt; keys.length, &#125;; &#125;, &#125;;&#125;;// 输出结果for (let key of obj) &#123; console.log(key);&#125; promise 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// MyPromise.js// 先定义三个常量表示状态const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;// 新建 MyPromise 类class MyPromise &#123; constructor(executor) &#123; // executor 是一个执行器，进入会立即执行 // 并传入resolve和reject方法 try &#123; executor(this.resolve, this.reject); &#125; catch (error) &#123; this.reject(error); &#125; &#125; // 储存状态的变量，初始值是 pending status = PENDING; // 成功之后的值 value = null; // 失败之后的原因 reason = null; // 存储成功回调函数 onFulfilledCallbacks = []; // 存储失败回调函数 onRejectedCallbacks = []; // 更改成功后的状态 resolve = (value) =&gt; &#123; // 只有状态是等待，才执行状态修改 if (this.status === PENDING) &#123; // 状态修改为成功 this.status = FULFILLED; // 保存成功之后的值 this.value = value; // resolve里面将所有成功的回调拿出来执行 while (this.onFulfilledCallbacks.length) &#123; // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空 this.onFulfilledCallbacks.shift()(value); &#125; &#125; &#125;; // 更改失败后的状态 reject = (reason) =&gt; &#123; // 只有状态是等待，才执行状态修改 if (this.status === PENDING) &#123; // 状态成功为失败 this.status = REJECTED; // 保存失败后的原因 this.reason = reason; // resolve里面将所有失败的回调拿出来执行 while (this.onRejectedCallbacks.length) &#123; this.onRejectedCallbacks.shift()(reason); &#125; &#125; &#125;; then(onFulfilled, onRejected) &#123; const realOnFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (value) =&gt; value; const realOnRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : (reason) =&gt; &#123; throw reason; &#125;; // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去 const promise2 = new MyPromise((resolve, reject) =&gt; &#123; const fulfilledMicrotask = () =&gt; &#123; // 创建一个微任务等待 promise2 完成初始化 queueMicrotask(() =&gt; &#123; try &#123; // 获取成功回调函数的执行结果 const x = realOnFulfilled(this.value); // 传入 resolvePromise 集中处理 resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;; const rejectedMicrotask = () =&gt; &#123; // 创建一个微任务等待 promise2 完成初始化 queueMicrotask(() =&gt; &#123; try &#123; // 调用失败回调，并且把原因返回 const x = realOnRejected(this.reason); // 传入 resolvePromise 集中处理 resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;; // 判断状态 if (this.status === FULFILLED) &#123; fulfilledMicrotask(); &#125; else if (this.status === REJECTED) &#123; rejectedMicrotask(); &#125; else if (this.status === PENDING) &#123; // 等待 // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来 // 等到执行成功失败函数的时候再传递 this.onFulfilledCallbacks.push(fulfilledMicrotask); this.onRejectedCallbacks.push(rejectedMicrotask); &#125; &#125;); return promise2; &#125; // resolve 静态方法 static resolve(parameter) &#123; // 如果传入 MyPromise 就直接返回 if (parameter instanceof MyPromise) &#123; return parameter; &#125; // 转成常规方式 return new MyPromise((resolve) =&gt; &#123; resolve(parameter); &#125;); &#125; // reject 静态方法 static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason); &#125;); &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; // 如果相等了，说明return的是自己，抛出类型错误并返回 if (promise2 === x) &#123; return reject( new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;) ); &#125; // 判断x是不是 MyPromise 实例对象 if (x instanceof MyPromise) &#123; // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected // x.then(value =&gt; resolve(value), reason =&gt; reject(reason)) // 简化之后 x.then(resolve, reject); &#125; else &#123; // 普通值 resolve(x); &#125;&#125;module.exports = MyPromise; 实现 new 1234567891011121314function newObject() &#123; var con = [].shift.call(arguments); var obj = Object.create(con.prototype); var res = con.apply(obj, arguments); return res ? res : obj;&#125;function My(a) &#123; return &#123; a, &#125;;&#125;// 使用const a = newObject(My, 1); // &#123; a: 1 &#125; instanceof 123456789101112131415161718const instance_of = (left, right) =&gt; &#123; // 基本的数据类型为false const baseType = [&#x27;number&#x27;, &#x27;string&#x27;, &#x27;boolean&#x27;, &#x27;undefined&#x27;, &#x27;symbol&#x27;]; if (baseType.includes(typeof left)) return false; // 右侧函数的原型 const RP = right.prototype; while (true) &#123; // 出口, left.__proto__.__proto__....的尽头是null, // 并且 null instanceof 任何类型 都不成立, 即使是Object, 下面会说到 if (left === null) &#123; return false; &#125; else if (left === RP) &#123; return true; &#125; // 找不到 ? 把left的值改为它的原型 left = left.__proto__; &#125;&#125;; 数据结构每种数据结构都有优缺点，需要运用在合适的场景才能发挥出最大的优势。不会有哪一种数据结构是万能的。 数组&amp;链表数组：可以根据索引直接查询（一般是连续的内存空间，所以插入的时候需要后挪，插入效率不好） 查询复杂 O(1) 插入复杂最好 O(1)（插入到最后），最坏 O(n)（插入到最前面），平均复杂下来 O(n) 链表：改善数组的插入操作 查询复杂 O(n) 遍历 插入复杂 O(1)，只需要改变指针的指向，常数级操作 链表实现 首先，细粒度每个链表节点的特点 有 value 记录自身。 有 next 指向下一个节点。 整个链表的基本特点 size 长度 head 头指针位置 tail 尾指针 find(index) 查找，从 head 开始遍历 prepend(value) 向头添加节点 append(value) 按顺序加值 pop() 删除并返回最后一个 shift() 删除并返回第一一个 insert(value, index) 向单链表指定位置后插入 remove(index) =&gt; 在单链表中删除一个节点 clear() =&gt; 清空单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// 节点class LinkedNode &#123; constructor(value) &#123; this.value = value; this.next = null; &#125; toString() &#123; return this.value; &#125;&#125;// 链表class LinkedList &#123; constructor(arr = []) &#123; this.size = 0; this.head = null; this.tail = null; if (arr.length) &#123; arr.forEach((v) =&gt; &#123; this.append(v); &#125;); &#125; &#125; // 往最后插入 append(value) &#123; // 创建 node 节点 const node = new LinkedNode(value); // 如果当前的头指向为null, 则当前append的节点作为头 if (!this.head) &#123; this.head = node; this.tail = node; &#125; else &#123; this.tail.next = node; this.tail = node; &#125; this.size += 1; &#125; prepend(value) &#123; // 创建 node 节点 const node = new LinkedNode(value); // 更改头指针的位置 node.next = this.head; this.head = node; this.size += 1; &#125; // 在指定位置后插入 insert(value, index) &#123; // 大于长度，最后插入 if (index &gt;= this.size - 1) &#123; this.append(value); &#125; // 小于1 if (index &lt;= 0) &#123; this.prepend(value); &#125; const node = new LinkedNode(value); // 找到前置节点和后置节点 const &#123; prevNode, nextNode &#125; = this.getPrevNextNodes(index); // 插入 prevNode.next = node; node.next = nextNode; this.size++; &#125; // 删除并返回最后一个 pop() &#123; const node = this.find(this.size - 2); node.next = null; const temp = this.tail; this.tail = node; this.size -= 1; return temp; &#125; shift() &#123; const temp = this.head; this.head = this.head.next; this.size += 1; return temp; &#125; // 删除 remove(index) &#123; // 大于长度，最后插入 if (index &gt;= this.size - 1) &#123; this.pop(); &#125; // 小于1 if (index &lt;= 0) &#123; this.shift(value); &#125; let &#123; prevNode, nextNode &#125; = this.getPrevNextNodes(index); prevNode.next = nextNode.next; this.size--; &#125; // 找到前置节点和后置节点 getPrevNextNodes(index) &#123; let count = 0; let prevNode = this.head; let nextNode = prevNode.next; while (count &lt; index - 1) &#123; prevNode = prevNode.next; nextNode = prevNode.next; count++; &#125; return &#123; prevNode, nextNode, &#125;; &#125; // 找到指定索引的node find(index) &#123; let count = 0; let currentNode = this.head; while (count &lt; index) &#123; currentNode = currentNode.next; count++; &#125; return currentNode; &#125; // 反转 reverse() &#123; let cur = this.head; let pre = null; while (cur) &#123; const temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; this.head = pre; &#125; // 方便打印 toString() &#123; let arr = []; let currentNode = this.head; while (currentNode) &#123; arr.push(currentNode); currentNode = currentNode.next; &#125; return arr.join(&#x27;=&gt;&#x27;); &#125;&#125; 12345678910const list = new LinkedList(); // LinkedList &#123;size: 0, head: null, tail: null&#125;list.append(1); // LinkedList &#123;size: 1, head: LinkedNode, tail: LinkedNode&#125;list.append(2); // LinkedList &#123;size: 2, head: LinkedNode, tail: LinkedNode&#125;list.append(3); // LinkedList &#123;size: 3, head: LinkedNode, tail: LinkedNode&#125;list.head.toString(); // 1list.tail.toString(); // 3list.append(4); // LinkedList &#123;size: 3, head: LinkedNode, tail: LinkedNode&#125;list.reverse();list.toString(); // &#x27;4=&gt;3=&gt;2=&gt;1&#x27;list.insert(2, &#x27;5&#x27;); 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表头。leetcode 206 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; // 定义两个指针 let cur = head; let pre = null; while (cur) &#123; // 记住cur.nuxt,方便cur指针后移 const temp = cur.next; // 将当前节点的next指向它的前置节点 cur.next = pre; // pre后移一个节点 pre = cur; // cur后移一个节点 cur = temp; &#125; return pre;&#125;; 两两交换链表中的节点 leetcode 24 递归法 =&gt; 两个指针，p 和 q，q 指向 p，p 连接后面要交换的子链表 1234567891011const swapPairs = (head) =&gt; &#123; if (head === null || head.next === null) &#123; return head; &#125; let p = head; let q = p.next; let temp = q.next; q.next = p; p.next = swapPairs(temp); return q;&#125;; 迭代法 =&gt; 三个指针，一直交换 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */const swapPairs = (head) =&gt; &#123; if (!head || !head.next) &#123; return head; &#125; let result = head.next; let p = head; let temp = p.next; let fakeHead = new ListNode(-1); while (p.next) &#123; p.next = temp.next; temp.next = p; fakeHead.next = temp; fakeHead = p; p = p.next; if (!p) &#123; break; &#125; // 交换完了之后 temp = p.next; &#125; return result;&#125;; 判断链表是否有环 leetcode 141 标记法，每遍历一个节点，set 记录内存地址。(O(n) 遍历一遍) 12345678910111213141516var hasCycle = function (head) &#123; if (!head || !head.next) &#123; return false; &#125; let p = head; p.flag = 1; while (p != null &amp;&amp; p.next != null) &#123; p = p.next; if (p.flag) &#123; return true; &#125; else &#123; p.flag = 1; &#125; &#125; return false;&#125;; 快慢指针，1 步走和两步走，有环的话肯定会相撞。(O(n) 遍历一遍) 12345678910var hasCycle = function (head) &#123; let p = head; let q = head; while (q != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next.next; if (p === q) return true; &#125; return false;&#125;; 如果要知道环的起点，具体位置，leetcode 142 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var detectCycle = function (head) &#123; let pos = null; if (!head || !head.next) &#123; return pos; &#125; pos = head; let set = new Set(); set.add(pos); while (pos &amp;&amp; pos.next) &#123; pos = pos.next; if (set.has(pos)) &#123; return pos; &#125; set.add(pos); &#125; return null;&#125;; 栈和队列栈：先进后出 查找 O(n) 插入 O(1) 队列：先进先出 查找 O(n) 插入 O(1) leetcode 20，包含大中小括号的字符串，判断字符串是否有效 用进栈出栈解决，最后栈为空。O(n) 最好用 map 把左右括号映射关系存起来。 12345678910111213141516var isValid = function (s = &#x27;&#x27;) &#123; let arr = []; const map = &#123; &#x27;&#125;&#x27;: &#x27;&#123;&#x27;, &#x27;)&#x27;: &#x27;(&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#125;; Array.prototype.forEach.call(s, (v) =&gt; &#123; if (!map[v] || arr[arr.length - 1] !== map[v]) &#123; arr.push(v); &#125; else &#123; arr.pop(); &#125; &#125;); return !arr.length;&#125;; 不断 replace(“()”, “”)消除，一直到为空。但因为 replace 查找的操作也需要遍历，可能时间复杂度会达到 n^2 123456var isValid = function (s = &#x27;&#x27;) &#123; while (s.includes(&#x27;&#123;&#125;&#x27;) || s.includes(&#x27;[]&#x27;) || s.includes(&#x27;()&#x27;)) &#123; s = s.replace(&#x27;&#123;&#125;&#x27;, &#x27;&#x27;).replace(&#x27;[]&#x27;, &#x27;&#x27;).replace(&#x27;()&#x27;, &#x27;&#x27;); &#125; return !s.length;&#125;; leetcode 232，225。用栈实现队列 用一个输入栈和输出栈，当执行取出时，从输出栈输出，若输出栈为空，从输入栈读取过来，再取出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var MyQueue = function () &#123; this.inarr = []; this.outarr = [];&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MyQueue.prototype.push = function (x) &#123; this.inarr.push(x);&#125;;/** * @return &#123;number&#125; */MyQueue.prototype.pop = function () &#123; this.fill(); return this.outarr.pop() || null;&#125;;/** * @return &#123;number&#125; */MyQueue.prototype.peek = function () &#123; this.fill(); return this.outarr[this.outarr.length - 1] || null;&#125;;/** * @return &#123;boolean&#125; */MyQueue.prototype.empty = function () &#123; this.fill(); console.log(this.outarr); if (!this.outarr.length) &#123; return true; &#125; return false;&#125;;/** * @return &#123;boolean&#125; */MyQueue.prototype.fill = function () &#123; if (!this.outarr.length) &#123; while (this.inarr.length) &#123; this.outarr.push(this.inarr.pop()); &#125; &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * var obj = new MyQueue() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.peek() * var param_4 = obj.empty() */ 优先队列 正常进，按照优先级出 实现机制 堆 (查找最大、最小总是 O(1), 插入需要看堆的具体实现) 堆中某个结点的值总是不大于或不小于其父结点的值； 堆总是一棵完全二叉树。(若设二叉树的深度为 h，除第 h 层外，其它各层 (1 ～ h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。) 二叉搜索树 leetcode 703。数据流中第 k 大的元素 保存前 k 个最大值。每次进来一个元素排序依次 O(n*klogk) 123456789var KthLargest = function (k, nums = []) &#123; this.nums = nums; this.k = k;&#125;;KthLargest.prototype.add = function (val) &#123; this.nums.push(val); return this.nums.sort((a, b) =&gt; b - a)[this.k - 1];&#125;; 小顶堆，size = 3, 每次进来一个元素跟最小的比较(O(n))，比顶小，则取顶。比顶大，则删掉顶，加入新元素，重排堆（logk）。则最后为 O(n*logk) leetcode 239。滑动窗口最大值 size=3。 暴力，每次都排序一次 维护大顶堆(删除新元素，查找顶元素), size 为窗口大小 3。重排堆（logk）。复杂度 O(nlogk) 双端队列, 关键在于双端队列记录的是索引，不是实际值 12345678910111213141516171819202122var maxSlidingWindow = function (nums, k) &#123; const deque = []; const res = []; for (let i = 0; i &lt; nums.length; i++) &#123; if (deque.length &amp;&amp; deque[0] &lt;= i - k) &#123; deque.shift(); &#125; // 与最右侧比较 while (deque.length) &#123; if (nums[deque[deque.length - 1]] &lt; nums[i]) &#123; deque.pop(); &#125; else &#123; break; &#125; &#125; deque.push(i); if (i &gt;= k - 1) &#123; res.push(nums[deque[0]]); &#125; &#125; return res;&#125;; 映射和集合哈希表，即，将字符串用哈希函数计算生成 key，再插入值。如何解决哈希碰撞？在每个冲突处构建链表，将所有冲突值链入链表，如同拉链一般一个元素扣一个元素，故名拉链法。 Map 和 Set 都可使用哈希表实现存储，查询插入删除速度为 O(1)。也可以用 Tree 来存储，查询速度为 O(logn)，TreeMap 和 TreeSet 优势在于相对有序。 有效的字母异位词 leetcode 242 排序 O(nlogn) 123456var isAnagram = function (s, t) &#123; /** 转换成数组排序后对比 */ s = [...s].sort(); t = [...t].sort(); return s.join(&#x27;&#x27;) === t.join(&#x27;&#x27;);&#125;; 用 Map 记录，最后比较(大写字母 A-Z 对应的 ASCII 码值是 65-90,小写字母 a-z 对应的 ASCII 码值是 97-122) 12345678910111213141516171819202122232425262728var isAnagram = function (s, t) &#123; /** 转换成数组排序后对比 */ let a = new Map(), b = new Map(); for (charcode of s) &#123; if (a.has(charcode)) &#123; a.set(charcode, a.get(charcode) + 1); &#125; else &#123; a.set(charcode, 1); &#125; &#125; for (charcode of t) &#123; if (b.has(charcode)) &#123; b.set(charcode, b.get(charcode) + 1); &#125; else &#123; b.set(charcode, 1); &#125; &#125; if (a.size !== b.size) &#123; return false; &#125; for ([key, value] of a) &#123; if (b.get(key) !== value) &#123; return false; &#125; &#125; return true;&#125;; 两数之和 (leetcode 1)[https://leetcode-cn.com/problems/two-sum/] 暴力抗法，两层循环 O(n2) 123456789var twoSum = function (nums, target) &#123; for (let i = 0; i &lt; nums.length - 1; i++) &#123; for (let j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] === target) &#123; return [i, j]; &#125; &#125; &#125;&#125;; map 解决 x+y = 9 =&gt; y = 9-x。O(n) 1234567891011var twoSum = function (nums, target) &#123; let hash = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; if (hash[target - nums[i]] !== undefined) &#123; // 保证小的索引在前 return [i, hash[target - nums[i]]].sort((a, b) =&gt; a - b); &#125; hash[nums[i]] = i; &#125; return [];&#125;; 三数之和 leetcode 15 暴力抗法，三层循环 O(n3)。数据大直接超时。。 12345678910111213var threeSum = function (nums) &#123; const arr = []; for (let i = 0; i &lt; nums.length - 2; i++) &#123; for (let j = i + 1; j &lt; nums.length - 1; j++) &#123; for (let k = j + 1; k &lt; nums.length; k++) &#123; if (nums[i] + nums[j] + nums[k] === 0) &#123; arr.push([nums[i], nums[j], nums[k]].sort().join(&#x27;,&#x27;)); &#125; &#125; &#125; &#125; return [...new Set(arr)].map((v) =&gt; v.split(&#x27;,&#x27;));&#125;; 双指针往中间夹 1234567891011121314151617181920212223242526272829303132var threeSum = function (nums) &#123; if (nums.length &lt; 3) &#123; return []; &#125; nums = nums.sort(); const arr = []; for (let i = 0; i &lt; nums.length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) &#123; continue; &#125; let left = i + 1; let right = nums.length - 1; while (left &lt; right) &#123; if (nums[i] + nums[left] + nums[right] === 0) &#123; arr.push([nums[i], nums[left], nums[right]].sort().join(&#x27;,&#x27;)); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123; left += 1; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123; right -= 1; &#125; left += 1; right -= 1; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123; left += 1; &#125; else if (nums[i] + nums[left] + nums[right] &gt; 0) &#123; right -= 1; &#125; &#125; &#125; return [...new Set(arr)].map((v) =&gt; v.split(&#x27;,&#x27;));&#125;; 树、二叉树、二叉搜索树 完全二叉树：每个节点要么没有子节点，要么有两个节点二叉搜索树：左子树所有节点都小于根节点，右子树所有节点都大于根节点，递归左子树也要满足二叉搜索树每次搜索只要找左边或者右边，效率比较高 平均 O(logn)，最坏 O(n)(树不平衡) 验证二叉搜索树 (leetcode 98)[https://leetcode-cn.com/problems/validate-binary-search-tree/] 中序遍历 =&gt; 遍历后的值肯定是升序 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isValidBST = function (root) &#123; // 升序 return inOrder(root).every((v, i, arr) =&gt; &#123; if (i != 0) &#123; return arr[i] &gt; arr[i - 1]; &#125; return true; &#125;);&#125;;var inOrder = function (root) &#123; if (root === null) &#123; return []; &#125; return [...inOrder(root.left), root.val, ...inOrder(root.right)];&#125;; 递归。利用特性，每个节点都大于它的左节点，小于右节点。在左遍历中，最大值为根；右遍历中，最小值为根。 123456789101112// 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.valvar isValidBST = function (root, min = -Infinity, max = Infinity) &#123; // 如果是空节点 if (!root) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (root.val &lt;= min || root.val &gt;= max) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return ( isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max) );&#125;; 二叉树最小共同祖先 leetcode 235 找出路径，路径最后重合的地方就是最近的公共祖先（因为没有 parent 指针，需要从跟开始找）（On） 递归： findPorQ(root, p, q) 找到满足 p 或者 q O(n)12345678var lowestCommonAncestor = function (root, p, q) &#123; // 如果 p 是 q 的祖先或者反过来，那公共祖先就是其中之一 if (root == null || root == p || root == q) return root; let left = lowestCommonAncestor(root.left, p, q); let right = lowestCommonAncestor(root.right, p, q); // 左侧没找到 return left == null ? right : right == null ? left : root;&#125;; 二叉树遍历 指的是根的位子 pre-order 前序 ABDECFG in-order 中序 DBEAFCG post-order 后序 DEBFGCA 有意义的在于，二叉搜索树，中序遍历出来是有序的 递归和分治盗梦空间 =&gt; 层层进入下一层梦，每次只能回到上一层的梦境，层层回来。 递归的模板 123456789101112function recursion(level, param1, param2...) &#123; // 出口，终止条件 if(level &gt; MAX_LEVEL) &#123; return result &#125; // 数据处理 process_data(level, data...) // 继续 self.recursion(level + 1, param1, param2...) // 解决完下一层后 reserve_state(level)&#125; pow(x,n) =&gt; x^n leetcode 50 库函数 pow 和 ** 暴力累乘 O(n) 递归分治，减半规模 O(logn) 123456789101112131415var myPow = function (x, n) &#123; if (n === 0) &#123; return 1; &#125; // n 为负数 if (n &lt; 0) &#123; return 1 / myPow(x, -n); &#125; // n 有余数 if (n % 2) &#123; return x * myPow(x, n - 1); &#125; // 分治 return myPow(x * x, n / 2);&#125;; 求众数（前提是一定有）leetcode 169 暴力，循环每个元素的数量，再循环一次（O(n2)） Map {x: count_x} 排序，重复的次数&gt;n/2 O(nlongn)1234const majorityElement = (nums) =&gt; &#123; nums.sort((a, b) =&gt; a - b); return nums[parseInt(nums.length / 2)];&#125;; 分治 贪心算法每次选当前最好的选择 纸币数最少的配置 但是有一定的条件。不能处处只看眼前。前提是：问题能分成子问题来解决，并且，子问题能递推到最终的最优解（最优子结构）。可遇不可求。 与动态规划的区别在于，动归能保存以前的计算结果，根据以前的结果对当前进行选择。 买股票的最佳时机（只能持有一股，无手续费） leetcode 122 每天如果后一天比前一天高，就买入，第二天卖出(On)123456789var maxProfit = function (prices) &#123; let revenue = 0; for (let i = 0; i &lt; prices.length - 1; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; revenue += prices[i + 1] - prices[i]; &#125; &#125; return revenue;&#125;; 动态规划 广度和深度优先搜索BFS(Breadth-First Search):广度(队列实现) DFS(Depth-First-Search):深度(递归实现) 二叉树层次遍历 (leetcode)[https://leetcode-cn.com/problems/binary-tree-level-order-traversal/] BFS =&gt; 维护一个队列，遍历该队列的在某一层的长度，遍历完出列 1234567891011121314151617181920212223var levelOrder = function (root) &#123; if (root == null) &#123; return []; &#125; let result = []; let arr = [root]; while (arr.length) &#123; const level_size = arr.length; const current = []; for (let i = 0; i &lt; level_size; i++) &#123; const node = arr.shift(); current.push(node.val); if (node.left) &#123; arr.push(node.left); &#125; if (node.right) &#123; arr.push(node.right); &#125; &#125; result.push(current); &#125; return result;&#125;; DFS 深度遍历 =&gt; 递归+1 1234var maxDepth = function (root) &#123; if (root == null) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));&#125;; 二叉树最大深度 leetcode 104 BFS O(n) 直接遍历，level 记录深度 1234567891011121314151617181920var maxDepth = function (root) &#123; if (root == null) return 0; let level = 0; let arr = [root]; // 遍历节点 while (arr.length) &#123; const level_size = arr.length; level += 1; for (let i = 0; i &lt; level_size; i++) &#123; const node = arr.shift(); if (node.left) &#123; arr.push(node.left); &#125; if (node.right) &#123; arr.push(node.right); &#125; &#125; &#125; return level;&#125;; DFS O(n) 直接遍历，level 记录深度 1234567891011121314151617181920var maxDepth = function (root) &#123; if (root == null) return 0; let level = 0; let arr = [root]; // 遍历节点 while (arr.length) &#123; const level_size = arr.length; level += 1; for (let i = 0; i &lt; level_size; i++) &#123; const node = arr.shift(); if (node.left) &#123; arr.push(node.left); &#125; if (node.right) &#123; arr.push(node.right); &#125; &#125; &#125; return level;&#125;; 生成有效括号组合 leetcode 22 DFS =&gt; 2n 个格子，每个格子两个选择。2^2n 改进：剪枝局部不合法，不再递归；left_used,right_used 123456789101112131415161718var generateParenthesis = function (n) &#123; let result = []; _gen(n, 0, 0, &#x27;&#x27;, result); return result;&#125;;var _gen = function (n, left, right, str, result) &#123; if (left === n &amp;&amp; right === n) &#123; result.push(str); return; &#125; if (left &lt; n) &#123; _gen(n, left + 1, right, str + &#x27;(&#x27;, result); &#125; if (right &lt; left) &#123; _gen(n, left, right + 1, str + &#x27;)&#x27;, result); &#125;&#125;; 剪枝搜索的优化策略：找局部最优的一个或者几个分支，淘汰无用的分支脑子里其实就在推演，我如果下这里，对方会怎么下，但是人脑的链路栈是有限的，容易乱。 N 皇后 leetcode 51 用一个 set 记录不可能的格子，下次就不往这边走。关键条件，递归出口：一行最多摆一个。n 个皇后放置在 n×n 的棋盘上，那么每行至少有一个，只有走到最后一行，才会 push 到结果。 123456789101112131415161718192021222324252627282930313233343536373839404142let cols = new Set();// 被占的斜向let pie = new Set();// 被占的斜向let na = new Set();var solveNQueens = function (n) &#123; if (n === 0) &#123; return []; &#125; // 记录结果 let result = []; // 被占的列 _dfs(n, 0, [], result); return result.map(translate);&#125;;// 遍历var _dfs = function (n, row, current_state, result) &#123; // 最后一行 if (row &gt;= n) &#123; result.push(current_state); return; &#125; for (let i = 0; i &lt; n; i++) &#123; // 是否在里面 if (cols.has(i) || pie.has(row + i) || na.has(row - i)) &#123; continue; &#125; cols.add(i); pie.add(row + i); na.add(row - i); _dfs(n, row + 1, [...current_state, i], result); cols.delete(i); pie.delete(row + i); na.delete(row - i); &#125;&#125;;function translate(arr) &#123; return arr.map( (v) =&gt; &#x27;.&#x27;.repeat(v) + &#x27;Q&#x27; + &#x27;.&#x27;.repeat(arr.length - v - 1) );&#125; 二分查找在选择排序的优化里面就有用到。 单调递增或递减（有序） 有界 能够用索引访问 求解平方根 leetcode 6912345678910111213141516171819202122232425var mySqrt = function (x, n = 0) &#123; if (x === 0 || x === 1) &#123; return x; &#125; let left = 0; let right = x; let num = 0; while (left &lt; right) &#123; let mid = (right - left) / 2 + left; if (right - left &lt; 10 ** -10) &#123; num = mid; break; &#125; const res = mid * mid; if (res &gt; x) &#123; right = mid - 1; &#125; else if (res &lt; x) &#123; left = mid + 1; &#125; else &#123; num = mid; break; &#125; &#125; return num.toFixed();&#125;; 字典树 1. 实现字典树 2. 二维网格中的单词搜索问题 位运算计算机用二进制存储和计算，用二进制处理速度较快。异或的特点： 统计位 1 的个数 leetcode 191 转换成二进制，遍历 &amp; n-1, 消除最低位12345678var hammingWeight = function (n) &#123; let count = 0; while (n) &#123; n &amp;= n - 1; count++; &#125; return count;&#125;; 2 的幂次方问题 &amp; 比特位技术问题 leetcode 231 一直模 2 123456789var isPowerOfTwo = function (n) &#123; if (n === 1) &#123; return true; &#125; while (n &gt;= 2) &#123; n /= 2; &#125; return n === 1;&#125;; 二进制位有且只有一个 1 123var isPowerOfTwo = function (n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) === 0;&#125;; N 皇后问题 =&gt; 用位运算 动态规划动态递归。 递归+记忆化 状态定义：opt[n],dp[n],fib[n]… 状态转移：opt[n] = best_of(opt[n-1], opt[n-2]….) 最优子结构 爬楼梯 leetcode 70 回溯 递推 f(n) = f(n-1) + f(n-2)123456789101112var climbStairs = function (n) &#123; if (n &lt;= 2) &#123; return n; &#125; let arr = []; arr[0] = 1; arr[1] = 2; for (let i = 2; i &lt; n; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; return arr[n - 1];&#125;; 三角形自顶向下的最小路径和 leetcode 120 递推：min = mini[j] = triangle[i][j] + Math.min(mini[j], mini[j + 1]); 12345678910var minimumTotal = function (triangle) &#123; const mini = triangle[triangle.length - 1]; for (let i = triangle.length - 2; i &gt;= 0; i--) &#123; for (let j = 0; j &lt; triangle[i].length; j++) &#123; mini[j] = triangle[i][j] + Math.min(mini[j], mini[j + 1]); &#125; &#125; return mini[0];&#125;; 乘积最大子数组 leetcode 152 股票买卖 并查集 岛屿个数&amp;朋友圈 leetcode 200 染色法，找到一个 1 后，遍历周围的所有 1，把他变成 0。完成一次遍历记录为 1 个岛屿 并查集，遍历节点，相邻的融合，最后看有几个集合 LRU cache缓存特点： 类似于记忆：容量体积小，会丢，要一直记住就要记在笔记本。 类似于钱包：经常要用的就要带在钱包，否则放在储物柜 CPU 缓存结构： LRU 指的是缓存替换算法 Least recently used。一般用双向链表。只查最前（最常用元素）和最后（最久没使用的元素）。 实现 LRU cache leetcode 146 布隆过滤器 Bloom Filter将一个元素经过计算函数计算，散列在二进制向量中。用于检测元素是否在一个集合中。如果未检测到，那元素肯定不存在；如果检测到了，那元素可能存在。缺点是误识别和删除困难。 如图：A 和 E 先插入到布朗过滤器。 A 发现是存在的 C 发现没有完全重合的元素，说明是不存在的。 B 发现有重合部分，会误判为存在，但其实不存在 B 常用的记忆模板常用的几种算法思路模板，要记下来，但不是硬套。有助于整理思路。 1. 递归 123456789101112function recursion(level, param1, param2) &#123; // recursion terminator if (level &gt; MAX_LEVEL) &#123; return &#125; // process logic in current level process_data(levle, data....) // drill down recursion(level+1, p1, p2 ...) // reverse current level status optional reverse_state(level)&#125; 2. DFS =&gt; 递归 12345678visited = set()def dfs(node, visited) &#123; visited.add(node) // process logic in current level for next_node in node.childrens(); if not next_node in visited: dfs(next_node, visited)&#125; 3. BFS 123456789101112def BFS(graph, start, end) : queue = [] queue.append(start) visited.add(start) while queue: node = queue.pop() visited.add(node) process(node) nodes = node.get_releated_nodes() queue.push(node) 4. 二分查找 123456789left, (right = 0), arr.length - 1while left &lt; right: mid = left + (right - left) / 2 if arr[mid] === target: break oretuen result if arr[mid] &lt; target: left = mid + 1 else: right = mid - 1 5. DP 动规 12345678910111213141516// 状态定义dp = new int[m + 1][n + 1]()// 初始状态d[0][0] = xd[0][1] = y// DP 状态推导for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= m; j++) &#123; d[i][j] = min(dp[i-1][j], dp[i][j-1], etc.) &#125;&#125;// 返回结果return dp[m][n] 以上看到题目的时候，首先要想，最蠢的办法是什么。 一般来说，最简单的暴力解法就是递归、循环、穷举，这些方法的事件空间复杂度往往会很高。 然后再想有什么数据结构可以解决，一般会比暴力抗法事件复杂度低。 最后再进行边角的优化，剪枝、缓存等等，减少一定的量级。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"算法","slug":"算法","permalink":"https://laputaz.github.io/home/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"浏览器：浏览器工作原理笔记","slug":"浏览器-浏览器工作和js执行原理笔记","date":"2020-09-23T16:10:01.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"浏览器-浏览器工作和js执行原理笔记/","link":"","permalink":"https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","excerpt":"最近看了浏览器原理，这里记录一下细节。浏览器原理可以把一系列知识串联起来。","text":"最近看了浏览器原理，这里记录一下细节。浏览器原理可以把一系列知识串联起来。 目录宏观视角下的浏览器网页渲染流程js 执行机制chrome 垃圾回收页面循环系统页面优化 宏观视角下的浏览器进程和线程1. 线程 VS 进程 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。 总结来说，进程和线程之间的关系有以下 4 个特点。 进程中的任意一线程执行出错，都会导致整个进程的崩溃。 线程之间共享进程中的数据。 当一个进程关闭之后，操作系统会回收进程所占用的内存。 进程之间的内容相互隔离。 Chrome 进程架构最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。 浏览器进程。主要负责浏览器界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。主进程和网络进程是共享的。 网页渲染流程导航流程 用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL 用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得 浏览器进程构建请求行信息，会通过进程间通信（IPC）将 URL 请求发送给网络进程GET /index.html HTTP1.1 网络进程获取到 URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接 200 返回；否则，进入网络请求过程 网络进程请求 DNS 返回域名对应的 IP 和端口号，如果之前 DNS 数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的 IP 和端口号，如果没有端口号，http 默认 80，https 默认 443。如果是 https 请求，还需要建立 TLS 连接。 Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。 TCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层 底层通过物理网络传输给目的服务器主机 目的服务器主机网络层接收到数据包，解析出 IP 头部，识别出数据部分，将解开的数据包向上传输到传输层 目的服务器主机传输层获取到数据包，解析出 TCP 头部，识别端口，将解开的数据包向上传输到应用层 应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态 code301 或者 302，同时在请求头的 Location 字段中附上重定向地址，浏览器会根据 code 和 Location 进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：``Cache-Control:Max-age=2000`响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 数据传输完成，TCP 四次挥手断开连接。如果，浏览器或者服务器在 HTTP 头部加上如下信息，TCP 就一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度Connection:Keep-Alive 网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到文档准备渲染 浏览器进程获取到通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页 渲染流程导航流程结束后，现在是渲染进程的主场 构建 DOM 树。 构建 DOM 树的输入内容是 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。 样式计算（Recalculate Style）。 当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。document.styleSheets 可以查看。 转换样式表中的属性值，使其标准化。如 font-size:bold =&gt; font-size:700。 计算出 DOM 树中每个节点的具体样式。（层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。） 布局阶段。（计算出 DOM 树中可见元素的几何位置） 创建布局树。只包含可见元素布局树。 布局计算。计算布局树节点的坐标位置。 分层。渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。devtool Layers 可以看到。 拥有层叠上下文属性的元素会被提升为单独的一层。 需要剪裁（clip）的地方也会被创建为图层。（overflow） 图层绘制。 为每个图层生成绘制列表，并将其提交到合成线程。 绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表。 栅格化（raster）操作。 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。 合成和显示。一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。 全流程 注意： css 与 js 的加载会阻塞布局树的生成，因为布局树需要 css 配合计算完成样式。 重排： 触发重新布局，解析之后的一系列子阶段，这个过程就叫重排 重绘： 并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。 js 执行机制JavaScript 的执行机制：先编译，再执行。变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。 变量提升变量提升，是指在 JavaScript 代码编译时，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。默认值 undefined。 执行上下文执行上下文是 JavaScript 执行一段代码时的运行环境。在执行上下文中存在一个变量环境的对象（Viriable Environment）。 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。 调用栈又称执行上下文栈。调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。例如没有出口的递归。 作用域作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。 es6 之前： 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。 es6 新增： 块级作用域 块级作用域的实现 =&gt; 词法环境函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。块级作用域编译的时候不会把内部的 let 放到词法环境，而是在执行阶段。当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出。 123456789101112131415function foo() &#123; var a = 1; let b = 2; &#123; let b = 3; var c = 4; let d = 5; console.log(a); console.log(b); &#125; console.log(b); console.log(c); console.log(d);&#125;foo(); 作用域链在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。 词法作用域词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。 闭包在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。 闭包的作用： 私有化变量 12345678function Foo(name) &#123; this.getName = function () &#123; return name; &#125;;&#125;var foo = new Foo(&#x27;luckyStar&#x27;);console.log(foo.name); // =&gt; undefinedconsole.log(foo.getName()); // =&gt; &#x27;luckyStar&#x27; 柯里化，即简化函数的参数。例如判断模式是 jj 的字符串 123456789101112131415function check(reg, text) &#123; return reg.test(text);&#125;check(/jj/, &#x27;jj&#x27;); // truecheck(/jj/, &#x27;tt&#x27;); // false//可以直接写为function curringCheck(reg) &#123; return function (text) &#123; return reg.test(text); &#125;;&#125;let checkFunc = curringCheck(/jj/);checkFunc(&#x27;jj&#x27;); // truecheckFunc(&#x27;js&#x27;); // false this this 指向 chrome 垃圾回收在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。 栈内存回收： 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。下移后，原执行上下文便会变成无效内存，下一次有执行上下文进栈时便会直接覆盖。 堆内存回收：代际假说。有以下两个特点： 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问； 第二个是不死的对象，会活得更久。 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。 副垃圾回收器，主要负责新生代的垃圾回收。 主垃圾回收器，主要负责老生代的垃圾回收。 不论什么类型的垃圾回收器，它们都有一套共同的执行流程。 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。 副垃圾回收器 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。 主垃圾回收器 标记 - 清除（Mark-Sweep）的算法。遍历调用栈中不可触达的对象，然后清除。 全停顿 一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。 页面循环系统每个渲染进程都有一个主线程，渲染引擎和 JS 引擎都是在该线程执行的。每个渲染进程都有一个主线程，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。这就需要一个系统来统筹调度这些任务，消息队列和事件循环系统。 消息队列：可以存放要执行的任务。也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。 渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息。 消息队列的两个问题： 如何处理高优先级的任务。为了适应效率和实时性，引入了微任务。通常把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。 如何解决单个任务执行时长过久的问题可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。 setTimeout除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表（延迟队列）。处理完主消息队列中的一个任务之后，会根据发起时间和延迟时间计算出到期延迟队列的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，会回到主消息队列。 如果当前任务执行时间过久，会影响定时器任务的执行。例如有个 for 循环任务阻塞住了主消息队列的执行。 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒 延时执行时间有最大值。如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。 使用 setTimeout 设置的回调函数中的 this 不符合直觉，如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因： 使用 requestAnimationFrame 不需要设置具体的时间，它会在一帧（一般是 16ms）间隔内根据选择浏览器情况去执行相关动作。requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销 同步回调和异步回调回调函数：将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。 同步回调： 在主函数返回之前执行，即为同步回调。同步回调就是在当前主函数的上下文中执行回调函数。 123456789let callback = function () &#123; console.log(&#x27;i am do homework&#x27;);&#125;;function doWork(cb) &#123; console.log(&#x27;start do work&#x27;); cb(); // 在主函数返回之前执行，同步回调 console.log(&#x27;end do work&#x27;);&#125;doWork(callback); 异步回调: 123456789let callback = function () &#123; console.log(&#x27;i am do homework&#x27;);&#125;;function doWork(cb) &#123; console.log(&#x27;start do work&#x27;); setTimeout(cb, 1000); // 异步回调 console.log(&#x27;end do work&#x27;);&#125;doWork(callback); 这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。 XMLHttpRequest 异步回调运作机制 网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。 宏任务 和 微任务普通消息队列和延迟执行队列中的任务都统称为“宏任务”。 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。 产生微任务有两种方式： 使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来操作节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务 promise 在当前宏任务快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。 如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。 Event Loop 中，每一次循环称为 tick，每一次 tick 的任务如下： 执行栈选择最先进入队列的宏任务（一般都是 script），执行其同步代码直至结束；检查是否存在微任务，有则会执行至微任务队列为空 宏任务 微任务 具体事件 1. script 2. setTimeout/setInterval 3. UI rendering/UI 事件 4. postMessage，MessageChannel 5. setImmediate，I/O（Node.js） 1. Promise 2. MutaionObserver 3. Object.observe（已废弃；Proxy 对象替代）4. process.nextTick（Node.js） 页面优化白屏和优化 浏览器渲染页面包括构建 DOM，构建 CSSOM, 构建布局树，渲染等。白屏的瓶颈主要体现在： 下载 html 文件（阻塞 DOM 的合成） 下载 CSS 文件（阻塞 CSSOM 的合成） 下载 JavaScript 文件 执行 JavaScript 3、4 =&gt; 在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。） 策略 去掉、减少多余网络请求 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。 对于依赖数据的 html,采用预渲染和服务端渲染，减少在前端再次请求。 减少请求的文件大小 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 Webpack 的代码切割 异步请求 将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。 优化网络请求 CDN 障眼法 对于依赖数据的 html,采用骨架屏和 loading 为什么 CSS 动画比 JavaScript 高效显示器是怎么显示图像的： 每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都缓冲区，显示器每秒固定读取 60 次缓冲区中的图像，并将读取的图像显示到显示器上。 动画的效果：在滚动或者缩放操作等动画操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的缓冲区。 正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 [刷新率] 张图片到显卡的后缓冲区 把渲染流水线生成的每一副图片称为一帧。 把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。 要解决卡顿问题，就要解决每帧生成时间过久的问题。 通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。 能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。 能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容。 比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。 123.box &#123; will-change: transform, opacity;&#125; 这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"浏览器","slug":"浏览器","permalink":"https://laputaz.github.io/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"js基础：排序算法总结","slug":"js基础-排序算法总结","date":"2020-09-20T21:22:47.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js基础-排序算法总结/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"各样的排序算法，每次都忘记，直接手写一遍，加强记忆。","text":"各样的排序算法，每次都忘记，直接手写一遍，加强记忆。 demohttps://github.com/laputaz/sort 战前准备定义一堆数组 123let arrs = [ 1, 356, 7, -234, 7, 24, 78678, 2342, 8, 2, 9, -56, 35, -67, 894534, 85,] 注意注意，我们不要一开始就纠结于循环的时候，是写 &lt; 呢，还是 &lt;= 。这无非就是多算一次，我们只有按照思路写出来之后再去调试，不要想着一蹴而就。 分类常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 相关概念: 稳定性：如果两个相同的数，排序之后相对位置不变，那就是稳定的。 时间复杂度：对排序数据的总的操作次数。一般是规模在 n 时，需要进行的操作次数，用 n 为变量的表达式表示。 空间复杂度：是指执行时所需存储空间度量，也是数据规模 n 的函数。 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到排序完成。 代码：（双循环，一开始循环到底，每冒泡完一遍，-1） 1234567891011121314151617//冒泡type升降序true升const bubble = (arr, type = true) =&gt; &#123; const length = arr.length // count 可以理解为有序区和无序区的分界点 let count = 1 // 循环的次数 while (count &lt; length - 1) &#123; // 从第一个元素开始 for (let i = 0; i &lt; length - count; i++) &#123; if ((type &amp;&amp; arr[i] &gt; arr[i + 1]) || (!type &amp;&amp; arr[i] &lt; arr[i + 1])) &#123; ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] &#125; &#125; count++ &#125; return arr&#125; 效果： 冒泡排序的优化: 外层循环优化：增加一个标志位，如果在一次外循环的冒泡中，发现没有一次交换，说明已经是有序的了，标志位置为 true,下次循环开始时直接返回。不用继续往下走了。 12345678910111213141516171819202122232425// 冒泡之外循环优化const bubble = (arr, type = true) =&gt; &#123; const length = arr.length // count 可以理解为有序区和无序区的分界点 let count = 1 // 循环的次数 while (count &lt; length - 1) &#123; // 终止条件 let flag = false // 从第一个元素开始 for (let i = 0; i &lt; length - count; i++) &#123; if ((type &amp;&amp; arr[i] &gt; arr[i + 1]) || (!type &amp;&amp; arr[i] &lt; arr[i + 1])) &#123; ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] flag = true &#125; &#125; // 未发生交换，直接结束 if (!flag) &#123; console.log(count) // 把次数打印出来 break &#125; count++ &#125; return arr&#125; 内循环优化：记住最后一次发生交换的位置，那么这个位置就是有序区和无序区的分水岭，下一次就不用再继续往后循环了。 12345678910111213141516171819202122232425262728293031323334// 冒泡之内循环优化let bubble = (arr, type = true) =&gt; &#123; const length = arr.length // count 可以理解为有序区和无序区的分界点 let count = 1 // 最后一次发生交换的index, 初始是最后一个 let lastExchangeIndex = length - count // 记录位置 let pos = 0 // 循环的次数 while (count &lt; length - 1) &#123; // 终止条件 let flag = false // 从第一个元素开始 for (let i = 0; i &lt; Math.min(length - count, lastExchangeIndex); i++) &#123; if ((type &amp;&amp; arr[i] &gt; arr[i + 1]) || (!type &amp;&amp; arr[i] &lt; arr[i + 1])) &#123; ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] flag = true // 记录最后一次交换的位置 pos = i &#125; &#125; // 只循环到无序区终点 lastExchangeIndex = Math.min(length - count, pos) console.log(&#x27;lastExchangeIndex&#x27;, lastExchangeIndex) // 未发生交换，直接结束 if (!flag) &#123; console.log(count) // 把次数打印出来 break &#125; count++ &#125; return arr&#125; 由此可见: 冒泡最好的情况是一次都不用交换，只进行一次外循环+一次内循环，遍历了 n 个元素 O(n) 冒泡最坏的情况是每一次都交换，复杂度为 O(n2) 问题来了：冒泡最坏的情况，严格来说应该是 n + (n - 1) + (n - 2) + … 1 次，为什么说是 O(n2)呢？ 先来看看 Big O 到底是什么： 大 O 符号（Big O notation）是用于描述函数渐进行为的数学符号。更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。在数学中，它一般用来刻画被截断的无穷级数尤其是渐近级数的剩余项； 根据高中知识，其实 n + (n - 1) + (n - 2) + … 1 是累加，可以写成 n(n+1) / 2，进一步转变为 n^2 * 1/2 + n/2。在这个式子中，当 n 足够大时，对结果起主导作用的就是 n^2。而 bigO 的规则是用最简单的式子来表示趋势的，那么用 n^2 这个主导的部分作为表示法，即 O(n2)。 在坐标轴上表示出来就很明显了，n(n+1) / 2 和 n^2 在数量够大的时候是趋近的。 选择排序 初始已排序区为空，全都是未排序区 每次遍历一遍，找到未排序区的最大/最小值，放在已排序区的末尾 循环 代码：（外循环为未排序区长度，内循环找最大值） 123456789101112131415const selectSort = (arr, type = true) =&gt; &#123; let len = arr.length for (let i = 0; i &lt; len; i++) &#123; // 未排序区的第一个索引 let mIdx = i for (let j = i; j &lt; len; j++) &#123; if (arr[j] &lt; arr[mIdx]) &#123; // 找到最大值的 index mIdx = j &#125; &#125; ;[arr[mIdx], arr[i]] = [arr[i], arr[mIdx]] &#125; return type ? arr : arr.reverse()&#125; 结果 选择排序优化 由于我们假定了初始左半部分是已排序区，右半部分为未排序区，如图： 那其实，我们假定有两个有序区就好了 每一次遍历无序区，将最小值放在左侧，最大值放在右侧，这样可以减少循环次数。 代码: 12345678910111213141516171819202122232425262728const selectSort = (arr, type = true) =&gt; &#123; let len = arr.length let left = 0 // 无序区左边界 let right = len - 1 // 无序区右边界 while (left &lt; right) &#123; let min = left let max = right for (let i = left; i &lt;= right; i++) &#123; //找到最大max, 最小 min if (arr[min] &gt; arr[i]) &#123; min = i &#125; if (arr[max] &lt; arr[i]) &#123; max = i &#125; // 交换 if (arr[min] &lt; arr[left]) &#123; ;[arr[min], arr[left]] = [arr[left], arr[min]] &#125; if (arr[max] &gt; arr[right]) &#123; ;[arr[max], arr[right]] = [arr[right], arr[max]] &#125; &#125; left++ right-- &#125; return type ? arr : arr.reverse()&#125; 效果 选择排序最好和最坏都得 O(n2), 只是优化后稍微好了一点点 插入排序 起始有序区是空的，剩余是无序区 取出无序区的第一个元素 遍历有序区，插入到有序区指定位置 其实和选择排序刚好反过来，选择排序是先在无序区比较出最大/小值，再插入到有序区末尾。而插入排序是取出无序区第一个元素，再在有序区看看排到第几位。类似于打牌的时候整理牌。 代码 12345678910111213141516// 直接插入排序const insert = (arr, type) =&gt; &#123; const len = arr.length // 取出无序区第一个，i记录无序区索引最前端 for (let i = 1; i &lt; len; i++) &#123; // 遍历有序区，找到合适的位置，再取出i, 插入 for (let j = 0; j &lt; i; j++) &#123; if ((arr[j] &gt; arr[i] &amp;&amp; type) || (arr[j] &lt; arr[i] &amp;&amp; !type)) &#123; arr.splice(j, 0, arr.splice(i, 1)[0]) // 插入后就结束当次循环了 break &#125; &#125; &#125; return arr&#125; 上面是从有序区从左到右查找的过程，其实也可以从右往左查找： 123456789101112131415function insertSort(arr) &#123; let length = arr.length for (let i = 1; i &lt; length; i++) &#123; let temp = arr[i] let j = i for (; j &gt; 0; j--) &#123; if (temp &gt;= arr[j - 1]) &#123; break // 当前考察的数大于前一个数，证明有序，退出循环 &#125; arr[j] = arr[j - 1] // 将前一个数复制到后一个数上 &#125; arr[j] = temp // 找到考察的数应处于的位置 &#125; return arr&#125; 直接插入排序最好是 O(n), 即有序的序列，最坏还是双循环 O(n2)需要额外一个空间存储移动的元素，空间复杂度 O(1) 插入排序优化-希尔排序 插入排序有两个痛点： 当数组相对有序的时候，速度会快很多，因为插入的比较次数少了。 当数组规模很小的时候，速度会快很多 利用这两个痛点，就有了希尔排序。 按照一定的跨度，将数组拆成几个子数组 对每个子数组使用插入排序 减少跨度，再将数组拆成几个子数组 一直到跨度为 1，这个时候就是对自身执行插入排序了 也就是让将数组拆成小的规模进行插入排序，再将子数组结合起来，形成一个规模比上个阶段大一点的“相对有序”的数组（粗略调整），再执行插入排序。 将数组拆成小的规模的方式，会有一个分组的跨度。这个跨度就叫希尔增量。 例如长度为 8 的数组：第一次分组时，分为 [0,4], [1,5], [2,6], [3,7]一共 4 组，跨度为 4第二次分组时，跨度为 2，分为 [0,2,4,6], [1,3,5,7]一共 2 组，跨度为 2第三次分组时，跨度为 2，分为 [0，1，2，3，4，5，6，7]一共 1 组，跨度为 1 希尔增量，可不是只有一直除以 2 那么简单。它是一个数学问题。这里为了简单还是一直除以 2。 代码： 12345678910111213141516171819202122//希尔排序var arr = [1, 2, 3, 41, 4, 34, 0, 76, 87]// shellSortconst shellSort = (arr, type) =&gt; &#123; const len = arr.length let gap = Math.floor(len / 2) while (gap &gt;= 1) &#123; for (let i = gap; i &lt; len; i++) &#123; let temp = arr[i] let j = i for (; j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]; j = j - gap) &#123; arr[j] = arr[j - gap] &#125; arr[j] = temp &#125; gap = Math.floor(gap / 2) &#125; return arr&#125;console.log(shellSort(arr)) 网络上的文章很不负责任的点在于，只解释了分组的概念，然后就仍一段代码给你，完全不解释代码的思路，看着就生气。 首先，上面这段代码的比较思路是从右往左第二，是遍历每个元素，判断每个元素在哪个分组中，并不是一次性将分组比较完，而是先比较分组一的前面一部分，在比较分组二的前一部分，直到遍历完所有分组的前一部分；再遍历第一个分组的第二部分，第二个分组的第二部分，以此类推。 插入排序优化-二分查找插入排序 为了减少插入的比较次数，在插入的过程引入二分查找法。二分查找的关键在于中位数。代码: 12345678910111213141516171819202122232425262728293031323334353637// 优化插入排序// 二分查找const halfInsert = (arr, type = true) =&gt; &#123; const len = arr.length let mid, low, high, pos // 在有序区内用二分法查找位置 for (let i = 1; i &lt; len; i++) &#123; // 有序区最低位 low = 0 // 有序区最高位 high = i - 1 while (high &gt; low) &#123; // 找到中位, 取整 mid = parseInt((low + high) / 2) // 刚好等于中位时，记录下来，结束循环，最后要插到他后边 if (arr[i] === arr[mid]) &#123; pos = mid break // 落在中位以左，将中位左侧的元素置位最高位，往左侧继续寻找 &#125; else if (arr[i] &lt; arr[mid]) &#123; high = mid - 1 // 落在中位以右，将中位右侧的元素置位最低位，往右侧继续寻找 &#125; else &#123; low = mid + 1 &#125; &#125; // 循环要么找到相等的了，要么一直循环到 high === low if (high === low) &#123; pos = arr[i] &lt; arr[low] ? low : low + 1 &#125; // 取出 let temp = arr.splice(i, 1)[0] // 插入 arr.splice(pos, 0, temp) &#125; return type ? arr : arr.reverse()&#125; 效果 快速排序快排主要有两部分，分段(Partition)和递归(Recursive)。 首先要找一个数字作为基准。为了方便，一般选择第 1 个数字作为基准 把这个待排序的数列中小于基准的元素移动到待排序的数列的左边，把大于基准的元素移动到待排序的数列的右边。 递归 代码 123456789101112131415161718192021//快速排序var arr = [1, 2, 3, 41, 21, 34, 23, 34, 0]const quicksort = (arr) =&gt; &#123; if (arr.length &lt;= 1) &#123; return arr &#125; let left = [] let right = [] const base = arr[0] for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt;= base) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return [...quicksort(left), base, ...quicksort(right)]&#125;console.log(quicksort(arr)) 效果 快速排序优化 上面这种写法有两个问题： 用了新数组 left 和 right，数据量很大的时候，占用内存会很大，空间复杂度很高 没有递归优化，数据量大的时候调用栈过多，容易堆栈溢出 解决： 使用交换的形式，而不是开辟新数组 递归优化，减少递归深度（注意不是尾递归） 当数组是正序或者倒序的时候，性能会比较差。因为比较次数是固定的，正序或者倒序的数组，会导致某一端的调用栈过深。所以优化 pivot 的取值很重要。平衡的分区可以达到 O(nlogn) 而不是最坏的 O(n2) 扫描一下整个数组，计算出一个中间值作为 pivot，让分区平衡 代码 1234567891011121314151617181920212223242526272829303132333435// start 为待排序的起点，end为待排序终点const quickSort = (arr, left, right) =&gt; &#123; const leftIndex = left ?? 0 const rightIndex = right ?? arr.length - 1 if (leftIndex &lt; rightIndex) &#123; let partitionIndex = partition(arr, leftIndex, rightIndex) quickSort(arr, leftIndex, partitionIndex - 1) quickSort(arr, partitionIndex + 1, rightIndex) &#125; return arr&#125;//！ 交换方法一：先对比交换其他元素，最后再交换基准到中间。const partition = (arr, left, right) =&gt; &#123; // 以左侧为基准 let pivot = left // 左右指针 let i = left, j = right while (i &lt; j) &#123; // 从右往左 while (arr[j] &gt;= arr[pivot] &amp;&amp; i &lt; j) &#123; j-- &#125; // 从右往左 while (arr[i] &lt;= arr[pivot] &amp;&amp; i &lt; j) &#123; i++ &#125; ;[arr[i], arr[j]] = [arr[j], arr[i]] &#125; // 交换基准到中间 ;[arr[pivot], arr[i]] = [arr[i], arr[pivot]] // 返回基准最后的位置 return i&#125; 这就是双哨兵法 为什么要从右边开始呢，因为从右开始，直到停下来，会出现： 没有一个比基准小的，停下来的位置刚好是左哨兵和基准，最后就是左哨兵等于右哨兵等于基准，不用交换，整个右边都比基准大 最后停下来的位置不是基准，而是中间的某个元素。 如果最后移动的是右哨兵（说明上一步已经让左右哨兵交换过了），此时停止位一定是比基数小的，停止位右边的所有数都比基数大。这个时候交换哨兵和基数，可以保证左边都是小的，右边都是大的。 如果最后移动的是左哨兵，此时右哨兵在的位置肯定也是比基数小的，因为右哨兵停下来的位置就是第一个比基数小的位置。那么停止位右边的数都比基数大，左边都比基数小，同理。 例子：可以用 6，1，2，7，9 走走看，从左往右的话，7 和 6 互换，就是错的。 从右往左可以保证最后停下来的数要小于基数，从左往右可能会出现停下的数大于基数的情况。 递归优化，减少递归深度 把入口代码改成 123456789// start 为待排序的起点，end为待排序终点const quickSort = (arr, left, right) =&gt; &#123; let pivot = left while (left &lt; right) &#123; pivot = partition(arr, left, right) quickSort(arr, left, pivot - 1) left = pivot + 1 &#125;&#125; 这种方法相当于在一个调用内尽可能多地调用自身。增加广度，减少深度。并不算尾递归调用。看这里 =&gt; 另外的优化点 扫描一下整个数组，计算出一个中间值作为 pivot，让分区平衡分割策略：随机取数法和三数取中。其实都是为了保证分割相对平衡，而不是严重失衡。 归并排序把数组一直对半划分，划分到最小粒度的时候，开始进行两两有序数组的合并。 把长度为 n 的输入序列分成两个长度为 n/2 的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 归并排序始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。 代码 123456789101112131415161718192021222324252627282930313233//归并排序const merge = (left, right) =&gt; &#123; let arr = [] // 两个数组都有长度时 while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; arr.push(left.shift()) &#125; else &#123; arr.push(right.shift()) &#125; &#125; if (left.length) &#123; arr = [...arr, ...left] &#125; if (right.length) &#123; arr = [...arr, ...right] &#125; return arr&#125;// 归并const mergeSort = (arr, type) =&gt; &#123; let len = arr.length // 长度小于2，直接返回 if (len &lt; 2) return arr // 切分 let mid = Math.floor(len / 2) let left = arr.slice(0, mid) let right = arr.slice(mid) // 递归 return type ? merge(mergeSort(left), mergeSort(right)) : merge(mergeSort(right), mergeSort(left))&#125; 计数排序计数排序要求输入的数据必须是有确定范围的整数。O(n+k) 找出最大最小值 建立一个长度为最大值的统计数组，每项数字都为 0 遍历原始数组，将值作为索引，元素出现次数作为值 遍历统计数组，push 进出现次出个元素，索引作为值 计数排序的缺点在于浪费空间，例如一个数组，大部分值都落在 1-1000，只有一两个在 10000+，那么 1000~10000 中间的存储就被浪费了。亦或者大部分元素都在 100~200，那 0~100 的部分就被浪费了。所以优化点在于不知要拿到最大值，还要拿到最小值。 代码： 1234567891011121314151617function countingSort(arr, maxValue) &#123; // 建立统计数组 var bucket = newArray(maxValue + 1).fill(0), sortedIndex = 0, arrLen = arr.length, bucketLen = maxValue + 1 for (var i = 0; i &lt; arrLen; i++) &#123; bucket[arr[i]]++ &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j bucket[j]-- &#125; &#125; return arr&#125; 桶排序桶排序是计数排序的升级版。 根据自定规则划分 n 个桶 每个桶内执行排序(有可能再使用别的排序算法,或是以递归方式继续使用桶排序进行排) 合并桶 规则的指定很重要，需要尽量保证每个桶之间是均匀的，避免出现空桶或者数量差异极大的桶。因为差异极大的话跟没分桶有什么区别？桶的思路就是用空间换取时间。数要相对均匀分布，桶的个数也要合理设计。其实我觉得应该叫分类排序。 假设排序的序列取值范围为 [0, 99]，我们选定十位数作为桶的映射函数 123456789101112131415161718192021222324252627282930function BucketSort(list) &#123; const buckets = [] for (let i = 0; i &lt; list.length; i++) &#123; const digit = parseInt(list[i] / 10) if (!buckets[digit]) &#123; buckets[digit] = [] &#125; insert(buckets[digit], list[i]) &#125; let p = 0 for (let i = 0; i &lt; buckets.length; i++) &#123; if (buckets[i]) &#123; while (buckets[i].length) &#123; list[p++] = buckets[i].shift() &#125; &#125; &#125; return list&#125;function insert(list, n) &#123; let i = list.length for (; i &gt; 0; i--) &#123; if (list[i - 1] &gt; n) &#123; list[i] = list[i - 1] &#125; else &#123; break &#125; &#125; list[i] = n&#125; 基数排序原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 例如有 1arr = [6, 4322, 432, 344, 55] 前面补上 0 ，变为 1arr = [0006, 4322, 0432, 0344, 0055] 第一次,根据个位数分桶。按照顺序来进行回收：结果：[4322,432,344,55,6] 第二次，根据十位数分桶按照顺序来进行回收：结果：[6,4322,432,344,55] 第三次，根据百位数分桶按照顺序来进行回收：结果：[6,55,4322,344,432] 第四次，根据千位数分桶按照顺序来进行回收：结果：[6,55,344,432,4322] 代码 12345678910111213141516171819202122// 省略获取位数的步骤，直接传参function RadixSort(list, maxDigit) &#123; const counter = [] for (let digit = 0, mod = 10; digit &lt; maxDigit; digit++, mod *= 10) &#123; for (let i = 0; i &lt; list.length; i++) &#123; const radix = parseInt((list[i] % mod) / (mod / 10)) if (!counter[radix]) &#123; counter[radix] = [] &#125; counter[radix].push(list[i]) &#125; let p = 0 for (let i = 0; i &lt; counter.length; i++) &#123; if (counter[i]) &#123; while (counter[i].length) &#123; list[p++] = counter[i].shift() &#125; &#125; &#125; &#125; return list&#125; 堆排序利用大小顶堆的特性，移动元素","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"算法","slug":"算法","permalink":"https://laputaz.github.io/home/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://laputaz.github.io/home/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"js-哪些场景不适合箭头函数","slug":"js-哪些场景不适合箭头函数","date":"2020-09-05T12:02:25.000Z","updated":"2024-11-26T03:47:07.891Z","comments":true,"path":"js-哪些场景不适合箭头函数/","link":"","permalink":"https://laputaz.github.io/home/js-%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8D%E9%80%82%E5%90%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"由于箭头函数的 this 在定义时确定， 所以有一些地方不能用箭头函数 不能定义对象上的方法 12345678let obj = &#123; a: 1, func: () =&gt; &#123; console.log(this.a); &#125;,&#125;;var a = 0;obj.func(); // 0 不能定义动态上下文的回调函数 1234const btn = document.getElementById(&quot;id&quot;);btn.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(this === window); // =&gt; true&#125;); 不能作为构造函数 12345const Mes = (a) =&gt; &#123; this.a = a;&#125;;const kk = new Mes(&quot;hh&quot;);// Throws &quot;TypeError: Message is not a constructor&quot;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js-try-catch代码提取","slug":"js-try-catch代码提取","date":"2020-09-04T12:36:40.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-try-catch代码提取/","link":"","permalink":"https://laputaz.github.io/home/js-try-catch%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96/","excerpt":"","text":"为了代码健壮性，亦或为了捕获异步的错误, 会频繁写 try / catch 12345678910111213try &#123; const res = await asyncFunc(); // admin 通常的接口结构, success 判断是否成功 if (res.success) &#123; // 成功处理 &#125; else &#123; // 错误处理, 如重置表单, 清空表格, 友好的$message错误提示 等 &#125;&#125; catch (e) &#123; // 错误处理, 如重置表单, 清空表格, 友好的$message错误提示 等&#125; finally &#123; // 关闭 loading 等&#125; 提取出来 12345678910111213const wrapRequest = async (req) =&gt; &#123; try &#123; const res = await req(); // admin 通常的接口结构 if (res.success) &#123; return [res.result, null]; &#125; else &#123; return [null, err]; &#125; &#125; catch (err) &#123; return [null, err]; &#125;&#125;; 使用 12345678910111213141516async function func() &#123; const [res, err] = await wrapRequest(req); if (err) &#123; // 错误处理 here &#125; // 成功处理 &amp; finally 处理 here&#125;// 只需要 errasync function func() &#123; const [, err] = await wrapRequest(req); if (err) &#123; // 错误处理 here &#125; // 成功处理 &amp; finally 处理 here&#125; 但是每次都要引用 wrapRequest ….@$#%^&amp;(#$%@+@!)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：循环方法整理","slug":"js-循环方法整理","date":"2020-09-04T12:32:13.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-循环方法整理/","link":"","permalink":"https://laputaz.github.io/home/js-%E5%BE%AA%E7%8E%AF%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/","excerpt":"遍历数组有很多方法, 最简单的便是 for 循环, 另外还有 forEach、map、filter、some、every、reduce 等 ;每种方法面向的场景是不一样的, 先讲一下使用, 性能嘛, 最后再看","text":"遍历数组有很多方法, 最简单的便是 for 循环, 另外还有 forEach、map、filter、some、every、reduce 等 ;每种方法面向的场景是不一样的, 先讲一下使用, 性能嘛, 最后再看 forfor 循环是最基础的一种循环方式 123456// 一般把长度先缓存, 避免重复获取, 无需多言const arr = [1, 2, 3, 4, 5]const len = arr.lengthfor (i = 0; i &lt; len; i++) &#123; // do something&#125; for循环可以通过break、return 等语句提前终止for并没有块级作用域当遇到return语句时 , 包含此for循环的方法会终止 12345678910111213const gg = () =&gt; &#123; const arr = [1, 2, 3, 4, 5] const len = arr.length for (i = 0; i &lt; len; i++) &#123; console.log(arr[i]) if (i === 3) &#123; return &#125; &#125; console.log(&#x27;last&#x27;)&#125;// return 后 &#x27;last&#x27; 不打印gg() // 1 2 3 4 字符串同样有 length 属性, 所以可以遍历字符串 forEach一般用于对数组每一项进行修改, 没有返回值 123arr.forEach((_) =&gt; &#123; // do something&#125;) 由于break, continue只能在循环中使用, 而 forEach 回调function是函数很明显不可以通过break, continue等中断循环但是可以通过return结束本次循环 12345678;[1, 2, 3, 4, 5].forEach((_) =&gt; &#123; if (_ === 3) &#123; return &#125; console.log(_)&#125;)// 1 2 4 5// 可以看到3 没有被打印, 循环仍会继续, 所以 4 5 被打印了 如果要我非要终止循环呢, 也不是不行, 不过我暂时只能想到抛异常的方法 123456789101112try &#123; ;[1, 2, 3, 4, 5].forEach((_) =&gt; &#123; if (_ === 3) &#123; throw new Error(&#x27;end&#x27;) &#125; console.log(_) &#125;)&#125; catch (e) &#123; console.log(e)&#125;// 1 2// throw new Error(&#x27;end&#x27;) 是一种方法 Set, Map原型中包含forEach方法, 所以可以用于遍历Set, Map, 并不需要 Array.forEach.call / apply 的方式去做 12Set.prototype.forEach // ƒ forEach() &#123; [native code] &#125;Map.prototype.forEach // ƒ forEach() &#123; [native code] &#125; 那么 Set 和 Map 调用 forEach 打印的 index, value 都是什么呢 1234567891011121314151617181920212223242526272829303132333435new Set([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, NaN, NaN]).forEach((value, index, set) =&gt; &#123; console.log(index) console.log(value)&#125;)//one//one//two//two//three//three//NaN//NaN// 可以看到, Set.forEach打印的index, value都是元素本身// 题外话, 另一个有趣现象是, 我在new Set()传入了两个NaN, 由于Set不允许重复元素, 所以最后只会存在一个NaN值// 但是, 不是说 NaN !== NaN 吗? 我认为, Set内部做了处理, 具体如何处理爹也不大明白//--------------------------------------------------//再看Mapnew Map([ [&#x27;key1&#x27;, &#x27;value1&#x27;], [&#x27;key2&#x27;, &#x27;value2&#x27;],]).forEach((value, index, map) =&gt; &#123; console.log(index) console.log(value)&#125;)//key1//value1//key2//value2//可以看到, index为元素的键, value为元素的值 map一般是对每个元素进行一些处理, 并返回新的数组 1234arr.map((el, index) =&gt; &#123; // do something with el return el&#125;) Set, Map没有该方法 常见用法 1234567const arr = [ &#123; id: &#x27;46548&#x27;, name: &#x27;faker&#x27; &#125;, &#123; id: &#x27;46549&#x27;, name: &#x27;faker2&#x27; &#125;,]const idList = arr.map((el) =&gt; el.id)console.log(idList)// [&#x27;46548&#x27;, &#x27;46549&#x27;] filter / findfilter 用来查找符合条件的元素集合find 找到第一个符合条件的元素并返回, 找到后不再往下遍历 every / some这两个方法更多地用在测试数组的个性every 测试数组内的所有元素是否都能通过某个指定函数的测试, 最终返回布尔值, 只要有一个元素不通过则终止循环并返回 false 123456const arr = [10, 30, 8, 2, 6]let bool = arr.every((el) =&gt; &#123; return el % 2 === 0&#125;)bool // true// 每个元素除以2余数都为0吗, 很明显, 是的 some测试是否至少有一个元素通过由提供的函数实现的测试, 最终返回布尔值, 只要有一个元素通过则终止循环并返回 true 123456const arr = [1, 2, 7, 11, 6]let bool = arr.some((el) =&gt; &#123; return el % 2 === 0&#125;)bool // true// 至少有一个元素除以2余数为0吗, 很明显, 是的 for infor in 循环可以遍历字符串、对象、数组，不能遍历 Set/Map, 并且只能拿到可枚举的(enumerable)属性需要注意的是, in 可以拿到原型上的属性 123456789101112131415161718192021let obj = &#123; [Symbol(&#x27;one&#x27;)]: 22, one: 11, two: 22,&#125;obj.__proto__.name = &#x27;haha&#x27;for (let v in obj) &#123; console.log(v)&#125;// one, two, name// 这里用symbol作为键时, 该属性是不可枚举的, 所以for in取不到// 把one属性改为不可枚举Object.defineProperty(obj, &#x27;one&#x27;, &#123; enumerable: false,&#125;)// 这个时候就取不到one了for (let v in obj) &#123; console.log(v)&#125;// two, name 还有, 如果给数组加上属性, 也会被迭代出来 1234567const arr = [1, 2, 3]arr.name = &#x27;haha&#x27;// name属性也会被遍历出来for (let v in arr) &#123; console.log(v)&#125;// 0,1,2,name 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。因此当迭代访问顺序很重要的数组时，最好用整数索引去进行 for 循环 for of遍历 Array 可以采用下标循环，遍历 Map 和 Set 就无法使用下标。为了统一集合类型，ES6 标准引入了新的 iterable 类型，Array、Map 和 Set 都部署了 Symbol.iterable 迭代器for of 循环不仅支持数组、大多数伪数组对象，也支持字符串遍历，此外还支持 Map 和 Set 对象遍历 1234567891011let iterable = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);for (let [key, value] of iterable) &#123; console.log(key); console.log(value);&#125;// a// 1// b// 2...... 区别for…in 语句以原始插入顺序迭代对象的可枚举属性, 拿到的是键for…of 语句遍历可迭代对象定义要迭代的数据, 拿到的是值","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"vue-set方法","slug":"vue-set方法","date":"2020-09-04T12:05:14.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"vue-set方法/","link":"","permalink":"https://laputaz.github.io/home/vue-set%E6%96%B9%E6%B3%95/","excerpt":"","text":"现象我们知道, 下面两种操作, 不会触发视图更新: 根据索引修改数组某项 给对象新增属性 12345678910const vm = new Vue(&#123; data: &#123; arr: [1, 2], obj: &#123; a: 3, &#125;, &#125;,&#125;);vm.arr[0] = 3; // 这种操作页面不会重新渲染vm.obj.b = 3; // 这种操作页面不会重新渲染 数组和对象 set 之后区别区别在于,: 对数组进行 set 改变属性后, 下次直接用索引操作依旧不会触发更新视图, 还是需要 set 而对对象用 set 新增属性后, 该属性就是响应式的了 官网上说 Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：push()pop()shift()unshift()splice()sort()reverse() Vue 对数组增加了一层原型, 即 Vue 中调用 splice, push 等这些方法时, 读取的是 Vue 定义的一层原型上的方法, 可以触发页面的重新渲染, 而非 Array 原型上的方法, Vue.set()对于数组的处理其实就是调用了 splice 方法触发响应, 而对象调用 set 时, 是为新增属性添加依赖收集, 所以对于对象来说, 第二次不必再使用 set.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"实现：一个用来 pull 代码的 shell 脚本","slug":"实现-一个pull代码的shell脚本","date":"2020-08-22T16:58:03.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"实现-一个pull代码的shell脚本/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-%E4%B8%80%E4%B8%AApull%E4%BB%A3%E7%A0%81%E7%9A%84shell%E8%84%9A%E6%9C%AC/","excerpt":"最近每次在 github 拉代码，都需要手动输一遍，有点麻烦。刚好看了一下 shell 脚本是怎么写的。用 sh 写了一下命令。https://github.com/laputaz/get-code","text":"最近每次在 github 拉代码，都需要手动输一遍，有点麻烦。刚好看了一下 shell 脚本是怎么写的。用 sh 写了一下命令。https://github.com/laputaz/get-code 效果其实特别简单，主要就是为了练习练习 shell 脚本的写法。 实现 建立文件夹 首先会提示，请输入文件夹名称。当文件夹名字是空的时候，继续提示。 12345# 建立文件夹read -p &#x27;请输入文件夹名称:&#x27; -a FLODERwhile [ -z $FLODER ]; do read -p &#x27;名称为空, 请重新输入:&#x27; -a FLODERdone 判断文件夹是不是已存在。如果选是，提示是否删除重建；否则退出。 12345678910# 文件夹已存在if [ -d $FLODER ]; then read -p &quot;文件夹已存在, 是否删除文件夹并重建？(y/n)&quot; -n 1 echo &#x27;&#x27; if [[ $REPLY =~ ^[Yy]$ ]]; then rm -rf $FLODER else exit fifi 定义一个新建文件夹并进入文件夹的函数。进入后创建一个 README.md 文件。 123456# 新建文件夹newDir() &#123; mkdir $FLODER cd $FLODER touch README.md&#125; 执行新建并进入文件夹。 1newDir 提示输入仓库地址，如果为空, 或者格式不对（以 ssh/http 开头），提示重新输入。 12345678# 仓库地址 http/sshread -p &#x27;请输入仓库地址:&#x27; -a URLwhile [ -z $URL ]; do read -p &#x27;地址为空, 请重新输入:&#x27; -a URLdonewhile [[ ! $URL =~ ^(http)|(ssh)$ ]]; do read -p &#x27;地址格式不正确, 请重新输入:&#x27; -a URLdone 提示输入仓库别名。默认是 origin。 123456# 仓库别名read -p &#x27;请输入远程仓库别名 (默认为 origin):&#x27; -a NAMEif [ -z $NAME ]; then NAME=&#x27;origin&#x27;fi 提示输入分支名。 12345# 分支名read -p &#x27;请输入分支名 (默认为 master) :&#x27; -a BRANCHif [ -z $BRANCH ]; then BRANCH=&#x27;master&#x27;fi 最后执行 git 命令，切到对应分支，并提交。 12345678# pullgit initgit remote add $NAME $URLgit checkout -b $BRANCHgit pull $NAME $BRANCHgit add .git commit -m &quot;add README.md&quot;git push $NAME $BRANCH 效果","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"shell","slug":"shell","permalink":"https://laputaz.github.io/home/tags/shell/"}]},{"title":"js-samesite兼容性及csrf处理","slug":"js-samesite兼容性及csrf处理","date":"2020-08-04T15:39:48.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-samesite兼容性及csrf处理/","link":"","permalink":"https://laputaz.github.io/home/js-samesite%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%8Acsrf%E5%A4%84%E7%90%86/","excerpt":"","text":"CSRF 主要设计两种 http 操作 safe http methods: &quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;, and &quot;TRACE&quot;, unsafe http methods: &quot;POST&quot; 这里 klk 技术团队已经遵循了基本的安全概念，即不会使用 GET 操作进行数据库的操作或业务逻辑处理，所以这里主要讨论 POST 情况, 讨论使用 Cookie 的 SameSite 属性来保证 POST 请求的安全性是否可行 第一种： post JSON结论 ：post JSON 会直接触发浏览器 CORS 安全防护。 但是在 使用 IP 而非域名的情况下不会触发（这里对用户无影响。 可视为使用 CURL） 第二种：post Form代码这里利用了一个现有的 post form 接口 12345&lt;form action=&quot;http://admind187.debug.klk.io/xos_api/prosrv/campaign/link/delete&quot; method=&quot;POST&quot;&gt; &lt;input name=&quot;project_id&quot; id=&quot;project_id&quot; val=&quot;0&quot; /&gt; &lt;button&gt;Post&lt;/button&gt;&lt;/form&gt; 版本兼容性 测试firefox v49 （无 SameSite 支持） 点击 Post. 表单提交成功并且目标域名 Cookie 信息 结论 ： 有漏洞存在 firefox v61 ( 支持 SameSite, 但是不会默认设置为 SameSite=Lax )重复以上操作 可以看到有 sameSite 支持 但是默认为 Unset 发送请求有 Cookie 携带。 结论： 存在漏洞 Chrome V81+ ( 支持 SameSite 并且 默认 SameSite=Lax )重复以上操作 可见支持 SameSite （默认 SameSite 值未给出 ） 可见 该请求未携带任何 Cookie 信息 结论： 目前部分较新版本浏览器默认支持 SameSite=Lax， 该情况下无 CSRF 漏洞问题。这里有结果返回主要因为是接口较旧没有做鉴权认证 总结论官方文档解释这里参考 https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7.1 Lax enforcement provides reasonable defense in depth against CSRF attacks that rely on unsafe HTTP methods (like &quot;POST&quot;), but does not offer a robust defense against CSRF as a general category of attack 官方解释为“ 使用 SameSite=Lax 可以对 unsafe HTTP Methods 有比较好的防护， 但是不能防护所有 CSRF 类 攻击。 ” 这里针对 B 端的常见业务以及已存在的技术团队内部的技术时间，我们只要针对 Post 请求进行 CSRF 防范即可。 这里使用 SameSite=Lax 已经可以满足需求 待处理 在笔者整理文档时还是有几大浏览器没有使用默认 SameSite=Lax 的处理 。 并且 IE 根本没有 SameSite 支持。 基于此： 后端鉴权服务主动添加 SameSite=Lax 处理 前端设置浏览器版本控制， 阻止用户使用较低版本浏览器访问","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"设计模式：设计模式笔记","slug":"js基础-设计模式笔记","date":"2020-05-27T11:04:10.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-设计模式笔记/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"每次都忘记一些设计模式，这里记录一下常用的一些。","text":"每次都忘记一些设计模式，这里记录一下常用的一些。 设计模式 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式原则 Single Responsibility Principle 单一职责原则 (S) 一个程序只做好一件事 如果功能过于复杂就拆分开，每个部分保持独立 OpenClosed Principle 开放/封闭原则 (O) 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码 Liskov Substitution Principle 里氏替换原则 (L) 子类能覆盖父类 父类能出现的地方子类就能出现 Interface Segregation Principle 接口隔离原则 (I) 保持接口的单一独立 类似单一职责原则，这里更关注接口 Dependency Inversion Principle 依赖倒转原则 (D) 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现 SO 体现较多，举个栗子：（比如 Promise）单一职责原则：每个 then 中的逻辑只做好一件事开放封闭原则（对扩展开放，对修改封闭）：如果新增需求，扩展 then 设计模式分类单例模式单例模式两个条件: 确保只有一个实例 可以全局访问 实例: 全局对象如 window、global 等 例如 Vue 也作为单例 弹窗组件，当需要时创建，关闭时缓存，再次调用时重复打开，而不是重新创建，徒损性能。 遇到的坑： 布局包、amis 包，依赖权限包，权限包请求并保存了权限 code。但是布局包的权限包与实际权限包版本号不统一，生成了两个实例。peerDependncy 策略模式 根据不同参数可以命中不同的策略 1234567891011121314151617const strategy = &#123; S: function (salary) &#123; return salary * 4 &#125;, A: function (salary) &#123; return salary * 3 &#125;, B: function (salary) &#123; return salary * 2 &#125;,&#125;const calculateBonus = function (level, salary) &#123; return strategy[level](salary)&#125;calculateBonus(&#x27;A&#x27;, 10000) // 30000 代理模式 为一个对象提供一个代用品或占位符，以便控制对它的访问。 场景： Proxy 或者 Object.defineProperty 迭代器模式 提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。 实例： Array.prototype.forEach ES6 Iterator 发布-订阅模式 &amp; 观察者模式定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。 发布订阅模式与观察者模式都是感知变化，相应变化。区别在于有没有中间人。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 主题 保存状态，状态变化之后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers() &#123; this.observers.forEach((observer) =&gt; &#123; observer.update() &#125;) &#125; attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&#x27;o1&#x27;, s)let o2 = new Observer(&#x27;02&#x27;, s)s.setState(12) 实例化的时候把自己注册到订阅中心（主题）。订阅中心发生变动时，通知所有观察者更新自身。 场景： DOM 事件 1234document.body.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;hello world!&#x27;)&#125;)document.body.click() Vue 响应式 IntersectionObserver 监听元素状态 组合模式 将对象组合成树形结构，以表示“整体-部分”的层次结构。 通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。 12345678910111213141516171819202122232425262728293031class TrainOrder &#123; create() &#123; console.log(&#x27;创建火车票订单&#x27;) &#125;&#125;class HotelOrder &#123; create() &#123; console.log(&#x27;创建酒店订单&#x27;) &#125;&#125;class TotalOrder &#123; constructor() &#123; this.orderList = [] &#125; addOrder(order) &#123; this.orderList.push(order) return this &#125; create() &#123; this.orderList.forEach((item) =&gt; &#123; item.create() &#125;) return this &#125;&#125;// 可以在购票网站买车票同时也订房间let train = new TrainOrder()let hotel = new HotelOrder()let total = new TotalOrder()total.addOrder(train).addOrder(hotel).create() 享元模式 大大减少对象的创建，降低系统的内存，使效率提高。 职责链模式使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 1234567891011121314151617181920212223// 请假审批，需要组长审批、经理审批、总监审批class Action &#123; constructor(name) &#123; this.name = name this.nextAction = null &#125; setNextAction(action) &#123; this.nextAction = action &#125; handle() &#123; console.log(`$&#123;this.name&#125; 审批`) if (this.nextAction != null) &#123; this.nextAction.handle() &#125; &#125;&#125;let a1 = new Action(&#x27;组长&#x27;)let a2 = new Action(&#x27;经理&#x27;)let a3 = new Action(&#x27;总监&#x27;)a1.setNextAction(a2)a2.setNextAction(a3)a1.handle() 场景: JS 中的事件冒泡 作用域链 原型链 中介者模式 解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A &#123; constructor() &#123; this.number = 0 &#125; setNumber(num, m) &#123; this.number = num if (m) &#123; m.setB() &#125; &#125;&#125;class B &#123; constructor() &#123; this.number = 0 &#125; setNumber(num, m) &#123; this.number = num if (m) &#123; m.setA() &#125; &#125;&#125;class Mediator &#123; constructor(a, b) &#123; this.a = a this.b = b &#125; setA() &#123; let number = this.b.number this.a.setNumber(number * 10) &#125; setB() &#123; let number = this.a.number this.b.setNumber(number / 10) &#125;&#125;let a = new A()let b = new B()let m = new Mediator(a, b)a.setNumber(10, m)console.log(a.number, b.number)b.setNumber(10, m)console.log(a.number, b.number) 装饰者模式 动态地给函数赋能。动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案。 在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象。 Vue 高阶组件 适配者模式 将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。 1234567891011121314151617class Plug &#123; getName() &#123; return &#x27;iphone充电头&#x27; &#125;&#125;class Target &#123; constructor() &#123; this.plug = new Plug() &#125; getName() &#123; return this.plug.getName() + &#x27; 适配器Type-c充电头&#x27; &#125;&#125;let target = new Target()target.getName() // iphone充电头 适配器转Type-c充电头 场景: 整合第三方 SDK 封装旧接口","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"css问题：safari 下 input 无法自动聚焦解决","slug":"css问题-ios端input无法自动聚焦解决","date":"2020-05-20T19:03:22.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"css问题-ios端input无法自动聚焦解决/","link":"","permalink":"https://laputaz.github.io/home/css%E9%97%AE%E9%A2%98-ios%E7%AB%AFinput%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%81%9A%E7%84%A6%E8%A7%A3%E5%86%B3/","excerpt":"shit","text":"shit 背景最近在开发一个移动端的页面，要求是，页面加载后，自动聚焦到输入框。 正常做法正常的做法是，获取 input 元素，然后执行 focus() 方法 12// 因为用的是 vue, 直接通过refs获取即可$refs.input.$el.focus() 这个方法在 chrome 下是可以生效的 问题但是，在 safari 下有兼容性问题，始终无法聚焦，这里记录一下解决方案: 相关问题：https://stackoverflow.com/questions/54424729/ios-show-keyboard-on-input-focus 思路是：创建一个额外的 input，再切换到目标 input（需要再研究一下为什么） 12345678910111213141516const autoFocus = (target) =&gt; &#123; // 创建 input 元素并 focus var fakeEl = document.createElement(&#x27;input&#x27;) fakeEl.style.height = 0 fakeEl.style.opacity = 0 fakeEl.style.position = &#x27;absolute&#x27; fakeEl.style.top = 0 document.body.appendChild(fakeEl) fakeEl.focus() // 切换至目标元素 setTimeout((_) =&gt; &#123; target.click() target.focus() document.body.removeChild(fakeEl) &#125;, 100)&#125; 以上。","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"},{"name":"问题","slug":"问题","permalink":"https://laputaz.github.io/home/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"vue-高阶组件","slug":"vue-高阶组件","date":"2020-05-06T15:31:57.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"vue-高阶组件/","link":"","permalink":"https://laputaz.github.io/home/vue-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","excerpt":"","text":"As being evident from the discussion above, implementing HoCs in Vue isn&#39;t as trivial as in React because Vue&#39;s API and functionality is broader and more edge cases have to be taken care of. 灵感来源开发 admin-ui 组件 https://knpm.klk.io/-/web/detail/@klk/admin-ui 本文也会以封装 element 组件为例 目标封装一个成熟的组件，并达成以下几点 传递给 HOC 的参数能正常传递给原组件 传递给 HOC 的事件能正常绑定到原组件 给 HOC 传递的 slot 能正常传递给原组件 HOC 内部能获取到从父组件传递的参数、事件、slot，并针对 HOC 的目标开发自定义功能 开发方式v-bind=&quot;$attrs&quot;, v-on=&quot;$listeners&quot; 通过对原组件 v-bind=&quot;$attrs&quot;, v-on=&quot;$listeners&quot; 将从父组件传递的参数和事件原样传递给原组件： 12345678910111213&lt;!-- parent.vue --&gt;&lt;my-hoc :data=&quot;tableData&quot; :border=&quot;true&quot; @select=&quot;handleSelect&quot; @select-all=&quot;handleSelectAll&quot;/&gt;&lt;!-- myHoc.vue --&gt;&lt;el-table v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;/&gt; 从 parent.vue 传递的参数 data, border 和事件 select, select-all 会原样传递给 el-table 如果不想把从父组件传递的参数或事件全都传递给原组件，需要做部分筛选，可以使用计算属性 computed： 12345&lt;!-- myHoc.vue --&gt;&lt;el-table v-bind=&quot;tableProps&quot; v-on=&quot;tableListeners&quot;/&gt; 1234567891011121314151617181920export default &#123; computed: &#123; tableProps() &#123; const &#123; data &#125; = this.$attrs return &#123; data &#125; &#125;, tableListeners() &#123; const &#123; select &#125; = this.$listeners return &#123; select &#125; &#125; &#125;&#125; 如果同时对原组件传递 $attrs 和与 $attrs 的某个 key 重名的参数，HOC 传递的参数优先级高于父组件： 12345678910&lt;!-- parent.vue --&gt;&lt;my-hoc :data=&quot;tableData&quot;/&gt;&lt;!-- myHoc.vue --&gt;&lt;el-table v-bind=&quot;$attrs&quot; :data=&quot;myData&quot;/&gt; el-table 会取从 HOC 传递的 myData 如果同时对原组件传递 $listeners 和与 $listeners 的某个 key 重名的事件，原组件触发事件时，这两个函数都会调用，HOC 传递的事件函数执行顺序优先级高于父组件传递的事件函数： 12345678910&lt;!-- parent.vue --&gt;&lt;my-hoc :select=&quot;handleSelect&quot;/&gt;&lt;!-- myHoc.vue --&gt;&lt;el-table v-on=&quot;$listeners&quot; @select=&quot;myHandleSelect&quot;/&gt; 当 el-table 触发 select 事件时，先触发函数 myHandleSelect，后触发函数 handleSelect 将从父组件传递的 slot 传递给原组件： 12345678910111213&lt;!-- parent.vue --&gt;&lt;my-hoc&gt; &lt;template #mySlot&gt; &lt;h1&gt;el-table Slot Append&lt;/h1&gt; &lt;/template&gt;&lt;/my-hoc&gt;&lt;!-- myHoc.vue --&gt;&lt;el-table&gt; &lt;template #append&gt; &lt;slot name=&quot;mySlot&quot; /&gt; &lt;/template&gt;&lt;/el-table&gt; 这里会将从父组件传递的名为 mySlot 的 slot 传递给 el-table 的 append slot，mySlot 的命名可自定义 如果需要在 HOC 组件内以 this.xxxProp 的方式调用从父组件传递的参数，则需要在 HOC 内定义对应的 prop，否则只能以 this.$attrs.xxxProp 的方式调用。在 HOC 内定义了 prop 后，指定参数会从 HOC 的 $attrs 中转移到 $props，此时需要注意给 el-table 手动传参。 根据 HOC 需要灵活设置 HOC 组件参数 inheritAttrs 此方式的优劣优点 代码风格较简洁 易于理解，便于维护 Vue 官方推荐的写 HOC 时原样传递参数和事件的方式，容错率较高 缺点 参数在 $attrs 和 $props 之间的切换可能会很频繁 事件修饰符无法传递，需要以其它方式替代 需要按照原组件的 slot 定义，逐个在 HOC 模版内如数定义一遍，slot 数量多时会引出较多代码量 相关资料 https://cn.vuejs.org/v2/api/#vm-attrs https://cn.vuejs.org/v2/api/#vm-listeners https://cn.vuejs.org/v2/api/#inheritAttrs 禁用 Attribute 继承 向子元素或子组件传递 attribute 和事件 将原生事件绑定到组件 渲染函数 h() / createElement() Vue 组件的选项之一，使用方式入口 h()，使用前墙裂建议先熟悉一下 基础 适合场景：需要 JavaScript 的完全编程的能力 关于渲染函数的介绍和使用，vue 官方文档已经介绍的比较全面，这里再介绍一些关于插槽的使用，也是我开发时花了比较多时间去理解的 12345678910&#123; // Vue 官方文档关于插槽相关属性的介绍： // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement(&#x27;span&#x27;, props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: &#x27;name-of-slot&#x27;,&#125; 属性 slot: 123&lt;div&gt; &lt;h1 v-slot:myslot&gt;我是 mySlot&lt;/h1&gt;&lt;/div&gt; 用 h() 对这个组件渲染，有多种方式，这里介绍使用到属性 slot 的方式： 123456789101112h( &#x27;div&#x27;, [ h( &#x27;h1&#x27;, &#123; slot: &#x27;myslot&#x27; &#125;, &#x27;我是 myslot&#x27; ) ]) 思路：定义当前组件时，告诉这个组件它是它的父组件里面插槽名为 slot 对应值的内容 属性 scopedSlots: 1234567&lt;div&gt; &lt;h1 v-slot:myslot1&gt;我是 myslot1&lt;/h1&gt; &lt;template v-slot:myslot2&gt; &lt;h2&gt;我是 myslot2 的 h2&lt;/h2&gt; &lt;h3&gt;我是 myslot2 的 h3&lt;/h3&gt; &lt;/template&gt;&lt;/div&gt; 用 h() 对这个组件渲染，有多种方式，这里介绍使用到属性 scopedSlots 的方式： 123456789101112h( &#x27;div&#x27;, &#123; scopedSlots: &#123; myslot1: (props) =&gt; h(&#x27;h1&#x27;, &#x27;我是 myslot1&#x27;), myslot2: (props) =&gt; [ h(&#x27;h2&#x27;, &#x27;我是 myslot2 的 h2&#x27;) h(&#x27;h3&#x27;, &#x27;我是 myslot2 的 h3&#x27;) ] &#125; &#125;) 思路：定义当前组件时，告诉这个组件它的各个 scopedSlots key 对应的内容分别要渲染什么 总结：可以理解为一个是被动，一个是主动 插槽命名 不要 用驼峰式命名，有 bug 此方式的优劣优点 还是那句话，发挥了 Javascript 的编程能力，编程自由度高 相比上一种方式，在插槽方面的处理，要优秀的很多，因为可以用编程的方式批量处理，同样，其它属性的赋值也可批量处理 缺点 代码较冗长，不方便维护，开发成本较高 要替代模版中的 v-model 指令，代价很大，因为不同表单组件的方式可能不一样，容易写出 bug，有点类似于开发 react 的受控组件和非受控组件的感觉 类似于 v-model ，部分事件修饰符也需要手动实现，也有部分是 vue 有提供捷径的 相关资料 渲染函数 &amp; JSX JSX ( To Be Completed…… )","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"js-千分位逗号分隔","slug":"js-千分位逗号分隔","date":"2020-03-04T12:15:51.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-千分位逗号分隔/","link":"","permalink":"https://laputaz.github.io/home/js-%E5%8D%83%E5%88%86%E4%BD%8D%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94/","excerpt":"","text":"toLocaleString() 1234(123456489656456).toLocaleString(&quot;en-US&quot;);// 带小数,但是toString, toLocaleString只能保留两位(123456489656456.45764655).toLocaleString();// &quot;123,456,489,656,456.45&quot; 正则 12// 带有小数的还没想到(123456489656456).toString().replace(/\\w(?=(\\w&#123;3&#125;)+$)/g, &quot;$&amp;,&quot;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js-实现链式调用","slug":"js-实现链式调用","date":"2020-01-15T12:00:58.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-实现链式调用/","link":"","permalink":"https://laputaz.github.io/home/js-%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/","excerpt":"","text":"问题上次被问到链式调用怎么实现, 而且需要中间seelp停顿n秒,再继续往下执行;链式调用思路是返回this, seelp的思路是利用js单线程while阻塞; (利用for等也是一样的) 简单示例12345678910111213141516171819202122232425let chain = &#123; log(...args) &#123; console.log(args.toString()); return this; &#125;, // 单位 ms sleep(delay) &#123; let start = Date.now(); while (+new Date() &lt; start + delay) &#123;&#125; // 或 for(;+new Date() &lt; start + delay;)&#123;&#125; return this; &#125;,&#125;;chain .log(&quot;start&quot;) .sleep(2000) .log(&quot;2s after&quot;) .log(&quot;continue&quot;) .sleep(5000) .log(&quot;5s after&quot;);// start// 2s after// continue// 5s after","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"实现：console 梳理，以及如何用 console 输出 p 站图标(误)","slug":"实现-console梳理以及如何用console输出pornhub图标","date":"2019-11-29T22:26:19.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"实现-console梳理以及如何用console输出pornhub图标/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-console%E6%A2%B3%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%94%A8console%E8%BE%93%E5%87%BApornhub%E5%9B%BE%E6%A0%87/","excerpt":"console 其实有很多方法，甚至可以设置样式。 console 方法记录。","text":"console 其实有很多方法，甚至可以设置样式。 console 方法记录。 起因下午写了一下 shell 脚本, 突然想到 chrome 的 devtool 是不是也支持字体颜色, 本着上（）下（）求（）索（）的精神，试了一下确实可以 尝试console.log方法是支持对打印的结果加一些简单的样式的, 如下 1console.log(&#x27;%c我黄了&#x27;, &#x27;color:yellow&#x27;) 复杂一点12345678console.log( &#x27;%chello %s %s %c%s&#x27;, &#x27;color:green;font-family:Hanzipen TC&#x27;, &#x27;QQQ&#x27;, &#x27;T&#x27;, &#x27;background-color: #ff6600;color:#fff&#x27;, &#x27;How are you&#x27;) 可以看到%c对应样式, %s对应字符,上面第一个参数中, 书写的顺序是%c %s %s %c %s, 所以从第二个参数开始, 传参顺序得是样式, 字符, 字符, 样式, 字符 还支持 padding 等属性123456console.log( &#x27;%c%s%cYours To Explore&#x27;, &#x27;color:#fff;background:#ff6600;font-weight:800;padding:10px;border-radius: 5px 0 0 5px &#x27;, &#x27;KLOOK&#x27;, &#x27;color:#fff;background:#ff6600;font-weight:800;padding:10px 10px 10px 0;font-family:Hanzipen TC; border-radius: 0 5px 5px 0&#x27;) 来了那么, 用 console.log 输出学习强国图标也就不是问题了. 12345console.log( &#x27;%cPorn %cHub&#x27;, &#x27;color:#fff;background:#000;font-weight:800;padding:10px;border-radius:3px&#x27;, &#x27;color:#000;background:#ff9900;font-weight:800;padding:3px;margin-left:-40px;border-radius:2px&#x27;) 再夸张一点123let css = &#x27;text-shadow: -1px -1px hsl(0,100%,50%), 1px 1px hsl(5.4, 100%, 50%), 3px 2px hsl(10.8, 100%, 50%), 5px 3px hsl(16.2, 100%, 50%), 7px 4px hsl(21.6, 100%, 50%), 9px 5px hsl(27, 100%, 50%), 11px 6px hsl(32.4, 100%, 50%), 13px 7px hsl(37.8, 100%, 50%), 14px 8px hsl(43.2, 100%, 50%), 16px 9px hsl(48.6, 100%, 50%), 18px 10px hsl(54, 100%, 50%), 20px 11px hsl(59.4, 100%, 50%), 22px 12px hsl(64.8, 100%, 50%), 23px 13px hsl(70.2, 100%, 50%), 25px 14px hsl(75.6, 100%, 50%), 27px 15px hsl(81, 100%, 50%), 28px 16px hsl(86.4, 100%, 50%), 30px 17px hsl(91.8, 100%, 50%), 32px 18px hsl(97.2, 100%, 50%), 33px 19px hsl(102.6, 100%, 50%), 35px 20px hsl(108, 100%, 50%), 36px 21px hsl(113.4, 100%, 50%), 38px 22px hsl(118.8, 100%, 50%), 39px 23px hsl(124.2, 100%, 50%), 41px 24px hsl(129.6, 100%, 50%), 42px 25px hsl(135, 100%, 50%), 43px 26px hsl(140.4, 100%, 50%), 45px 27px hsl(145.8, 100%, 50%), 46px 28px hsl(151.2, 100%, 50%), 47px 29px hsl(156.6, 100%, 50%), 48px 30px hsl(162, 100%, 50%), 49px 31px hsl(167.4, 100%, 50%), 50px 32px hsl(172.8, 100%, 50%), 51px 33px hsl(178.2, 100%, 50%), 52px 34px hsl(183.6, 100%, 50%), 53px 35px hsl(189, 100%, 50%), 54px 36px hsl(194.4, 100%, 50%), 55px 37px hsl(199.8, 100%, 50%), 55px 38px hsl(205.2, 100%, 50%), 56px 39px hsl(210.6, 100%, 50%), 57px 40px hsl(216, 100%, 50%), 57px 41px hsl(221.4, 100%, 50%), 58px 42px hsl(226.8, 100%, 50%), 58px 43px hsl(232.2, 100%, 50%), 58px 44px hsl(237.6, 100%, 50%), 59px 45px hsl(243, 100%, 50%), 59px 46px hsl(248.4, 100%, 50%), 59px 47px hsl(253.8, 100%, 50%), 59px 48px hsl(259.2, 100%, 50%), 59px 49px hsl(264.6, 100%, 50%), 60px 50px hsl(270, 100%, 50%), 59px 51px hsl(275.4, 100%, 50%), 59px 52px hsl(280.8, 100%, 50%), 59px 53px hsl(286.2, 100%, 50%), 59px 54px hsl(291.6, 100%, 50%), 59px 55px hsl(297, 100%, 50%), 58px 56px hsl(302.4, 100%, 50%), 58px 57px hsl(307.8, 100%, 50%), 58px 58px hsl(313.2, 100%, 50%), 57px 59px hsl(318.6, 100%, 50%), 57px 60px hsl(324, 100%, 50%), 56px 61px hsl(329.4, 100%, 50%), 55px 62px hsl(334.8, 100%, 50%), 55px 63px hsl(340.2, 100%, 50%), 54px 64px hsl(345.6, 100%, 50%), 53px 65px hsl(351, 100%, 50%), 52px 66px hsl(356.4, 100%, 50%), 51px 67px hsl(361.8, 100%, 50%), 50px 68px hsl(367.2, 100%, 50%), 49px 69px hsl(372.6, 100%, 50%), 48px 70px hsl(378, 100%, 50%), 47px 71px hsl(383.4, 100%, 50%), 46px 72px hsl(388.8, 100%, 50%), 45px 73px hsl(394.2, 100%, 50%), 43px 74px hsl(399.6, 100%, 50%), 42px 75px hsl(405, 100%, 50%), 41px 76px hsl(410.4, 100%, 50%), 39px 77px hsl(415.8, 100%, 50%), 38px 78px hsl(421.2, 100%, 50%), 36px 79px hsl(426.6, 100%, 50%), 35px 80px hsl(432, 100%, 50%), 33px 81px hsl(437.4, 100%, 50%), 32px 82px hsl(442.8, 100%, 50%), 30px 83px hsl(448.2, 100%, 50%), 28px 84px hsl(453.6, 100%, 50%), 27px 85px hsl(459, 100%, 50%), 25px 86px hsl(464.4, 100%, 50%), 23px 87px hsl(469.8, 100%, 50%), 22px 88px hsl(475.2, 100%, 50%), 20px 89px hsl(480.6, 100%, 50%), 18px 90px hsl(486, 100%, 50%), 16px 91px hsl(491.4, 100%, 50%), 14px 92px hsl(496.8, 100%, 50%), 13px 93px hsl(502.2, 100%, 50%), 11px 94px hsl(507.6, 100%, 50%), 9px 95px hsl(513, 100%, 50%), 7px 96px hsl(518.4, 100%, 50%), 5px 97px hsl(523.8, 100%, 50%), 3px 98px hsl(529.2, 100%, 50%), 1px 99px hsl(534.6, 100%, 50%), 7px 100px hsl(540, 100%, 50%), -1px 101px hsl(545.4, 100%, 50%), -3px 102px hsl(550.8, 100%, 50%), -5px 103px hsl(556.2, 100%, 50%), -7px 104px hsl(561.6, 100%, 50%), -9px 105px hsl(567, 100%, 50%), -11px 106px hsl(572.4, 100%, 50%), -13px 107px hsl(577.8, 100%, 50%), -14px 108px hsl(583.2, 100%, 50%), -16px 109px hsl(588.6, 100%, 50%), -18px 110px hsl(594, 100%, 50%), -20px 111px hsl(599.4, 100%, 50%), -22px 112px hsl(604.8, 100%, 50%), -23px 113px hsl(610.2, 100%, 50%), -25px 114px hsl(615.6, 100%, 50%), -27px 115px hsl(621, 100%, 50%), -28px 116px hsl(626.4, 100%, 50%), -30px 117px hsl(631.8, 100%, 50%), -32px 118px hsl(637.2, 100%, 50%), -33px 119px hsl(642.6, 100%, 50%), -35px 120px hsl(648, 100%, 50%), -36px 121px hsl(653.4, 100%, 50%), -38px 122px hsl(658.8, 100%, 50%), -39px 123px hsl(664.2, 100%, 50%), -41px 124px hsl(669.6, 100%, 50%), -42px 125px hsl(675, 100%, 50%), -43px 126px hsl(680.4, 100%, 50%), -45px 127px hsl(685.8, 100%, 50%), -46px 128px hsl(691.2, 100%, 50%), -47px 129px hsl(696.6, 100%, 50%), -48px 130px hsl(702, 100%, 50%), -49px 131px hsl(707.4, 100%, 50%), -50px 132px hsl(712.8, 100%, 50%), -51px 133px hsl(718.2, 100%, 50%), -52px 134px hsl(723.6, 100%, 50%), -53px 135px hsl(729, 100%, 50%), -54px 136px hsl(734.4, 100%, 50%), -55px 137px hsl(739.8, 100%, 50%), -55px 138px hsl(745.2, 100%, 50%), -56px 139px hsl(750.6, 100%, 50%), -57px 140px hsl(756, 100%, 50%), -57px 141px hsl(761.4, 100%, 50%), -58px 142px hsl(766.8, 100%, 50%), -58px 143px hsl(772.2, 100%, 50%), -58px 144px hsl(777.6, 100%, 50%), -59px 145px hsl(783, 100%, 50%), -59px 146px hsl(788.4, 100%, 50%), -59px 147px hsl(793.8, 100%, 50%), -59px 148px hsl(799.2, 100%, 50%), -59px 149px hsl(804.6, 100%, 50%), -60px 150px hsl(810, 100%, 50%), -59px 151px hsl(815.4, 100%, 50%), -59px 152px hsl(820.8, 100%, 50%), -59px 153px hsl(826.2, 100%, 50%), -59px 154px hsl(831.6, 100%, 50%), -59px 155px hsl(837, 100%, 50%), -58px 156px hsl(842.4, 100%, 50%), -58px 157px hsl(847.8, 100%, 50%), -58px 158px hsl(853.2, 100%, 50%), -57px 159px hsl(858.6, 100%, 50%), -57px 160px hsl(864, 100%, 50%), -56px 161px hsl(869.4, 100%, 50%), -55px 162px hsl(874.8, 100%, 50%), -55px 163px hsl(880.2, 100%, 50%), -54px 164px hsl(885.6, 100%, 50%), -53px 165px hsl(891, 100%, 50%), -52px 166px hsl(896.4, 100%, 50%), -51px 167px hsl(901.8, 100%, 50%), -50px 168px hsl(907.2, 100%, 50%), -49px 169px hsl(912.6, 100%, 50%), -48px 170px hsl(918, 100%, 50%), -47px 171px hsl(923.4, 100%, 50%), -46px 172px hsl(928.8, 100%, 50%), -45px 173px hsl(934.2, 100%, 50%), -43px 174px hsl(939.6, 100%, 50%), -42px 175px hsl(945, 100%, 50%), -41px 176px hsl(950.4, 100%, 50%), -39px 177px hsl(955.8, 100%, 50%), -38px 178px hsl(961.2, 100%, 50%), -36px 179px hsl(966.6, 100%, 50%), -35px 180px hsl(972, 100%, 50%), -33px 181px hsl(977.4, 100%, 50%), -32px 182px hsl(982.8, 100%, 50%), -30px 183px hsl(988.2, 100%, 50%), -28px 184px hsl(993.6, 100%, 50%), -27px 185px hsl(999, 100%, 50%), -25px 186px hsl(1004.4, 100%, 50%), -23px 187px hsl(1009.8, 100%, 50%), -22px 188px hsl(1015.2, 100%, 50%), -20px 189px hsl(1020.6, 100%, 50%), -18px 190px hsl(1026, 100%, 50%), -16px 191px hsl(1031.4, 100%, 50%), -14px 192px hsl(1036.8, 100%, 50%), -13px 193px hsl(1042.2, 100%, 50%), -11px 194px hsl(1047.6, 100%, 50%), -9px 195px hsl(1053, 100%, 50%), -7px 196px hsl(1058.4, 100%, 50%), -5px 197px hsl(1063.8, 100%, 50%), -3px 198px hsl(1069.2, 100%, 50%), -1px 199px hsl(1074.6, 100%, 50%), -1px 200px hsl(1080, 100%, 50%), 1px 201px hsl(1085.4, 100%, 50%), 3px 202px hsl(1090.8, 100%, 50%), 5px 203px hsl(1096.2, 100%, 50%), 7px 204px hsl(1101.6, 100%, 50%), 9px 205px hsl(1107, 100%, 50%), 11px 206px hsl(1112.4, 100%, 50%), 13px 207px hsl(1117.8, 100%, 50%), 14px 208px hsl(1123.2, 100%, 50%), 16px 209px hsl(1128.6, 100%, 50%), 18px 210px hsl(1134, 100%, 50%), 20px 211px hsl(1139.4, 100%, 50%), 22px 212px hsl(1144.8, 100%, 50%), 23px 213px hsl(1150.2, 100%, 50%), 25px 214px hsl(1155.6, 100%, 50%), 27px 215px hsl(1161, 100%, 50%), 28px 216px hsl(1166.4, 100%, 50%), 30px 217px hsl(1171.8, 100%, 50%), 32px 218px hsl(1177.2, 100%, 50%), 33px 219px hsl(1182.6, 100%, 50%), 35px 220px hsl(1188, 100%, 50%), 36px 221px hsl(1193.4, 100%, 50%), 38px 222px hsl(1198.8, 100%, 50%), 39px 223px hsl(1204.2, 100%, 50%), 41px 224px hsl(1209.6, 100%, 50%), 42px 225px hsl(1215, 100%, 50%), 43px 226px hsl(1220.4, 100%, 50%), 45px 227px hsl(1225.8, 100%, 50%), 46px 228px hsl(1231.2, 100%, 50%), 47px 229px hsl(1236.6, 100%, 50%), 48px 230px hsl(1242, 100%, 50%), 49px 231px hsl(1247.4, 100%, 50%), 50px 232px hsl(1252.8, 100%, 50%), 51px 233px hsl(1258.2, 100%, 50%), 52px 234px hsl(1263.6, 100%, 50%), 53px 235px hsl(1269, 100%, 50%), 54px 236px hsl(1274.4, 100%, 50%), 55px 237px hsl(1279.8, 100%, 50%), 55px 238px hsl(1285.2, 100%, 50%), 56px 239px hsl(1290.6, 100%, 50%), 57px 240px hsl(1296, 100%, 50%), 57px 241px hsl(1301.4, 100%, 50%), 58px 242px hsl(1306.8, 100%, 50%), 58px 243px hsl(1312.2, 100%, 50%), 58px 244px hsl(1317.6, 100%, 50%), 59px 245px hsl(1323, 100%, 50%), 59px 246px hsl(1328.4, 100%, 50%), 59px 247px hsl(1333.8, 100%, 50%), 59px 248px hsl(1339.2, 100%, 50%), 59px 249px hsl(1344.6, 100%, 50%), 60px 250px hsl(1350, 100%, 50%), 59px 251px hsl(1355.4, 100%, 50%), 59px 252px hsl(1360.8, 100%, 50%), 59px 253px hsl(1366.2, 100%, 50%), 59px 254px hsl(1371.6, 100%, 50%), 59px 255px hsl(1377, 100%, 50%), 58px 256px hsl(1382.4, 100%, 50%), 58px 257px hsl(1387.8, 100%, 50%), 58px 258px hsl(1393.2, 100%, 50%), 57px 259px hsl(1398.6, 100%, 50%), 57px 260px hsl(1404, 100%, 50%), 56px 261px hsl(1409.4, 100%, 50%), 55px 262px hsl(1414.8, 100%, 50%), 55px 263px hsl(1420.2, 100%, 50%), 54px 264px hsl(1425.6, 100%, 50%), 53px 265px hsl(1431, 100%, 50%), 52px 266px hsl(1436.4, 100%, 50%), 51px 267px hsl(1441.8, 100%, 50%), 50px 268px hsl(1447.2, 100%, 50%), 49px 269px hsl(1452.6, 100%, 50%), 48px 270px hsl(1458, 100%, 50%), 47px 271px hsl(1463.4, 100%, 50%), 46px 272px hsl(1468.8, 100%, 50%), 45px 273px hsl(1474.2, 100%, 50%), 43px 274px hsl(1479.6, 100%, 50%), 42px 275px hsl(1485, 100%, 50%), 41px 276px hsl(1490.4, 100%, 50%), 39px 277px hsl(1495.8, 100%, 50%), 38px 278px hsl(1501.2, 100%, 50%), 36px 279px hsl(1506.6, 100%, 50%), 35px 280px hsl(1512, 100%, 50%), 33px 281px hsl(1517.4, 100%, 50%), 32px 282px hsl(1522.8, 100%, 50%), 30px 283px hsl(1528.2, 100%, 50%), 28px 284px hsl(1533.6, 100%, 50%), 27px 285px hsl(1539, 100%, 50%), 25px 286px hsl(1544.4, 100%, 50%), 23px 287px hsl(1549.8, 100%, 50%), 22px 288px hsl(1555.2, 100%, 50%), 20px 289px hsl(1560.6, 100%, 50%), 18px 290px hsl(1566, 100%, 50%), 16px 291px hsl(1571.4, 100%, 50%), 14px 292px hsl(1576.8, 100%, 50%), 13px 293px hsl(1582.2, 100%, 50%), 11px 294px hsl(1587.6, 100%, 50%), 9px 295px hsl(1593, 100%, 50%), 7px 296px hsl(1598.4, 100%, 50%), 5px 297px hsl(1603.8, 100%, 50%), 3px 298px hsl(1609.2, 100%, 50%), 1px 299px hsl(1614.6, 100%, 50%), 2px 300px hsl(1620, 100%, 50%), -1px 301px hsl(1625.4, 100%, 50%), -3px 302px hsl(1630.8, 100%, 50%), -5px 303px hsl(1636.2, 100%, 50%), -7px 304px hsl(1641.6, 100%, 50%), -9px 305px hsl(1647, 100%, 50%), -11px 306px hsl(1652.4, 100%, 50%), -13px 307px hsl(1657.8, 100%, 50%), -14px 308px hsl(1663.2, 100%, 50%), -16px 309px hsl(1668.6, 100%, 50%), -18px 310px hsl(1674, 100%, 50%), -20px 311px hsl(1679.4, 100%, 50%), -22px 312px hsl(1684.8, 100%, 50%), -23px 313px hsl(1690.2, 100%, 50%), -25px 314px hsl(1695.6, 100%, 50%), -27px 315px hsl(1701, 100%, 50%), -28px 316px hsl(1706.4, 100%, 50%), -30px 317px hsl(1711.8, 100%, 50%), -32px 318px hsl(1717.2, 100%, 50%), -33px 319px hsl(1722.6, 100%, 50%), -35px 320px hsl(1728, 100%, 50%), -36px 321px hsl(1733.4, 100%, 50%), -38px 322px hsl(1738.8, 100%, 50%), -39px 323px hsl(1744.2, 100%, 50%), -41px 324px hsl(1749.6, 100%, 50%), -42px 325px hsl(1755, 100%, 50%), -43px 326px hsl(1760.4, 100%, 50%), -45px 327px hsl(1765.8, 100%, 50%), -46px 328px hsl(1771.2, 100%, 50%), -47px 329px hsl(1776.6, 100%, 50%), -48px 330px hsl(1782, 100%, 50%), -49px 331px hsl(1787.4, 100%, 50%), -50px 332px hsl(1792.8, 100%, 50%), -51px 333px hsl(1798.2, 100%, 50%), -52px 334px hsl(1803.6, 100%, 50%), -53px 335px hsl(1809, 100%, 50%), -54px 336px hsl(1814.4, 100%, 50%), -55px 337px hsl(1819.8, 100%, 50%), -55px 338px hsl(1825.2, 100%, 50%), -56px 339px hsl(1830.6, 100%, 50%), -57px 340px hsl(1836, 100%, 50%), -57px 341px hsl(1841.4, 100%, 50%), -58px 342px hsl(1846.8, 100%, 50%), -58px 343px hsl(1852.2, 100%, 50%), -58px 344px hsl(1857.6, 100%, 50%), -59px 345px hsl(1863, 100%, 50%), -59px 346px hsl(1868.4, 100%, 50%), -59px 347px hsl(1873.8, 100%, 50%), -59px 348px hsl(1879.2, 100%, 50%), -59px 349px hsl(1884.6, 100%, 50%), -60px 350px hsl(1890, 100%, 50%), -59px 351px hsl(1895.4, 100%, 50%), -59px 352px hsl(1900.8, 100%, 50%), -59px 353px hsl(1906.2, 100%, 50%), -59px 354px hsl(1911.6, 100%, 50%), -59px 355px hsl(1917, 100%, 50%), -58px 356px hsl(1922.4, 100%, 50%), -58px 357px hsl(1927.8, 100%, 50%), -58px 358px hsl(1933.2, 100%, 50%), -57px 359px hsl(1938.6, 100%, 50%), -57px 360px hsl(1944, 100%, 50%), -56px 361px hsl(1949.4, 100%, 50%), -55px 362px hsl(1954.8, 100%, 50%), -55px 363px hsl(1960.2, 100%, 50%), -54px 364px hsl(1965.6, 100%, 50%), -53px 365px hsl(1971, 100%, 50%), -52px 366px hsl(1976.4, 100%, 50%), -51px 367px hsl(1981.8, 100%, 50%), -50px 368px hsl(1987.2, 100%, 50%), -49px 369px hsl(1992.6, 100%, 50%), -48px 370px hsl(1998, 100%, 50%), -47px 371px hsl(2003.4, 100%, 50%), -46px 372px hsl(2008.8, 100%, 50%), -45px 373px hsl(2014.2, 100%, 50%), -43px 374px hsl(2019.6, 100%, 50%), -42px 375px hsl(2025, 100%, 50%), -41px 376px hsl(2030.4, 100%, 50%), -39px 377px hsl(2035.8, 100%, 50%), -38px 378px hsl(2041.2, 100%, 50%), -36px 379px hsl(2046.6, 100%, 50%), -35px 380px hsl(2052, 100%, 50%), -33px 381px hsl(2057.4, 100%, 50%), -32px 382px hsl(2062.8, 100%, 50%), -30px 383px hsl(2068.2, 100%, 50%), -28px 384px hsl(2073.6, 100%, 50%), -27px 385px hsl(2079, 100%, 50%), -25px 386px hsl(2084.4, 100%, 50%), -23px 387px hsl(2089.8, 100%, 50%), -22px 388px hsl(2095.2, 100%, 50%), -20px 389px hsl(2100.6, 100%, 50%), -18px 390px hsl(2106, 100%, 50%), -16px 391px hsl(2111.4, 100%, 50%), -14px 392px hsl(2116.8, 100%, 50%), -13px 393px hsl(2122.2, 100%, 50%), -11px 394px hsl(2127.6, 100%, 50%), -9px 395px hsl(2133, 100%, 50%), -7px 396px hsl(2138.4, 100%, 50%), -5px 397px hsl(2143.8, 100%, 50%), -3px 398px hsl(2149.2, 100%, 50%), -1px 399px hsl(2154.6, 100%, 50%); font-size: 40px;&#x27;console.log(&#x27;%cI am so happy today !&#x27;, css) console 其实还有很多有用的方法console.warn警告 1console.warn(&#x27;This is a warning&#x27;) console.error错误 1console.warn(&#x27;This is a warning&#x27;) console.count计数, 相同的 label 数量会相加 (可以用来统计函数调用次数) 12345678910111213141516console.count()console.count()console.count()console.count(&#x27;ddd&#x27;)console.count(&#x27;hhh&#x27;)console.count(&#x27;ddd&#x27;)console.count(&#x27;hhh&#x27;)// 结果:// default: 1// default: 2// default: 3// ddd: 1// hhh: 1// ddd: 2// hhh: 2 console.assert断言, 断言为 false，则将打印一个错误消息 12let num = 10console.assert(num &lt; 5, &quot;num is large than 5&quot;) console.debug只有在level包含Verbose的时候才显示 1console.debug(&#x27;Only view at the &quot;debug&quot; log level&#x27;) console.info只有在level包含Info的时候才显示 console.dir打印出该对象的所有属性和属性值. 12345678910111213let obj = &#123; a: 1, b: &#123; bb: 22, cc: &#123; ccc: 222 &#125; &#125;, fn() &#123; return &#125;&#125;console.dir(obj) 和普通的log好像没什么区别? console.dirxml1console.dirxml(document) 和普通的log好像没什么区别? console.group() / console.groupEnd()分组 1console.group(&#x27;out&#x27;);console.log(&#x27;1&#x27;);console.log(&#x27;2&#x27;);console.group(&#x27;inner&#x27;);console.log(&#x27;333&#x27;); console.table表格得形式展示对象/数组 console.time() / console.timeEnd()可以用于计时(参数用于区分多个timer, 也用于显示打印的label) 123456console.time(&#x27;Traversal&#x27;);let i = 100000000;while(i &gt;= 0)&#123; i--;&#125;console.timeEnd(&#x27;Traversal&#x27;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"浏览器：浏览器网络安全整理","slug":"浏览器-csrf和xss攻击整理","date":"2019-09-30T13:47:35.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"浏览器-csrf和xss攻击整理/","link":"","permalink":"https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-csrf%E5%92%8Cxss%E6%94%BB%E5%87%BB%E6%95%B4%E7%90%86/","excerpt":"记一下 csrf 和 xss","text":"记一下 csrf 和 xss 同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。 CSP 策略配置内容安全策略涉及到添加 Content-Security-Policy HTTP 头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的 action 属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。制定策略： Content-Security-Policy: policy Content-Security-Policy: default-src ‘self’ Content-Security-Policy: default-src ‘self’ _.trusted.com Content-Security-Policy: default-src ‘self’; img-src _; media-src media1.com media2.com; script-src userscripts.example.com Content-Security-Policy: default-src https://onlinebanking.jumbobank.com Content-Security-Policy: default-src ‘self’ _.mailsite.com; img-src _ 跨站脚本攻击（XSS）XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。 危害： 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。 可以监听用户行为。 恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。 可以通过修改 DOM 伪造内容 还可以在页面内生成浮窗广告 。。。 如何注入 存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。 存储型是用户输入的恶意脚本地址被存储到数据库，当哦用户访问页面时，被展示出来，浏览器识别成 script 脚本。这个时候这个脚本就可以读取 cookie 信息，操作 dom 了，监听输入了。 反射型跟存储型的区别在于服务器没有存储反射型 XSS 攻击的恶意脚本。 基于 DOM 的攻击。在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的等等。 如何阻止 XSS 攻击 输入来源：服务器对输入脚本进行过滤或转码。如 &gt; 转换成 &amp;gt, 或者直接过滤掉 &lt;script&gt; 充分利用 CSP 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的； 禁止向第三方域提交数据，这样用户数据也不会外泄； 禁止执行内联脚本和未授权的脚本； 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。 使用 HttpOnly 属性 CSRF 攻击CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。 发起 CSRF 攻击的三个必要条件： 目标站点一定要有 CSRF 漏洞； 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态； 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。 防止： 利用好 Cookie 的 SameSite 属性 验证请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性。Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。 CSRF Token 第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。 第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。 CSRF Token 和 JWT 的区别CSRF Token 是用来防范 CSRF 攻击的。JWT 主要用于用户身份认证（http 无状态，所以这种方式将 session id 加密存储在客户端，而不是存储在后端唯一的 session 服务，因为这样不好做负载均衡） session 和 cookieHTTP 是无状态的,为了能够在 HTTP 协议之上保持住状态,比如用户是否登陆、购物车等等。这种技术就叫 Session。Session 的功能是把一个个分离的 HTTP 请求关联起来，只要能实现这个功能，基本上都能叫 Session 的一种实现。 在 Cookie 里放个 JSESSIONID，在服务器中存上状态，用户请求来了，根据 JSESSIONID 去服务器里查状态，这是 Tomcat 的实现方法。 把所有状态都存在 Cookie 里，服务器给个签名防止伪造，每次请求来了，直接从 Cookie 里提取状态，这是 JWT 的实现方法。 在 Cookie 里放个 token，状态不存在中间件里，而是存在 Redis 里，这也是一种 Session 实现方法。 只要 HTTP 还是无状态的，只要保存状态还是刚需，Session 就不会消失，变化的只是它的实现方式。 举个例子，只要人们还要出行，交通工具就不可能消失，只是实现的方法从走路变成了马车，在变成火车、汽车、飞机，未来可能还有火箭啥的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"浏览器","slug":"浏览器","permalink":"https://laputaz.github.io/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"网络安全","slug":"网络安全","permalink":"https://laputaz.github.io/home/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"js基础-深拷贝/扁平化/数组去重/节流/防抖/promise/大数相加","slug":"js-深拷贝-扁平化-去重-节流防抖-promise-大数相加","date":"2019-09-04T12:21:48.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-深拷贝-扁平化-去重-节流防抖-promise-大数相加/","link":"","permalink":"https://laputaz.github.io/home/js-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%89%81%E5%B9%B3%E5%8C%96-%E5%8E%BB%E9%87%8D-%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96-promise-%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"深拷贝/扁平化/数组去重/节流/防抖","text":"深拷贝/扁平化/数组去重/节流/防抖 背景这一些操作都是老生常谈了，是必拿分，不能出任何差错。手写一遍，方便记忆。循序渐进，不要想着一步到位。 深拷贝 乞丐版本。JSON.stringify() / JSON.parse() 12345678910111213141516171819202122let obj = &#123; a: 1, b: &#123; w: 4 &#125; &#125;let obj1 = JSON.parse(JSON.stringify(obj))console.log(obj1)// 此方法问题在于, 若属性的值为undefined或者函数, 会造成属性丢失let obj2 = &#123; a: 1, b: &#123; w: 4, k: undefined, func() &#123;&#125;, arr: [undefined, 1, function () &#123;&#125;] &#125;,&#125;let obj3 = JSON.parse(JSON.stringify(obj2))console.log(obj3)// &#123;// &quot;a&quot;: 1,// &quot;b&quot;: &#123;// &quot;w&quot;: 4,// &quot;arr&quot;: [// null,// 1,// null// ]// &#125;// &#125; 基础版 12345678910111213// 递归的模板function deepClone(target) &#123; // 出口 if (typeof target !== &#x27;object&#x27;) &#123; return target &#125; let cloneTarget = &#123;&#125; for (let key in target) &#123; // 递归 cloneTarget[key] = deepClone(target[key]) &#125; return cloneTarget&#125; 考虑数组。 12345678910111213// 递归的模板function deepClone(target) &#123; // 出口 if (typeof target !== &#x27;object&#x27;) &#123; return target &#125; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125; for (let key in target) &#123; // 递归 cloneTarget[key] = deepClone(target[key]) &#125; return cloneTarget&#125; 循环引用。如果有循环引用，如： 12const obj = &#123;&#125;obj.a = obj 会造成堆栈溢出： 1Uncaught RangeError: Maximum call stack size exceeded 解决方法是用空间来存储已经遍历过的属性。 1234567891011121314151617function deepClone(target, map = new Map()) &#123; // 出口 if (typeof target !== &#x27;object&#x27;) &#123; return target &#125; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125; if (map.get(target)) &#123; return map.get(target) &#125; else &#123; map.set(target, cloneTarget) &#125; for (let key in target) &#123; // 递归 cloneTarget[key] = deepClone(target[key], map) &#125; return cloneTarget&#125; 扁平化 简单类型, toString() / join() 1234// 只适用于每一项类型相同, 且均为简单类型let arr = [1, 5, [8, 8, 6, [6, 4, 3]]]let arr1 = arr.toString().split(&#x27;,&#x27;).map(Number)let arr2 = arr.join(&#x27;,&#x27;).split(&#x27;,&#x27;).map(Number) reduce 12345678const flatten = (arr) =&gt; &#123; return arr.reduce((cur, next) =&gt; &#123; return cur.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125;console.log(flatten([1, 5, [8, 8, 6, [6, 4, 3]]]))// [ 1, 5, 8, 8, 6, 6, 4, 3 ] 递归 12345678910111213var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]]function flatten(arr) &#123; var res = [] for (let i = 0, length = arr.length; i &lt; length; i++) &#123; if (Array.isArray(arr[i])) &#123; res = res.concat(flatten(arr[i])) //concat 并不会改变原数组 &#125; else &#123; res.push(arr[i]) &#125; &#125; return res&#125;flatten(arr1) //[1, 2, 3, 1, 2, 3, 4, 2, 3, 4] flat 最简单的方法 12// flat参数可以规定扁平化几层, 默认1层let arr = [1, 5, [8, 8, 6, [6, 4, 3, &#123; a: 1, b: 2 &#125;]]].flat(Infinity) 数组去重 Array.filter() + indexOf O(n2) 12345function unique(arr) &#123; return arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) === index &#125;)&#125; 双重 for 循环 O(n2) 1234567891011121314function unique(arr) &#123; let len = arr.length for (let i = 0; i &lt; len; i++) &#123; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[i] == arr[j]) &#123; arr.splice(j, 1) // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一 len-- j-- &#125; &#125; &#125; return arr&#125; for…of + includes() O(n2) 1234567function unique(arr) &#123; let result = [] for (let i of arr) &#123; !result.includes(i) &amp;&amp; result.push(i) &#125; return result&#125; Array.sort() + for O(nlogn) 123456789function unique(arr) &#123; arr = arr.sort() let result = [arr[0]] for (let i = 1, len = arr.length; i &lt; len; i++) &#123; arr[i] !== arr[i - 1] &amp;&amp; result.push(arr[i]) &#125; return result&#125; new Set() 1234function unique(arr) &#123; return Array.from(new Set(arr)) return [...new Set(arr)]&#125; for…of + Object O(n) 12345678910111213function unique(arr) &#123; let result = [] let obj = &#123;&#125; for (let i of arr) &#123; if (!obj[i]) &#123; result.push(i) obj[i] = 1 &#125; &#125; return result&#125; 节流每隔一段时间，只执行一次函数。 场景： 滚动加载，加载更多或滚到底部监听 高频点击提交，表单重复提交 mousemove 执行一次，离开后不执行 1234567891011121314function throttle(func, wait) &#123; var context, args var previous = 0 return function () &#123; var now = +new Date() context = this args = arguments if (now - previous &gt; wait) &#123; func.apply(context, args) previous = now &#125; &#125;&#125; 第一次不执行，离开后再执行 123456789101112131415function throttle(func, wait) &#123; var context, args var timeout return function () &#123; context = this args = arguments if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 组合版 12345678910111213141516171819202122232425262728293031// 第三版function throttle(func, wait) &#123; var timeout, context, args, result var previous = 0 var later = function () &#123; previous = +new Date() timeout = null func.apply(context, args) &#125; var throttled = function () &#123; var now = +new Date() //下次触发 func 剩余的时间 var remaining = wait - (now - previous) context = this args = arguments // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; previous = now func.apply(context, args) &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining) &#125; &#125; return throttled&#125; 防抖最后一次操作完几秒后再执行。只需触发一次回调。 场景：搜索框搜索输入。只需用户最后一次输入完，再发送请求手机号、邮箱验证输入检测窗口大小 Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 初版 12345678// 第一版function debounce(func, wait) &#123; var timeout return function () &#123; clearTimeout(timeout) timeout = setTimeout(func, wait) &#125;&#125; this 和 参数 1234567891011121314// 第三版function debounce(func, wait) &#123; var timeout return function () &#123; var context = this var args = arguments clearTimeout(timeout) timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait) &#125;&#125; 立即执行 1234567891011121314151617181920212223// 第四版function debounce(func, wait, immediate) &#123; var timeout return function () &#123; var context = this var args = arguments if (timeout) clearTimeout(timeout) if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout timeout = setTimeout(function () &#123; timeout = null &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; promisehttps://github.com/xieranmaya/blog/issues/3 大数相加12345678910111213141516var addStrings = function (num1, num2) &#123; let i = num1.length - 1, j = num2.length - 1, add = 0 const ans = [] while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123; const x = i &gt;= 0 ? +num1.charAt(i) : 0 const y = j &gt;= 0 ? +num2.charAt(j) : 0 const result = x + y + add ans.push(result % 10) add = Math.floor(result / 10) i -= 1 j -= 1 &#125; return ans.reverse().join(&#x27;&#x27;)&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：Symbol 的作用","slug":"js基础-Symbol的作用","date":"2019-08-17T20:10:05.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-Symbol的作用/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-Symbol%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"symboooool","text":"symboooool Symbol 是什么symbol 是一种基本数据类型，Symbol() 函数是一个静态方法，会返回一个 symbol 类型的值，但它不是一个构造函数。 Symbol 的作用在 js 代码中，对象的属性 key 必须是字符串，当使用引用类型作为 key 时，会调用 Symbol.toPrimitive / toString 转换成一个字符串。如： 12345const a = &#123;&#125;console.log(&#123; [a]: 1,&#125;)// 输出 &#123;[object Object]: 1&#125; Symbol 的一个主要作用就是作为对象的 key =&gt; 这可不是我瞎说的，原话： 一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。 Symbol 作为 key 有什么优势呢 因为 Symbol 生成的值是唯一的，所以可以保证 key 不冲突。当我们在写一个工具方法、库的时候，例如要在 window 上挂载一个全局变量，可能存在命名的冲突（虽然可能性也不大）。如果用 Symbol 就可以避免。 1234567const key1 = Symbol(&#x27;my-util&#x27;) // 参数仅仅作为标识作用const key2 = Symbol(&#x27;my-util&#x27;)window[key1] = function () &#123;&#125;window[key2] = function () &#123;&#125;key1 === key2 // false 但是 uuid 不也可以实现吗？可以是可以，但 Symbol 类型的 key 值还有一个特性，就是它会在遍历时/序列化时被隐藏，可以模仿私有属性，如： 123456789101112131415const key = Symbol(&#x27;private&#x27;)const obj = &#123; [key]: 1, num: 2,&#125;// 遍历for (let key in obj) &#123; console.log(key) // num&#125;// 取出keyObject.getOwnPropertyNames(obj) // [&#x27;num&#x27;]// 取出keyObject.keys(obj) // [&#x27;num&#x27;]// 序列化JSON.stringify(obj) // &#x27;&#123;&quot;num&quot;:2&#125;&#x27; 虽然如此，但是 uuid 也可以实现类似的效果，只要关掉可枚举即可 123456Object.defineProperty(obj, &#x27;num&#x27;, &#123; value: 2, enumerable: false,&#125;)// 取出keyObject.keys(obj) // [&#x27;num&#x27;] 而且强行要访问 symbol 类型的 key 也是可以的： 1234Object.getOwnPropertySymbols(obj) // [Symbol(private)]// 取const keySymbol = Object.getOwnPropertySymbols(obj)[0]console.log(obj[keySymbol]) // 1 所以要模拟也不是不行，但是 Symbol 更简便，为什么不用呢。 综上：Symbol 的作用在于生成唯一的值，并且作为一种弱形式的信息隐藏，主要作用是作为对象属性的标识符。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：valueOf、toString、[Symbol.toPrimitive] 方法解析","slug":"js基础-valueOf-toString解析","date":"2019-08-16T16:06:11.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-valueOf-toString解析/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-valueOf-toString%E8%A7%A3%E6%9E%90/","excerpt":"valueOf 和 toString，我们在日常使用中很少会手动调用，[Symbol.toPrimitive] 就更少了，这里记录一下他们的用途。","text":"valueOf 和 toString，我们在日常使用中很少会手动调用，[Symbol.toPrimitive] 就更少了，这里记录一下他们的用途。 是什么MDN 的说法是： 123- valueOf() 方法返回指定对象的&#x27;原始值&#x27;。- toString() 方法返回一个表示该对象的字符串。- [Symbol.toPrimitive]() 当一个对象转换为对应的&#x27;原始值&#x27;时，会调用此函数。 问题来了， 什么是原始值 ？ MDN 的说法是： In JavaScript, a primitive (primitive value, primitive data type) is data that is not an object and has no methods. There are 7 primitive data types: string, number, bigint, boolean, undefined, symbol, and null. 基本上可以理解为，原始数据、原始值是一种既非对象也无方法的数据，也就是基本数据类型。 不同类型对象的表现用途很少会显式地使用这三个方法（除了 toString 偶尔会用到）当对象需要被转换成原始值的时候，就会被调用，例如： 12345678910111213const obj = &#123; a: 1,&#125;// 算术运算obj + 1 // NaN// 拼接obj + &#x27;&#x27;// 当成obj的keyconst obj1 = &#123; [obj]: 1,&#125;// 当做一些方法的参数alert(obj) 以上这些场景发生的时候，就会隐式调用这三个方法。 优先级重写三个方法，尝试每个转换场景，看看每个场景下，这三个函数的调用优先级； 1234567891011121314151617181920212223242526272829303132333435// 重写三个方法const obj = &#123; valueOf() &#123; console.log(&#x27;valueOf called&#x27;) return 1 &#125;, toString() &#123; console.log(&#x27;toString called&#x27;) return 2 &#125;, [Symbol.toPrimitive]() &#123; console.log(&#x27;Symbol.toPrimitive called&#x27;) return 3 &#125;,&#125;// 比较obj &gt; 1 // Symbol.toPrimitive called// 运算obj + 1 // Symbol.toPrimitive calledobj + &#x27;&#x27; // Symbol.toPrimitive called// 逻辑!obj // 未调用obj || true // 未调用// 条件if (obj) &#123; // 未调用 console.log(&#x27;haha&#x27;)&#125;// 作为属性const b = &#123; [obj]: 1, // Symbol.toPrimitive called&#125;// 作为参数alert(obj) // Symbol.toPrimitive called 结论一：Symbol.toPrimitive 调用优先级最高, 当存在 Symbol.toPrimitive 方法时， 所有转换都会调用它 12345678910111213141516171819202122232425262728293031// 重写 valueOf 和 toStringconst obj = &#123; valueOf() &#123; console.log(&#x27;valueOf called&#x27;) return 1 &#125;, toString() &#123; console.log(&#x27;toString called&#x27;) return 2 &#125;,&#125;// 比较obj &gt; 1 // valueOf called// 运算obj + 1 // valueOf calledobj + &#x27;&#x27; // valueOf calledobj * 1 // valueOf called// 逻辑!obj // 未调用obj || true // 未调用// 条件if (obj) &#123; // 未调用 console.log(&#x27;haha&#x27;)&#125;// 作为属性const b = &#123; [obj]: 1, // toString called&#125;// 作为参数alert(obj) // toString called 结论二： 比较和算术运算 =&gt; valueOf, 作为对象的 key、作为函数参数时 =&gt; toString 无聊的运用有一道面试题，是让 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 成立；老实说这种题目就是脑残，单纯是为了炫技，实际工作谁要这样写，不会被 n+1 ? 思路是，当使用 == 的时候会发生隐式转换，会调用 valueOf，所以只要劫持 valueOf 即可，解法： 12345678910class A &#123; constructor(value) &#123; this.value = value &#125; valueOf() &#123; return this.value++ &#125;&#125;const a = new A(1)console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 如果是 === 怎么办，a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3=== 不会有隐式转换，所以用 defineProperty 劫持就好了 12345678// definePropertyconst value = 1Object.defineProperty(window, &#x27;a&#x27;, &#123; get() &#123; return value++ &#125;,&#125;)console.log(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"vue-生命周期整理","slug":"vue-生命周期整理","date":"2019-07-19T12:34:50.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"vue-生命周期整理/","link":"","permalink":"https://laputaz.github.io/home/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%95%B4%E7%90%86/","excerpt":"","text":"生命周期开始创建、初始化数据、编译模板、挂载 Dom、渲染 → 更新 → 渲染、激活、移除、销毁 el 优先级 render 函数选项 &gt; template 参数 &gt; 外部 HTML 过程 new Vue() 初始化实例 beforeCreate() (数据/计算属性/方法 未初始化, Dom 未挂载) 初始化 数据/计算属性/方法 created() (数据/计算属性/方法 已初始化, Dom 未挂载) 查找对应的模板，编译模板为虚拟 Dom beforeMounted() (数据/计算属性/方法 已初始化, Dom 未挂载) 挂载 Dom mounted() (数据/计算属性/方法 已初始化, Dom 已挂载) 更新 首先触发 watch 再触发 beforeUpdate() 再触发 updated() beforeUpdate(), updated()中不能更改数据，否则会陷入死循环 激活 activated() -&gt; for keep-alive，组件被激活时调用 deactivated() -&gt; for keep-alive，组件被移除时调用 销毁 $destroy 方法被调用的时候就会执行 beforeDestroy() destroyed() 一般 beforeDestroy()善后, destroyed()也可以:清除计时器、清除非指令绑定的事件等等 数据和方法还存在,但无法操作 Dom 了","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"js基础：简单的拖动实例","slug":"js基础-简单的拖动实例","date":"2019-07-18T18:17:48.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-简单的拖动实例/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E7%9A%84%E6%8B%96%E5%8A%A8%E5%AE%9E%E4%BE%8B/","excerpt":"拖动也总是忘记，简单实现记录一下。demo: https://laputaz.github.io/move/","text":"拖动也总是忘记，简单实现记录一下。demo: https://laputaz.github.io/move/ Demo: https://laputaz.github.io/move/ 相关事件mousedown / mouseup / mousemove 实现思路最终效果：目标块在外部容器内随意拖动，不超出。 将容器设置为相对定位，目标块设置为绝对定位。 为目标块绑定 mousedown，记录按下鼠标时，鼠标相对于目标块的位置 (diffX / diffY)。 在容器上绑定 mousemove 事件，鼠标移动时，设置目标块的 left 和 top 值 left 的计算(top 同理)： left 的最大值： 代码实现123456789101112131415161718192021222324252627282930313233343536373839let outer = document.querySelector(&#x27;.outer&#x27;)let item = document.querySelector(&#x27;.item&#x27;)let diffX = 0let diffY = 0let moving = falseitem.addEventListener(&#x27;mousedown&#x27;, function (e) &#123; item.style.cursor = &#x27;move&#x27; moving = true // 记录按下鼠标时，鼠标相对于目标块的位置 diffX = e.offsetX diffY = e.offsetY&#125;)window.addEventListener(&#x27;mouseup&#x27;, function (e) &#123; item.style.cursor = &#x27;default&#x27; moving = false&#125;)outer.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; if (!moving) return // 计算 left 和 top let l = e.x - outer.offsetLeft - diffX let t = e.y - outer.offsetTop - diffY // left 不能小于 0 item.style.left = l &lt; 0 ? 0 : l + &#x27;px&#x27; item.style.top = t &lt; 0 ? 0 : t + &#x27;px&#x27; // left 不能超过 outer.clientWidth - item.clientWidth let DX = outer.clientWidth - item.clientWidth if (DX &lt; l) &#123; item.style.left = DX + &#x27;px&#x27; &#125; let DY = outer.clientHeight - item.clientHeight if (DY &lt; t) &#123; item.style.top = DY + &#x27;px&#x27; &#125;&#125;) 以上。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}]},{"title":"小程序：赛博朋克 2077 倒计时-以及简单的云开发","slug":"小程序-cyberpunk-wechat","date":"2019-07-05T00:49:13.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"小程序-cyberpunk-wechat/","link":"","permalink":"https://laputaz.github.io/home/%E5%B0%8F%E7%A8%8B%E5%BA%8F-cyberpunk-wechat/","excerpt":"闲来无事, 做了一个赛博朋克 2077 发售倒计时页面","text":"闲来无事, 做了一个赛博朋克 2077 发售倒计时页面 AppID申请到一个小程序后, 会对应一个 AppID 基本目录结构1234- cloudfunctions 云函数目录- miniprogram 开发目录- README.md 描述项目- project.config.json 项目配置 cloudfunctions结构如图, 每一个云函数会新建一个目录, index.js 为入口, login / openapi 是自带的, 可以获取 AppID 等 miniprogram结构如图:images 存放静态图片miniprogram_npm 是 npm 安装的依赖构建 node_module 后生成的库文件目录pages 下编写各个界面style 下存储了一些样式文件app.js / app.json 分别是程序入口 和主界面配置 以 app.json 为例 1234567891011121314151617181920212223242526272829&#123; &quot;pages&quot;: [&quot;pages/imghander/imghander&quot;, &quot;pages/base/base&quot;], &quot;window&quot;: &#123; &quot;backgroundColor&quot;: &quot;#F6F6F6&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#faf003&quot;, &quot;navigationBarTitleText&quot;: &quot;Cyberpunk 2077&quot;, &quot;navigationBarTextStyle&quot;: &quot;white&quot; &#125;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;, &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#000000&quot;, &quot;selectedColor&quot;: &quot;#000000&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/imghander/imghander&quot;, &quot;text&quot;: &quot;2077&quot;, &quot;iconPath&quot;: &quot;images/film.png&quot;, &quot;selectedIconPath&quot;: &quot;images/film-actived.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/base/base&quot;, &quot;text&quot;: &quot;Cyberpunk&quot;, &quot;iconPath&quot;: &quot;images/profile.png&quot;, &quot;selectedIconPath&quot;: &quot;images/profile-actived.png&quot; &#125; ] &#125;&#125; pages属性 定义界面路径, 相当于路由 tabBar属性定义了底栏相关的属性window属性定义了标题栏的文字和颜色 , 文字颜色 navigationBarTextStyle 只能是 black 或 white 页面目录 pages以 pages 下的 base 为例一个页面初始化会包含四个文件 1234js - &gt; 页面逻辑json -&gt; 页面配置, 如安装vant库后, usingComponents 可以引入需要的组件wxml -&gt; 页面结构wxss -&gt; 页面样式 下面看一下一个 js 文件的内容 pages=&gt;页面=&gt;js以 pages=&gt;base=&gt;base.js 为例, 结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// pages/base/base.jsconst db = new wx.cloud.database()Page(&#123; /** * 页面的初始数据 */ data: &#123;&#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123;&#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123;&#125;,&#125;) 预置了很多生命周期函数 效果 云开发云开发环境创建的时候, 一个账号可以提供两个环境, 每个环境可以设置 id 云数据库json 形式数据库, 每一条数据都是 json 格式的对象 , 与关系型数据库差异如图, 基于 mongoDB关系型数据库更适合表之间有复杂的关联关系, 文档型更适合频繁的读写操作, 效率高一些包含以下数据类型在小程序端操作会有权限控制, 而云函数操作则有完全的读写控制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//初始化const db = wx.cloud.database(&#123; env: &#x27;dh&#x27; &#125;) // 传入环境名// 插入数据, 可以用毁掉的写法, 也可以用promise写法// 插入的数据会有 id 主键 和 _openid 标识插入的用户db.collection(&#x27;user&#x27;).add(&#123; data: &#123; name: &#x27;dh&#x27;, time: &#x27;2019&#x27;, &#125;, success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.log(err) &#125;,&#125;)// promise写法db.collection(&#x27;user&#x27;) .add(&#123; data: &#123; name: &#x27;dh&#x27;, time: &#x27;2019&#x27;, &#125;, &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// 更新数据, doc拿到记录db.collection(&#x27;user&#x27;) .doc(&#x27;as1h35idf4g56ahafhjioasdf&#x27;) .update(&#123; data: &#123; name: &#x27;dh1&#x27;, time: &#x27;2019&#x27;, &#125;, &#125;)// 查找db.collection(&#x27;user&#x27;).where(&#123; name: &#x27;dh1&#x27; &#125;).get()// 删除 多条数据删除, 需要在云函数进行db.collection(&#x27;user&#x27;).doc(&#x27;as1h35idf4g56ahafhjioasdf&#x27;).remove() 云函数云函数, 保存在云 云存储云存储能力 wx.cloud.uploadFile // 上传 wx.cloud.downloadFile //下载 wx.cloud.deleteFile // 删除 wx.cloud.getTempFileUrl // 临时路径 …. …. 举个简单的例子-上传用户打开相册选择图片 1wx.chooseImage() // promise 可以拿到文件临时路径 上传至云存储 12345678wx.cloud.uploadFile(&#123; ... filePath: &#x27;&#x27; // 传入上一步读取的文件临时路径 ... ...&#125;).then(res =&gt; &#123; console.log(res.fileID)&#125;) // promise 可以拿到文件的 fileID 拿到 fileID 存到云数据库, 便于操作(fileID 可以直接用于 image 组件的 src) 12db.collection(&#x27;image&#x27;).add(&#123;fileID:fileID&#125;) // 在新建的image表中插入记录&lt;image src=&quot;&#123;fileID&#125;&quot;&gt;&lt;/image&gt; //可展示 举个简单的例子-下载通过 data-xxx 自定义属性 1&lt;button data-fileid=&quot;agsyuadi123asda&quot; bindTap=&quot;download&quot;&gt;下载&lt;/button&gt; 使得点击的时候通过 event 获取到文件的 fileID, downloadFile 方法拿到 filePath, 保存到本地 123456789download(e)&#123; wx.cloud.downloadFile(&#123; fileID: e.target.dataset.fileid &#125;).then(res =&gt; &#123; // wx.saveImageToPhotoAlbum(&#123; //保存 filePath: res.filePath &#125;) &#125;)&#125;","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"小程序","slug":"小程序","permalink":"https://laputaz.github.io/home/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"跨端","slug":"跨端","permalink":"https://laputaz.github.io/home/tags/%E8%B7%A8%E7%AB%AF/"}]},{"title":"js基础：递归，迭代，和尾调用优化","slug":"2019-6-22-js基础-递归迭代和尾调用优化","date":"2019-06-22T23:23:25.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"2019-6-22-js基础-递归迭代和尾调用优化/","link":"","permalink":"https://laputaz.github.io/home/2019-6-22-js%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E5%92%8C%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/","excerpt":"面试 futu 遇到的问题","text":"面试 futu 遇到的问题 场景今天去面试 futu, 被问到一题 -&gt; 参数为数字, 输出斐波那契数列对应结果, 实现了一下 1234function fibonacci(n) &#123; if (n == 1 || n == 2) return 1 return fibonacci(n - 1) + fibonacci(n - 2)&#125; 123456789然后面试官问: &quot;你觉得这个有什么问题 ?&quot;我: &quot;(⊙o⊙)…忘记判断参数类型了.&quot;面试官: &quot;不是这个问题.&quot;我: &quot;嗯..嗯...嗯.呃...这个...&quot;面试官: &quot;如果数字很大会怎么样?&quot;我: &quot;会...性能很差&quot;面试官: &quot;嗯, 会爆炸, 为什么? 那怎么改?&quot;我: &quot;嗯..嗯...嗯.呃...不会...&quot;面试官: &quot;你回去查一下吧.&quot; Game Over回来查原来 有个概念叫尾调用优化, 果然还是太菜 什么是尾调用 尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。尾调用-阮一峰 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一个 B 的调用记录。等到 B 运行结束，将结果返回到 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 递归的计算过程（recursive process）包含了两个阶段，先逐级扩展（expansion），构造起一个由被推迟的操作组成的链条（会被解释器保存在堆栈里），然后在收缩（contraction）阶段逐级回溯执行那些操作。随着递归计算步骤的增多，这种方法消耗的资源会越来越大，而且会包含越来越多的冗余操作，上面那个求斐波那契数列的例子（在 SICP 里被称作“树形递归”）在这方面问题尤其严重，因为它的计算步骤会随着参数而指数性的增长。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 看完浏览器原理，简言之，尾递归不用保留上一步的执行上下文，节省了内存。 优化-&gt;尾调用1234567function lastFibonacci(n, acc1, acc2) &#123; if (n == 1) return acc1 return lastFibonacci(n - 1, acc2, acc1 + acc2)&#125;lastFibonacci(6, 1, 1) //8lastFibonacci(7, 1, 1) //13 这样每次都要输入 1,1,可以用柯里化或 es6 加柯里化或 es61234567891011121314151617// 再封装一层柯里化-----------function curringF(acc1, acc2) &#123; return function (n) &#123; return lastFibonacci(n, acc1, acc2) &#125;&#125;let func = curringF(1, 1)func(6) // 8func(7) // 13//或 es6---------function lastFibonacci(n, acc1 = 1, acc2 = 1) &#123; if (n == 1) return acc1 return lastFibonacci(n - 1, acc2, acc1 + acc2)&#125;lastFibonacci(7) //13 虽然解决了占用内存的问题，但是冗余计算还是在的。 递归和迭代的区别 迭代 1234567// 迭代，重复一定的算法，上一次的结果作为达到想要的目的。数学上二分法，牛顿法是很好的迭代例子function iteration(x) &#123; var sum = 1 for (x; x &gt;= 1; x--) &#123; sum = sum * x &#125;&#125; 递归 123456789// 递归，自身调用自身的迭代就是递归。// 但是正式定义好像不是这么说的。这只是我个人理解function recursion(x) &#123; if (x &gt; 1) &#123; return x * recursion(x - 1) &#125; else &#123; return 1 &#125;&#125; 相同点： 递归和迭代都是循环的一种。递归和迭代都用了循环这个手段。 不同点： 程序结构不同 递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。 算法结束方式不同 递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。 效率不同 在循环的次数较大的时候，迭代的效率明显高于递归，因为递归需要保留着上一次的执行环境，在后代得到结果之后需要回溯。递归可能存在冗余计算（比如最典型的是斐波那契数列，计算第 6 个需要计算第 4 个和第 5 个，而计算第 5 个还需要计算第 4 个，所处会重复）。迭代在这方面有绝对优势。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"实现：css 变量加 grid-跑偏的用途","slug":"实现-css变量和grid-跑偏的用途","date":"2019-06-11T12:21:00.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"实现-css变量和grid-跑偏的用途/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-css%E5%8F%98%E9%87%8F%E5%92%8Cgrid-%E8%B7%91%E5%81%8F%E7%9A%84%E7%94%A8%E9%80%94/","excerpt":"css 也是有变量的，基于 grid + css 变量实现类似 css-doodle 的效果https://laputaz.github.io/wordfall-generator/https://laputaz.github.io/maze-generator/","text":"css 也是有变量的，基于 grid + css 变量实现类似 css-doodle 的效果https://laputaz.github.io/wordfall-generator/https://laputaz.github.io/maze-generator/ css 变量我们在写 css 预处理器的时候，例如 scss, 是可以声明变量的，例如： 1234$--var: blue;div &#123; color: $--var;&#125; 其实 css 也是有变量的： 12345678// 父级，变量必须以 -- 开头.parent &#123; --main-bg-color: brown;&#125;// 所有子级都可以继承.parent .child &#123; background-color: var(--main-bg-color);&#125; css 变量同样可以通过 js 操作： 1el.style.setProperty(&#x27;--main-bg-color&#x27;, &#x27;red&#x27;) 整活有一个网站叫 css-doodle，他封装了一些语法，可以用简单的语法配制出复杂的图案，其实就是基于 grid 布局。 上一篇记了一些 grid 常见的属性，这一次加上 css 变量，就可以整活了 文字墙Demo: https://laputaz.github.io/wordfall-generator/ 实现很简单，关键点： 容器 grid-auto-flow 设置为 row dense, 这样产生的空位可以被后续尺寸刚好的子项目填充 子项目 grid-column 设置为 span [num], num 为一定范围内的值 如 1 ~ 5，为子项目大小 子项目设置变量 –word，值为指定文字集中的任意一个 子项目 after 设置 content: var(–word) 点击时重复 3 1234.container &#123; grid-auto-flow: row dense;&#125;cell.style.setProperty(&#x27;--word&#x27;, `&quot;$&#123;word&#125;&quot;`) 迷宫图案Demo: https://laputaz.github.io/maze-generator/ 实现很简单： 按照尺寸将容器划分为若干等分 生成 n 个子项目 给每个子项目定义一个 css 变量 –deg ，值为 [‘45deg’, ‘135deg’, ‘225deg’, ‘315deg’] 之一 给每个子项目设置一个 after 子元素，设置样式 translate: rotate(var(–deg)) 每次点击容器，随机改变第 3 步 1234const randomDeg = () =&gt; [&#x27;45deg&#x27;, &#x27;135deg&#x27;, &#x27;225deg&#x27;, &#x27;315deg&#x27;][Math.round(Math.random() * 3)]let cell = document.createElement(&#x27;div&#x27;)cell.style.setProperty(&#x27;--deg&#x27;, randomDeg())","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"css基础：grid 记录","slug":"css基础-grid记录","date":"2019-06-10T21:35:04.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"css基础-grid记录/","link":"","permalink":"https://laputaz.github.io/home/css%E5%9F%BA%E7%A1%80-grid%E8%AE%B0%E5%BD%95/","excerpt":"grid 总是云里雾里，手写梳理一下","text":"grid 总是云里雾里，手写梳理一下 Grid 布局采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。 12345&lt;div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;&lt;/div&gt; 容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。 行和列的交叉区域，称为”单元格”（cell）。 划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 容器属性 display 设置为 grid 1234div &#123; display: grid; display: inline-grid; // 可以设置为行内元素&#125; grid-template-columns 和 grid-template-rows 分别指定列数和列宽，行数和行高。 12345678&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; grid-template-columns: 50px 20px; grid-template-rows: 100px 40px 100px; &#125;&lt;/style&gt; 也可以使用百分比，如果较为重复，可以缩写为 repeat: 12345678910&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; width: 300px; height: 300px; grid-template-columns: repeat(2, 10% 20%); // 重复两次 ‘10% 20%’ grid-template-rows: repeat(3, 10% 20%); &#125;&lt;/style&gt; 有时，单元格的大小是固定的，但是容器的大小不确定。用 auto-fill 摆放，直到摆不下： 12345678910&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; width: 300px; height: 300px; grid-template-columns: repeat(auto-fill, 40px); grid-template-rows: repeat(auto-fill, 100px); &#125;&lt;/style&gt; 为了方便表示比例关系，网格布局提供了 fr 关键字（fraction 的缩写，意为”片段”）。 12345678910&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; width: 300px; height: 300px; grid-template-columns: 1fr 2fr 40px; grid-template-rows: 2fr 1fr; &#125;&lt;/style&gt; 常见的左右固定，中间自适应布局，可以用 auto 1grid-template-columns: 100px auto 100px; row-gap 属性，column-gap 属性，gap 属性 顾名思义，分别是行的间距，列的间距，以及简写。 grid-template-areas 这是一个很吊的属性，可以用来指定单元格名称，并且用来合并单元格， grid-template-areas 为每个单元格命名，子元素用 grid-area 指定所属，把单元格划分的明明白白的： 12345678910111213141516&lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;grid-area: b; background: rebeccapurple&quot;&gt;b&lt;/div&gt; &lt;div style=&quot;grid-area: c; background: red&quot;&gt;c&lt;/div&gt; &lt;div style=&quot;grid-area: a; background: greenyellow&quot;&gt;a&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; width: 300px; height: 300px; grid-template-areas: &#x27;b b a&#x27; &#x27;b b c&#x27; &#x27;b b c&#x27;; &#125;&lt;/style&gt; grid-auto-flow 表示从横向开始填充（row）还是纵向开始填充（column）当设置为 row dense / column dense 时， 如果有空位，会用后面可以容纳的下的项目去填充 如图，2 已经摆不下了，换了一行： 设置 row dense，发现 3 的尺寸刚好，便会用 3 来填充空虚： justify-items 属性，align-items 属性，place-items 属性 注意：设置的是单元格里的内容 12345.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch; place-items: justify-items | align-items;&#125; 1234start：对齐单元格的起始边缘。end：对齐单元格的结束边缘。center：单元格内部居中。stretch：拉伸，占满单元格的整个宽度（默认值）。 justify-content 属性，align-content 属性，place-content 属性 注意：设置的是单元格本身 1234567.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; place-content: justify-content | align-content;&#125; 项目属性 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性 1234grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线 注意：网格线是从 1 开始，而不是 0 1234567891011121314151617181920&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;first&quot;&gt;葡萄地&lt;/div&gt; &lt;div&gt;西瓜地&lt;/div&gt; &lt;div&gt;番茄地&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: grid; width: 300px; height: 300px; grid-template-columns: 100px 80px; grid-template-rows: 100px 40px 100px; &#125; .first &#123; grid-column-start: 1; // 等同于 grid-column: 1 4; 也等同于 grid-column-start：span 3; grid-column-end: 4; background: purple; color: #fff; &#125;&lt;/style&gt; justify-self 属性，align-self 属性，place-self 属性 与 justify-items 属性，align-items 属性，place-items 属性完全一样，但只作用于本身","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"css基础：BFC/外边距折叠","slug":"css基础-BFC-外边距折叠","date":"2019-06-08T12:28:19.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"css基础-BFC-外边距折叠/","link":"","permalink":"https://laputaz.github.io/home/css%E5%9F%BA%E7%A1%80-BFC-%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0/","excerpt":"什么是 BFC","text":"什么是 BFC BFC 块格式化上下文 (Block Formatting Context) 块格式化上下文（Block Formatting Context)，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，BFC 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。 一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。 下列方式会创建块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值） 匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content 或 strict 的元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug） 加粗的地方尤其常用, 可用来清除浮动带来的高度塌陷; 外边距折叠 块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠。 可以看到, 需要满足以下条件: 块级元素 ( 特意写出来, 是因为要注意 inline-block 有块级元素的一部分特性, 但属于行内元素 - MDN 行内元素列表 ) 非浮动元素 非绝对定位元素 上下外的边距 (也就是说左右是不会折叠的) 相邻, 也就是可以是兄弟, 也可以是父子 所以这里又有一个分类，也就是外边距折叠有两个细分： 兄弟折叠： 相邻兄弟元素外边距折叠 父子折叠： 父子外边距折叠 那怎么消除外边距折叠呢? 浮动 inline-block 绝对定位 创建 BFC 这里要注意：创建 BFC，消除的是父子折叠， 兄弟折叠可不一定， 如 overflow:hidden, display:flex 等等， 仍会与相邻兄弟发生折叠 创建 BFC 的方式有非常多种，而浮动元素、inline-block 元素、绝对定位元素， 只是其中的三种， 这三种恰好又是用于消除外边距折叠的方式， 所以， 消除外边距折叠，有创建BFC这个方法，这种方法消除的是父子折叠， 但反过来， 不能说创建了BFC一定能消除外边距折叠 ，也就是说, 消除折叠的方法， 是创建BFC方法的子集","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"css基础：各种居中方式","slug":"css基础-各种居中方式","date":"2019-06-01T12:21:02.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"css基础-各种居中方式/","link":"","permalink":"https://laputaz.github.io/home/css%E5%9F%BA%E7%A1%80-%E5%90%84%E7%A7%8D%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F/","excerpt":"把居中全实现了一遍，不怕忘记","text":"把居中全实现了一遍，不怕忘记 水平居中 行内元素, 父级是块级, 设置 text-align: center; 12345678&lt;div class=&quot;container&quot;&gt; &lt;span&gt;Center&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .container &#123; text-align: center; &#125;&lt;/style&gt; 块级元素, 宽度确定, margin: 0 auto; 123456789&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;block&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .block &#123; width: 300px; margin: 0 auto; &#125;&lt;/style&gt; 块级元素, 宽度不确定, display: inline-block 或 display: inline 其转换成行内块级, 再套用 1 块级元素, 使用 绝对定位 position:absolute, left:50%, 然后 margin-left: -宽度的一半 px; 或者 transform: translateX(-50%) 12345678910111213&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;block&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; position: relative; &#125; .block &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125;&lt;/style&gt; flex 布局, 父元素添加属性 display: flex; justify-content: center; 123456789&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;block&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: flex; justify-content: center; &#125;&lt;/style&gt; Grid auto xxxpx auto 垂直居中 行高等于盒子的高, line-height === height 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;block&quot;&gt;Center&lt;/span&gt;&lt;/div&gt;&lt;style&gt; .container &#123; height: 300px; &#125; .block &#123; line-height: 300px; &#125;&lt;/style&gt; 块级元素, 使用 绝对定位 position:absolute, top:50%, 然后 margin-top: -宽度的一半 px; 或者 transform: translateY(-50%) flex 布局, 父元素添加属性 display: flex; align-items: center; 123456789&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;block&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; display: flex; align-items: center; &#125;&lt;/style&gt; 水平垂直居中 子元素宽高固定，父元素为非 static，给子元素设置绝对定位，top: 0; right: 0; bottom: 0; left: 0; margin: auto; 12345678910111213141516171819&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;block&quot;&gt;Center&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; height: 300px; position: relative; &#125; .block &#123; position: absolute; top: 0; right: 0; height: 20px; width: 20px; bottom: 0; left: 0; margin: auto; &#125;&lt;/style&gt; 绝对定位，left: 50%; top: 50%; margin-left: –元素宽度的一半 px; margin-top: –元素高度的一半 px; flex 布局, 父元素添加属性 display: flex; justify-content: center;align-items: center; 双飞翼 左右固定, 中间自适应 浮动 12345678910111213141516171819202122232425262728&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;22&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;33&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; &#125; .left &#123; width: 300px; float: left; height: 100%; background-color: purple; &#125; .right &#123; height: 100%; width: 300px; float: right; background-color: red; &#125; .middle &#123; height: 100%; margin: 0 300px; background-color: gold; &#125;&lt;/style&gt; 绝对定位, main left 和 right 等值 123456789101112131415161718192021222324252627282930313233&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;22&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;33&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; position: relative; &#125; .left &#123; width: 300px; position: absolute; left: 0; height: 100%; background-color: purple; &#125; .right &#123; height: 100%; position: absolute; right: 0; width: 300px; background-color: red; &#125; .middle &#123; height: 100%; position: absolute; left: 300px; right: 300px; background-color: gold; &#125;&lt;/style&gt; flex 1234567891011121314151617181920212223242526272829&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;flex&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;flex&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;flex&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; display: flex; &#125; .left &#123; width: 300px; height: 100%; flex-shrink: 0; background-color: lightcoral; &#125; .right &#123; height: 100%; width: 300px; flex-shrink: 0; background-color: hotpink; &#125; .middle &#123; width: 100%; // or flex-grow: 1; background-color: greenyellow; &#125;&lt;/style&gt; table。 还别说，邮件客户端浏览器比较垃圾，经常会用到！ 1234567891011121314151617181920212223242526272829&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left is-inline-block&quot;&gt;table&lt;/div&gt; &lt;div class=&quot;middle is-inline-block&quot;&gt;table&lt;/div&gt; &lt;div class=&quot;right is-inline-block&quot;&gt;table&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; display: table; &#125; .is-inline-block &#123; display: table-cell; &#125; .left &#123; width: 300px; height: 100%; background-color: rosybrown; &#125; .right &#123; width: 300px; height: 100%; background-color: teal; &#125; .middle &#123; background-color: indianred; height: 100%; &#125;&lt;/style&gt; calc()+inline-block 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left is-inline-block&quot;&gt;grid&lt;/div&gt; &lt;div class=&quot;middle is-inline-block&quot;&gt;grid&lt;/div&gt; &lt;div class=&quot;right is-inline-block&quot;&gt;grid&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; /* 行内元素空白字符间距问题 */ font-size: 0; &#125; .is-inline-block &#123; display: inline-block; &#125; .left &#123; width: 300px; height: 100%; background-color: rosybrown; &#125; .right &#123; width: 300px; height: 100%; background-color: teal; &#125; .middle &#123; width: calc(100% - 300px - 300px); background-color: indianred; height: 100%; &#125;&lt;/style&gt; grid 1234567891011121314151617181920212223242526&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;grid&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;grid&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;grid&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; width: 100%; height: 500px; display: grid; grid-template-columns: 300px auto 300px; grid-template-rows: 500px; &#125; .left &#123; width: 100%; background-color: yellowgreen; &#125; .right &#123; width: 100%; background-color: teal; &#125; .middle &#123; width: 100%; background-color: indianred; &#125;&lt;/style&gt;","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"css基础：::before ::after 以及 clear:left, right, both 的错误理解","slug":"css基础-float-clear-fix","date":"2019-05-30T23:33:01.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"css基础-float-clear-fix/","link":"","permalink":"https://laputaz.github.io/home/css%E5%9F%BA%E7%A1%80-float-clear-fix/","excerpt":"对于::before, ::after, 和 clear:left, right, both， 发现以前理解错了，在这里记录一下。","text":"对于::before, ::after, 和 clear:left, right, both， 发现以前理解错了，在这里记录一下。 起因早上看 float 布局时， 突然想起以前学的 clear:both 清除浮动， 其中有个利用 ::after 伪元素的方法， 我动手试了一下,一开始 ，我写成这样： 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125; 效果： 父元素高度没撑开， 现在用上clear: both试试，然后，我写成了这样： 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125;.left::after &#123; content: &#x27;&#x27;; clear: both;&#125; 效果： 还是没撑开啊 ？ nmd, wsm ? ::after不是给left加了一个兄弟吗， clear：both 不是清除前面的浮动效果吗？ 查了一下发现， 我理解错了 !::after给元素增加一个子元素（而不是兄弟元素），放在最后。。。。改成这样就好了 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415.parent &#123; border: 5px solid #000;&#125;.left &#123; float: left; width: 200px; height: 100px; background-color: yellow; opacity: 0.7;&#125;.parent::after &#123; content: &#x27;&#x27;; display: block; clear: both;&#125; OK, 撑开了，看东西还是要细心。。 ::before 和 ::after网络上搜的很多文章的解释是: 在元素前或后产生一个伪元素；这种解释不严谨， 让我误以为，::before 和 ::after生成的元素是兄弟元素 ;现在才发现是不对的（捂脸），来看一下 MDN 上的解释 In CSS, ::after creates a pseudo-element that is the last child of the selected element. It is often used to add cosmetic content to an element with the content property. It is inline by default. CSS 伪元素::after 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合 content 属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。 生成的是子元素。。。::before放在第一位， ::after放在最后。 clear: both为什么clear: both能撑开父级 ？先看一下clear在MDN的解释： clear 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。clear 属性适用于浮动和非浮动元素。 The clear CSS property sets whether an element must be moved below (cleared) floating elements that precede it. The clear property applies to floating and non-floating elements. 也就是说，如果在一个元素加上 clear 属性，那么 清除该元素前面的元素带来的浮动影响， 放在浮动元素的后面 这里， 网络上的说法：clear：both 会消除该元素两侧的浮动， 这是错误的，clear 只能消除在它前面的元素的浮动 ！否则， 为甚么网上搜的所有的方法都用::after, 而不是::before 呢， 因为::before 生成第一个子元素， 浮动元素都在它之后， 根本无法消除。 clear:left，clear:right, clear: both 三者区别在哪？ 直接看效果。 1. clear: left清除前面的float：left元素的影响，可以看到，父容器高度以左浮动2为准了， 此时右浮动还是超出了容器 。 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;左浮动1&lt;/div&gt; &lt;div class=&quot;left&quot; style=&quot;height: 80px&quot;&gt;左浮动2&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右浮动&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 120px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: left;&#125; 2. clear: right同理, 清除该元素前面, 右浮动元素的影响, 此时父容器高度被右浮动撑开了(其实应该说，clear:both 元素被放在右浮动元素的后面了, 所以撑开了) 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;左浮动1&lt;/div&gt; &lt;div class=&quot;left&quot; style=&quot;height: 120px&quot;&gt;左浮动2&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右浮动&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 80px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: right;&#125; 3. clear: both同理, 清除前面的所有浮动元素影响 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;左浮动1&lt;/div&gt; &lt;div class=&quot;left&quot; style=&quot;height: 120px&quot;&gt;左浮动2&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右浮动&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.parent &#123; border: 2px solid #656565; width: 500px; margin: 0 auto;&#125;.left &#123; float: left; height: 50px; width: 100px; background: #2ecc71; opacity: 0.8;&#125;.right &#123; float: right; height: 80px; width: 100px; background: #e74c3c; opacity: 0.8;&#125;.clear &#123; clear: both;&#125; 看东西不认真会导致反复和浪费时间。","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"}]},{"title":"实现：回到顶部","slug":"实现-回到顶部","date":"2019-05-18T17:25:03.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"实现-回到顶部/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/","excerpt":"回到顶部是常见功能，在项目中也有碰到过。实现并不难，记录一波。demo: https://github.com/laputaz/scrollTop","text":"回到顶部是常见功能，在项目中也有碰到过。实现并不难，记录一波。demo: https://github.com/laputaz/scrollTop 回到顶部在页面右下角会固定一个图标，点击后回到顶部。 Demo: https://github.com/laputaz/scrollTop 实现思路，有几种方式： document.documentElement.scrollTop，一直减少，直到为 0 123456789101112// 第一种 ScrollTopfunction byScrollTop() &#123; let oldVal = document.documentElement.scrollTop if (!oldVal) return let timer = setInterval(() =&gt; &#123; document.documentElement.scrollTop = oldVal = oldVal - 50 if (oldVal &lt;= 0) &#123; window.clearInterval(timer) console.log(&#x27;finish&#x27;) &#125; &#125;)&#125; document.documentElement.scrollIntoView 方法，自带 smooth 动画 1234567// 第2种 ScrollIntoViewfunction byScrollIntoView() &#123; document.documentElement.scrollIntoView(&#123; behavior: &#x27;smooth&#x27;, &#125;) console.log(&#x27;finish&#x27;)&#125; window.scrollBy 123// window.scrollBy(x-coord, y-coord); x y 分别偏移// 第3种 scrollBywindow.scrollBy(0, -document.documentElement.scrollTop) 以上。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：花式获取对象属性和冻结对象","slug":"js基础-花式获取对象属性和冻结对象","date":"2018-10-21T17:29:56.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-花式获取对象属性和冻结对象/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E8%8A%B1%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E5%86%BB%E7%BB%93%E5%AF%B9%E8%B1%A1/","excerpt":"本文介绍的是一些获取对象属性和防止对象被修改的方法","text":"本文介绍的是一些获取对象属性和防止对象被修改的方法 获取对象属性先定义一个对象 12345678let obj = &#123; a: 1, b: 2 &#125;obj.__proto__.name = 22obj[Symbol()] = 33Object.defineProperty(obj, &#x27;cc&#x27;, &#123; value: &#x27;cc&#x27;, enumerable: false,&#125;)// &#123;a: 1, b: 2, cc: &quot;cc&quot;, Symbol(): 33&#125; , obj.__proto__.name -&gt; 22 各个方法 for…in -&gt; 遍历对象属性, 拿到可枚举的和原型上的属性, 不能拿到 Symbol 123456for (key in obj) &#123; console.log(key)&#125;// a// b// name Object.keys() -&gt; 返回一个由一个给定对象的自身可枚举属性组成的数组, 不会拿到原型上的属性, 拿不到 Symbol 1Object.keys(obj) // [&quot;a&quot;, &quot;b&quot;] Object.values() -&gt; 返回一个给定对象自身的所有可枚举属性值的数组, 不能拿到 Symbol 1Object.values(obj) //[1, 2] Object.entries() -&gt; 返回一个给定对象自身可枚举属性的键值对数组, 不会拿到原型上的属性 1Object.entries(obj) // [[&quot;a&quot;, 1],[&quot;b&quot;, 2]] Object.getOwnPropertyNames() -&gt; 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol值作为名称的属性）组成的数组 1Object.getOwnPropertyNames(obj) // [&quot;a&quot;, &quot;b&quot;, &quot;cc&quot;] Object.getOwnPropertySymbols() -&gt; 返回一个给定对象自身的所有 Symbol 属性的数组 1Object.getOwnPropertySymbols(obj) //[Symbol()] Reflect.ownKeys() -&gt; 返回一个由目标对象自身的所有属性键组成的数组, 包括不可枚举, Symbol 1Reflect.ownKeys(obj) // [&quot;a&quot;, &quot;b&quot;, &quot;cc&quot;, Symbol()] 冻结、密封对象 不可扩展对象 Object.preventExtensions 不可添加新属性 123456let obj = &#123; a: 1, b: 2 &#125;Object.preventExtensions(obj)obj.c = 1obj // &#123;a:1,b:2&#125;// Object.isExtensible检测是否可扩展console.log(Object.isExtensible(obj)) // false 密封对象 Object.seal 密封对象不可扩展，而且已有的属性成员[[configurable]]特性将被设置成 false（意味着不能删除属性和方法，但是可修改已有属性值） 12345678910111213141516171819202122let obj = &#123; a: &#x27;a&#x27;, b: [1, 2],&#125;// 密封Object.seal(obj)// 删除delete obj.a // false// 可以删引用类型的属性delete obj.b[1] // true.obj.b // &#123;a: &quot;a&quot;, b: [1, empty]&#125;obj.b[1] // undefinedobj.a = &#x27;c&#x27;obj.a // c// 查看描述, 可以看到configurable为falseObject.getOwnPropertyDescriptors(obj)//a: &#123;value: &quot;a&quot;, writable: true, enumerable: true, configurable: false&#125;//b: &#123;value: Array(2), writable: true, enumerable: true, configurable: false&#125; 冻结对象 Object.freeze 最严格的防止篡改级别是冻结对象，冻结的对象既不可以扩展，又是密封的，而且对象数据属性的[[writable]]特性会被设置为 false。 如果定义[[Set]]函数，访问器属性仍然是可写的 1234567891011121314151617181920let obj = &#123; a: &#x27;a&#x27;, b: [1, 2],&#125;Object.freeze(obj)// 不可修改obj.a = &#x27;c&#x27;obj.a // &#x27;a&#x27;// 不可删除delete obj.a // false// 不可新增obj.c = 1// 查看描述, 可以看到configurable为false, writable也为 falseObject.getOwnPropertyDescriptors(obj)// a: &#123;value: &quot;a&quot;, writable: false, enumerable: true, configurable: false&#125;// b: &#123;value: Array(2), writable: false, enumerable: true, configurable: false&#125; 以上","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"try里面放return，finally还会执行吗","slug":"try-catch-return","date":"2018-10-17T23:29:54.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"try-catch-return/","link":"","permalink":"https://laputaz.github.io/home/try-catch-return/","excerpt":"try 里面放 return，finally 还会执行吗","text":"try 里面放 return，finally 还会执行吗 123456789101112// return 执行了但是没有立即返回，而是先执行了finallyfunction kaimo() &#123; try &#123; return 0; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; console.log(&quot;a&quot;); &#125;&#125;console.log(kaimo()); // a 0 123456789101112// finally 中的 return 覆盖了 try 中的 return。function kaimo() &#123; try &#123; return 0; &#125; catch (err) &#123; console.log(err); &#125; finally &#123; return 1; &#125;&#125;console.log(kaimo()); // 1","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"vue：源码整理, 数据代理和响应式","slug":"Vue源码整理, 数据代理和响应式","date":"2018-09-22T23:28:34.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"Vue源码整理, 数据代理和响应式/","link":"","permalink":"https://laputaz.github.io/home/Vue%E6%BA%90%E7%A0%81%E6%95%B4%E7%90%86,%20%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"最近看了一下 Vue 相关的东西 ,整理一下流程。","text":"最近看了一下 Vue 相关的东西 ,整理一下流程。 最近很慌, 想看源码, 先把简单的相关概念理一理 Object.defineProperty首先, 概念 : Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 没啥好说的, 直接上例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 定义一个对象const obj = &#123; firstName: &#x27;D&#x27;, lastName: &#x27;Z&#x27;&#125;// 数据描述符-----------------------------------------------// 新增一个属性Object.defineProperty(obj, &#x27;age&#x27;, &#123; configurable: false, // 不可重新定义 enumerable: false, // 不可枚举 value: 18, // 值 writable: false // 不可写&#125;)// 不可重新配置Object.defineProperty(obj, &#x27;age&#x27;, &#123; configurable: false, enumerable: true&#125;) // 报错// 不可删除delete obj.age // falseconsole.log(obj.age) // 18// 不可枚举Object.keys(obj) // [&quot;firstName&quot;, &quot;lastName&quot;]// 不可写obj.age = 17console.log(obj.age) // 18// 存取描述符-----------------------------------------------Object.defineProperty(obj, &#x27;fullName&#x27;, &#123; get() &#123; return this.firstName + &#x27;-&#x27; + this.lastName &#125;, set(value) &#123; const arr = value.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125;&#125;)obj.fullName // D-Zobj.fullName = &#x27;A-B&#x27;obj.lastName // Bobj.firstName // A configurable: false 不可重新定义, 也就是说再执行 Object.defineProperty(obj, &#39;age&#39;, &#123;...&#125;)将会报错, 并且, 属性不可删除enumerable: false 不可枚举, 也就是再执行Object.keys()或for in 等将取不到该属性value:18 值writable: false 不可写, 也就是对age赋值操作将不会生效, 但不会报错get取值操作 , function, 默认undefinedset属性值修改时，触发执行该方法 , function, 默认undefined 以上这一些属性, 称为描述符, 需要注意的是, 当使用了 getter 或 setter 方法，不允许使用 writable 和 value 这两个属性get set 看起来就很像 vue 的计算属性 伪数组伪数组 (ArrayLike) ，又称类数组。是一个类似数组的对象，但是有如下几个特征。按索引方式储存数据 10: xxx, 1: xxx, 2: xxx... 具有 length 属性 1但是length属性不是动态的，不会随着成员的变化而改变 不具有数组的 push()， forEach()等方法 123arrayLike.__proto__ === Object.prototype //truearrayLike instanceof Object //truearrayLike instanceof Array //false 以下是常见伪数组： arguments NodeList =&gt; document.querySelectorAll(‘div’).constructor.name // NodeList HTMLCollection =&gt; document.getElementsByClassName(‘head_wrapper’).constructor.name // HTMLCollection jQuery =&gt; $() 转换为真数组方法 遍历伪数组存入真数组 Array.prototype.splice.call(arrayLike) Array.from(arrayLike) […arrayLike] 原型继承,arrayLike.proto=Array.prototype 其他工具库中的方法，如 jQuery 中的 makeArray() toArray()等 NodeType元素,属性,文本等, 都实现了 Node 接口, 都会有 NodeType 属性, 它标识了节点属于的 类型常见的有:1 -&gt; 元素 节点3 -&gt; 文字节点8 -&gt; 注释节点11 -&gt; DocumentFragment 节点 12345&lt;div class=&quot;my&quot;&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;span&gt;789&lt;/span&gt;&lt;/div&gt; 上面的 html 片段, 分别用 childNodes 和 children 取值, 结果分别是什么呢 12document.querySelector(&#x27;.my&#x27;).childNodes // NodeList(5) [text, span, text, span, text]document.querySelector(&#x27;.my&#x27;).children // HTMLCollection(2) [span, span] 从图中可以看到, my div 下, 包含了 5 个 Node, 其中 123, 以及两个小红框位置的换行符, 属于 TextNode , span 标签属于 ElementNodechildNodes 和 children 结果分别是节点 list 和 子元素 list DocumentFragment文档片段接口，表示一个没有父级文件的最小文档对象.通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到 DOM 树。在 DOM 树中，文档片段被其所有的子元素所代替。因为文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 1234let content = document.createDocumentFragment()let el = document.querySelector(&#x27;.nums&#x27;)content.appendChild(el)// 这个时候 .nums 元素会从页面消失, 存入content这个Fragment片段 ProxyProxy 用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”。 12345678910111213var obj = new Proxy( &#123;&#125;, &#123; get(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`) return Reflect.get(target, key, receiver) &#125;, set(target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`) return Reflect.set(target, key, value, receiver) &#125;, &#125;) 上面代码对一个空对象架设了一层拦截，重新定义了属性的读取(get)和设置(set)行为。对设置了拦截行为的对象 obj，去读写它的属性，用自己的定义覆盖了语言的原始定义，运行得到下面的结果 123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 1. 数据代理 -&gt; Object.defineProperty()123456789101112131415let vm = new Vue(&#123; data: &#123; a: 0, &#125;,&#125;)// 为什么能通过 vm.a 访问到 data 中的 a ?// 因为会通过 Object.defineProperty 设置了数据代理Object.defineProperty(vm, &#x27;a&#x27;, &#123; get() &#123; return data.a &#125;, set(val) &#123; data.a = val &#125;,&#125;) 2. 模板解析 -&gt; NodeType -&gt; Reg -&gt; moustache -&gt; v-on -&gt; bind/html/class/textVue 2 是虚拟节点 VNode 12345678910111213let vm = new Vue(&#123; el: &#x27;#my&#x27;, data: &#123; a: 0, &#125;,&#125;)// 拿到 el 对应的模板以后, createDocumentFragment() 产生一个Dom片段// 再将el所有子节点插入到该Fragment// 遍历Fragment中每个节点// 文本 =&gt; 匹配&#123;&#123;&#125;&#125;// 元素 =&gt; 编译元素的指令// 普通指令/事件指令 =&gt; 编译完后删除该指令// 包含子节点 =&gt; 继续迭代 3. 数据绑定和响应式 -&gt; 使用数据劫持的技术实现一旦更新 data 中某个属性数据, 所有界面直接使用或间接使用该属性的节点会更新基本思路: 通过 defineProperty 监视 data 中所有层级数据的变化, 变化则更新界面 1234vm.a = 3=&gt; vm.a.set // 更新data中的a=&gt; vm.data.a = 3=&gt; vm.data.a.set //更新界面 123456789101112131415161718192021222324252627282930313233增加observe =&gt; 递归对每个属性 Object.defineProperty 增加 get set, 并且设为configurable:false除了事件指令, 每个指令/表达式 =&gt; 增加watcherDep -&gt; &#123; 实例创建时间 =&gt; 给data中每个属性增加observe数据劫持时(增加get,set)创建的, 在模板编译之前, new watcher()以前 数量 =&gt; 与data中属性一一对应(所有层级) 结构 =&gt; &#123; id: 标识 uid subs: [] subscribe订阅者数组, 内容是 watchers // 即需要更新的所有相关表达式 &#125;&#125;watcher -&gt; &#123; 实例创建时间 =&gt; 初始化解析大括号表达式/一般指令时创建 数量 =&gt; 与大括号表达式/一般指令一一对应 结构 =&gt; &#123; cb: cb 界面更新回调 vm: vm exp: 对应的表达式 depIds: &#123;&#125; 相关的n个dep // 主要用于判断关系是否建立, 避免再次建立dep watcher关系 value: get() 当前表达式value &#125;&#125;Dep与Watcher关系关系 -&gt; data属性 -&gt; 一个dep -&gt; n个watcher(属性在模板多次使用) 表达式 -&gt; watcher -&gt; n个dep(多层表达式, 如a.b, 对应了两个dep)建立 -&gt; 初始化data数据 -&gt; 每个数据增加dep, 并增加 get, set -&gt; 编译模板 -&gt; 拿到表达式 -&gt; 每个表达式增加一个watcher -&gt; watcher初始化会有个value属性 -&gt; 该value属性调用了dep的get方法 -&gt; dep的get方法depend() -&gt; 通过watcher的depIds判断关系是否建立 -&gt; dep 保存watcher到subs -&gt; watcher 的depIds保存dep响应式 -&gt; vm.name = &#x27;abc&#x27; -&gt; data中name属性值变化 -&gt; name的 set() -&gt; dep.notify() -&gt; dep中subs数组中每个watcher进行update() -&gt; watcher.cb 回调 -&gt; updater更新界面 总结整体实现分为已下步骤 实现一个 Observer，对数据进行劫持，通知数据的变化（将使用的要点为：Object.defineProperty()方法） 实现一个 Compile，对指令进行解析，初始化视图，并且订阅数据的变更，绑定好更新函数 实现一个 Watcher，将其作为以上两者的一个中介点，在接收数据变更的同时，让 Dep 添加当前 Watcher，并及时通知视图进行 update 实现一些 VUE 的其他功能（Computed、menthods） 实现 MVVM，整合以上几点，作为一个入口函数","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"}]},{"title":"js基础：es6 中需要注意的一些点","slug":"js基础-es6中需要注意的一些点","date":"2018-09-05T17:36:36.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-es6中需要注意的一些点/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-es6%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/","excerpt":"es6 的一些需要额外注意的点","text":"es6 的一些需要额外注意的点 let &amp;&amp; const 拥有块级作用域 不可重复声明 暂时性死区 (作用域内声明前, 不可用, 报错) 未声明前, typeof 也是直接报错, 但 typeof 一个为定义的变量不会报错, 输出 undefined (typeof 不再安全) const，声明必须赋值 (并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动) let、const、class 声明的全局变量，不属于顶层对象的属性。从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 globalThis 全局对象(提案) 解构 字符串也可以解构赋值。 const [a, b, c, d, e] = ‘hello’; 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 12let &#123; toString: s &#125; = 123s === Number.prototype.toString 字符串方法 includes(), startsWith(), endsWith(), padStart()，padEnd(), tirmStart(), tirmEnd() 数字 Number.isFinite(), Number.isNaN() 与 isNaN() 区别, isNaN()会先转换成数字, 如 isNaN(‘a’) //true Number.isInteger(), Number.isSafeInteger() Math.sign 方法用来判断一个数到底是正数、负数、还是零 指数运算符（**） 函数 length 属性 , 含义是，该函数预期传入的参数个数, 指定了默认值后，该参数不被统计 rest 参数（形式为…变量名）,rest 参数之后不能再有其他参数 name 属性, 函数名 var f = function () {}; // es5 f.name=&gt; “” // es6 f.name=&gt; “f” 箭头函数内的 this 对象，就是定义时所在的对象 箭头函数不可以当作构造函数 箭头函数不可以使用 arguments 对象 箭头函数不能用作 Generator 函数 数组 扩展运算符, 复制数组, 合并数组 与解构赋值结合 const [first, …rest] = [1, 2, 3, 4, 5]; 将字符串转为真正的数组 […’hello’] Iterator Array.from 将两类对象转为真正的数组：类似数组的对象和可遍历的对象, Array.from(Set) Array.of 方法用于将一组值，转换为数组 Array.of(3, 11, 8) find() 和 findIndex() fill() // let a = []; a.length =100; a.fill(1) // [1,1,1,1,….100 个 1] includes() flat() / flatMap() 扁平化数组 数组的空位, ES6 则是明确将空位转为 undefined // Array(3) // [, , ,] 对象 Object.getOwnPropertyNames 包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性） Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 扩展运算符 // {…{b:2}, a: 1} //{b: 2, a: 1} Object.is 跟 === 一样 Object.assign(target, source1, source2) 将源对象（source）的所有可枚举属性，复制到目标对象（target）(浅拷贝) Object.getPrototypeOf() =&gt; proto Object.keys()，Object.values()，Object.entries() (键值对数组) set / map 在 Set 内部，两个 NaN 是相等 Map 的遍历顺序就是插入顺序 promise 123456789// 加载图片const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image() image.onload = resolve image.onerror = reject image.src = path &#125;)&#125; Promise.all / Promise.race Iterator 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作 for…of 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的 获取 Iterator1234let iter = [1, 2, 3][Symbol.iterator]()iter.next() //&#123;value: 1, done: false&#125;iter.next() //&#123;value: 2, done: false&#125;iter.next() //&#123;value: 3, done: true&#125; 调用 Iterator 接口的场合 =&gt; 解构赋值, 扩展运算符, yield* , for…of, Array.from(),Map(), Set(), Promise.all / Promise.race async async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖 async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数 没有 return , 返回 resolve(undefined) async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。 123456789async function f() &#123; throw new Error(&#x27;出错了&#x27;)&#125;f() .then((v) =&gt; console.log(v)) .catch((e) =&gt; &#123; console.log(e) &#125;) await 命令只能出现在 async 函数内部，否则都会报错 13.类 注意的几个点 : 在class中定义的方法, 均为原型方法 1234class F &#123; say() &#123;&#125;&#125;F.prototype.hasOwnProperty(&#x27;say&#x27;) //true class 中定义的属性, 均为实例属性, 而非在原型上, 并且构造函数中定义相同属性会覆盖class中的定义 123456789class W &#123; a = 1 constructor() &#123; this.a = 2 &#125;&#125;let w = new W()w.hasOwnProperty(&#x27;a&#x27;) //truew.a // 2 类本身指向构造函数 1Object.getPrototypeOf(w).constructor === W class 没有写构造函数, 会自动创建一个, 并返回this 与es5不同的是, 类中定义的方法是不可枚举的, es5的prototype写法可以 12345678910//classclass F &#123; say() &#123;&#125;&#125;Object.keys(F.prototype) // []// es5function G() &#123;&#125;G.prototype.say = function () &#123;&#125;Object.keys(G.prototype) // [&#x27;say&#x27;] __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，我们可以使用 Object.getPrototypeOf static修饰的方法不会被实例继承, 静态方法, 只能被类调用, 可以与实例方法重名 1234567891011class H &#123; static say() &#123; console.log(1) &#125; say() &#123; console.log(2) &#125;&#125;let h = new H()h.say() // 2H.say() // 1 使用extends继承时, 若子类显式地写了构造函数, 那么构造函数 中必须调用super(), 子类未显式写构造函数则不用 class中可以写get, set 12345678class K &#123; get a() &#123; return this.b &#125; set a(val) &#123; this.b = val &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：promise 的简单实现和需要注意的一些点","slug":"js基础-promise的简单实现和需要注意的一些点","date":"2018-09-04T12:06:42.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-promise的简单实现和需要注意的一些点/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-promise%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/","excerpt":"Promise 的一些注意点，以及梳理","text":"Promise 的一些注意点，以及梳理 前言昨天面试去 xiaoman, 提到了 promise;面对不断深入发问, 我脑子一片空白, 然后就想到了白云山;我想怎么思考其他问题的时候没有这么思维活跃; 常用方法12345678910Promise.prototype.then()Promise.prototype.catch()Promise.prototype.finally()Promise.all() // 必须所有都 resolvedPromise.race() // 只要有一个 resolvedPromise.allSettled() // 所有都结束，不管是 resolved 还是 rejectedPromise.any() // 只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 与 race 只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。Promise.resolve()Promise.reject()Promise.try() Promise 状态的不可逆性Promise 状态的一旦变成 resolved 或 rejected 时，Promise 的状态和值就固定下来了，不论你后续再怎么调用 resolve 或 reject 方法，都不能改变它的状态和值。 12345678910111213141516171819var p1 = new Promise(function (resolve, reject) &#123; resolve(&#x27;success1&#x27;) resolve(&#x27;success2&#x27;)&#125;)var p2 = new Promise(function (resolve, reject) &#123; resolve(&#x27;success&#x27;) reject(&#x27;reject&#x27;)&#125;)p1.then(function (value) &#123; console.log(value)&#125;)p2.then(function (value) &#123; console.log(value)&#125;)// &quot;success1&quot;// &quot;success&quot; resolve 或 reject 后面的代码会不会执行当然会 then 的第二个参数和 catchcatch相当于then(null,function(err)&#123; /*处理错误*/&#125;)的写法 123456789101112// 写法一new Promise((resolve) =&gt; &#123; foo.bar()&#125;).then( (res) =&gt; &#123; console.log(res) &#125;, (err) =&gt; &#123; console.log(err) &#125;)// ReferenceError: foo is not defined 123456789101112// 写法二new Promise((resolve) =&gt; &#123; foo.bar()&#125;) .then((res) =&gt; &#123; console.log(res) kk() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// ReferenceError: foo is not defined 上面代码中，catch要好于then(null,err=&gt;&#123;&#125;)写法, catch 可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。如下: 1234567891011new Promise((resolve) =&gt; &#123; resolve(1)&#125;) .then((res) =&gt; &#123; console.log(res) kk() &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// ReferenceError: kk is not defined then/catch 的链式调用首先, 在new Promise中需要执行resolve或者reject改变状态,否则不会执行then方法, 像下面then就不会执行: 12345678910var p = new Promise(function (resolve, reject) &#123; return 1&#125;)p.then(function (value) &#123; console.log(value) return value * 2&#125;).then(function (value) &#123; console.log(value)&#125;)// Promise &#123;&lt;pending&gt;&#125; 在状态改变后, then方法返回一个新的Promise对象，因此可以通过链式调用then方法.catch也可以链式调用, 因为catch相当于then(null,err=&gt;&#123;&#125;) 函数的返回值将被用作创建then返回的Promise对象, 有如下情况: return 一个同步的值（当没有返回时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。 return 一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。 throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。 12345678910111213141516171819202122232425262728293031var p = new Promise(function (resolve, reject) &#123; resolve(1)&#125;)p.then(function (value) &#123; //第一个then console.log(value) return value * 2&#125;) .then(function (value) &#123; //第二个then console.log(value) &#125;) .then(function (value) &#123; //第三个then console.log(value) return Promise.resolve(&#x27;resolve&#x27;) &#125;) .then(function (value) &#123; //第四个then console.log(value) return Promise.reject(&#x27;reject&#x27;) &#125;) .then( function (value) &#123; //第五个then console.log(&#x27;resolve: &#x27; + value) &#125;, function (err) &#123; console.log(&#x27;reject: &#x27; + err) &#125; ) 1234512undefined&quot;resolve&quot;&quot;reject: reject&quot; 再写一个return返回promise的例子: 12345678910111213141516171819var a = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;5s later&#x27;) &#125;, 5000)&#125;)var p = new Promise(function (resolve, reject) &#123; resolve(1)&#125;)p.then(function (value) &#123; //第一个then console.log(1) return a&#125;).then(function (value) &#123; //第二个then console.log(value)&#125;)// 1// 5s later Promise.resolve()Promise.resolve()(注意,是Promise.resolve(),而不是new Promise中的resolve)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象;当参数是Promise对象时，对象的值就是这个参数；下面的例子可以看到 p1,p2 是相等的 1234let p1 = Promise.resolve(1)let p2 = Promise.resolve(p1)p1 === p2// true then 拿到数据发现不合适, 怎么触发 catchthrow new Error()抛出错误. 或者 Promise.reject() resolve 和 reject当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。即最后的状态是根据传入的promise对象的状态确定的;如下: 执行的是resolve(a), 但是a5 秒后返回的状态是rejected,所以会执行rejected回调 123456789101112131415161718192021var a = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;error&#x27;) &#125;, 5000)&#125;)var p = new Promise(function (resolve, reject) &#123; var b = resolve(a) console.log(a === b)&#125;)p.then( function (value) &#123; console.log(&#x27;success&#x27;) &#125;, function (err) &#123; console.log(err) return err &#125;)// false// Promise &#123;&lt;pending&gt;&#125;// error 但是, reject方法不同, reject方法不存在拆箱等待, 而是直接将传入的promise对象传入下个阶段, 如下 12345678910111213141516171819202122232425262728293031var a = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;error after 5s&#x27;) &#125;, 5000)&#125;)var p = new Promise(function (resolve, reject) &#123; reject(a)&#125;)p.then(function (value) &#123; console.log(&#x27;success&#x27;)&#125;) .catch((err1) =&gt; &#123; // 第一个 catch console.log(&#x27;fail: &#x27; + err1) return err1 &#125;) .catch((err2) =&gt; &#123; // 第二个 catch console.log(err2) return 1 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;)// fail: [object Promise]// Promise &#123;&lt;pending&gt;&#125;// error after 5s// 1 可以看到, p中reject了a, 直接把a传到了第一个 catch, 第一个 catch 中, 打印出来参数, 就是promise对象a .在 第一个catch中return err1, 等待 5 秒后a变成rejected状态, 触发第二个 catch , 捕获到结果error after 5s,最后catch 可以继续链式调用, 返回1, 相当于resolve(1), 最后then打印出1. promise 中出现异常, promise 外的后面的代码会执行吗会, Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 123456new Promise(function (resolve, reject) &#123; resolve(x + 1)&#125;)console.log(333)// 333// Uncaught (in promise) ReferenceError: x is not defined promise.all123456789101112131415161718192021let a = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111) &#125;, 3000)&#125;)let b = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(222) &#125;, 1000)&#125;)let c = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(333) &#125;, 100)&#125;)Promise.all([b, a, c]).then((res) =&gt; &#123; console.log(res)&#125;)// 结果数组也是顺序的// [222, 111, 333] 123456789101112131415161718192021222324252627let a = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;haha&#x27;) resolve(111) &#125;, 3000)&#125;)let b = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(222) &#125;, 1000)&#125;)let c = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(333) &#125;, 100)&#125;)Promise.all([b, a, c]) .then((res) =&gt; &#123; console.log(res) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)只要有一个错误, 就会catch该错误// 222// haha Promise 如何按顺序执行有一个数组，数组元素是返回 Promise 对象的函数，怎样顺序执行数组中的函数，即在前一个数组中的 Promise resolve 之后才执行下一个函数？…. 先生成数据, 下面代码执行完,生成 10 个函数组成的数组, 均返回 promise 对象 1234567891011121314151617function createPromises(id) &#123; return function () &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(id) resolve(id) &#125;, 1000) &#125;) &#125;&#125;let list = []for (let i = 0; i &lt; 10; i++) &#123; list.push(createPromises(i))&#125;// (10) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ] 递归法 123456789// 递归调用function promise_queue(list, i) &#123; if (i &gt;= 0 &amp;&amp; i &lt; list.length) &#123; list[i]().then(() =&gt; &#123; promise_queue(list, i + 1) &#125;) &#125;&#125;promise_queue(list, 0) await 12345678async function promise_queue(list) &#123; let index = 0 while (index &gt;= 0 &amp;&amp; index &lt; list.length) &#123; await list[index]() index++ &#125;&#125;promise_queue(list) Promise.resolve()初始状态是Promise.resolve(), then执行第一个, 并把下一个作为then的success函数(因为then返回一个promise的话, promise状态改变后, 才会执行下一个then) 1234567function promise_queue(list) &#123; var sequence = Promise.resolve() list.forEach((item) =&gt; &#123; sequence = sequence.then(item) &#125;) return sequence&#125; reduce 1list.reduce((pre, next) =&gt; pre.then(next), Promise.resolve()) promise 实现每隔一段时间执行一次函数, 执行 n 次 , 不用 await每隔 interval 毫秒, 执行一次 fn 函数, 执行 time 次: 12345678910111213function interval(fn, interval, time) &#123; let f = () =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; fn() resolve() &#125;, interval) &#125;) let a = Promise.resolve() for (let i = 0; i &lt; time; i++) &#123; a = a.then(f) &#125;&#125; 简易版本实现 promisepromise 特性： 状态不可逆，从 pending =&gt; fulfilled / rejected 有 then、catch 方法，还有 all、race、any 方法 同一个 promise 可以有多个 then then 可以链式调用 已经为 fulfilled/rejected 状态时，调用 then 会立刻执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211// 判断变量否为functionconst isFunction = (variable) =&gt; typeof variable === &#x27;function&#x27;// 定义Promise的三种状态常量const PENDING = &#x27;PENDING&#x27;const FULFILLED = &#x27;FULFILLED&#x27;const REJECTED = &#x27;REJECTED&#x27;class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error(&#x27;MyPromise must accept a function as a parameter&#x27;) &#125; // 添加状态 this._status = PENDING // 添加状态 this._value = undefined // 添加成功回调函数队列 this._fulfilledQueues = [] // 添加失败回调函数队列 this._rejectedQueues = [] // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err) &#125; &#125; // 添加resovle时执行的函数 _resolve(val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb while ((cb = this._fulfilledQueues.shift())) &#123; cb(value) &#125; &#125; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb while ((cb = this._rejectedQueues.shift())) &#123; cb(error) &#125; &#125; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( (value) =&gt; &#123; this._value = value this._status = FULFILLED runFulfilled(value) &#125;, (err) =&gt; &#123; this._value = err this._status = REJECTED runRejected(err) &#125; ) &#125; else &#123; this._value = val this._status = FULFILLED runFulfilled(val) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED this._value = err let cb while ((cb = this._rejectedQueues.shift())) &#123; cb(err) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加then方法 then(onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = (value) =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value) &#125; else &#123; let res = onFulfilled(value) if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; // 封装一个失败时执行的函数 let rejected = (error) =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error) &#125; else &#123; let res = onRejected(error) if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break &#125; &#125;) &#125; // 添加catch方法 catch(onRejected) &#123; return this.then(undefined, onRejected) &#125; // 添加静态resolve方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise((resolve) =&gt; resolve(value)) &#125; // 添加静态reject方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)) &#125; // 添加静态all方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( (res) =&gt; &#123; values[i] = res count++ // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values) &#125;, (err) =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err) &#125; ) &#125; &#125;) &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( (res) =&gt; &#123; resolve(res) &#125;, (err) =&gt; &#123; reject(err) &#125; ) &#125; &#125;) &#125; finally(cb) &#123; return this.then( (value) =&gt; MyPromise.resolve(cb()).then(() =&gt; value), (reason) =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) ) &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：cookie 的查看和操作","slug":"js基础-cookie的查看和操作","date":"2018-09-02T00:42:32.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-cookie的查看和操作/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-cookie%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%93%8D%E4%BD%9C/","excerpt":"之前面试的时候问到，cookie 有哪些属性， 怎么删除一个 cookie， 答的吞吞吐吐， 整理一下","text":"之前面试的时候问到，cookie 有哪些属性， 怎么删除一个 cookie， 答的吞吞吐吐， 整理一下 cookie 查看以 github 为例： cookie 的字段namecookie 的名字，一个域名下绑定的 cookie，name 不能相同，相同的 name 的值会被覆盖掉（但是 name 相同，只要 cookie 的 domain ，path ， secure 有一项不同，就是不同的 cookie） value表示 cookie 的值，cookie 的值要被编码， 但不是必须的。 cookie 规定是名称/值是不允许包含分号，逗号，空格的，为了不给用户到来麻烦，考虑服务器的兼容性，cookie 的数据都最好编码。 12345678// 例如 tz 设置为 广东;shenzhen, 有中文也有分号, 就需要编码document.cookie = `tz=$&#123;encodeURIComponent(&#x27;广东;shenzhen&#x27;)&#125;`console.log(document.cookie)// tz=%E5%B9%BF%E4%B8%9C%3Bshenzhenconsole.log(decodeURIComponent(document.cookie))// tz=广东;shenzhen domaincookie 绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，cookie 有跨域的限制， 但不会判断端口名 pathpath 这个属性默认是’/‘，这个值匹配的是 web 的路由，举个例子： 1234//默认路径www.baidu.com//blog路径www.baidu.com/blog //当路径设置成/blog的时候，其实它会给/blog、/blogabc等等的绑定cookie expires/max-age默认情况下， 设置的 cookie 的expires/max-age为session， 也就是关闭浏览器后，该 cookie 会被删除 如果想要 cookie 存在一段时间，那么你可以通过设置 expires 属性为未来的一个时间节点(GMT 时间) 1document.cookie = `mycookie=gg;expires=$&#123;new Date(2020, 08, 1).toGMTString()&#125;` 但这个属性已经逐渐被 max-age 取代；max-age，是以秒为单位，max-age 为正数时，cookie 会在 max-age 秒之后，被删除，当 max-age 为负数时，表示的是临时储存，不会生出 cookie 文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie 就会消失，当 max-age 为 0 时，又会发生什么呢，删除 cookie，因为 cookie 机制本身没有设置删除 cookie，失效的 cookie 会被浏览器自动从内存中删除，所以，它实现的就是让 cookie 失效。 利用过期时间可以用来删除 cookie： 12345678// 把expires时间设置为过去的时间let date = new Date()let sec = date.getTime()date.setTime(sec - 1)document.cookie = `mycookie=;expires=$&#123;date.toGMTString()&#125;;`// 或者把 max-age 设置为0或负数document.cookie = `mycookie=;max-age=0;` secure当这个属性设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输 HttpOnly这个属性设置为 true，就不能通过 js 脚本来获取 cookie 的值，能有效的防止 xss 攻击（也就是用户通过 xss 输入的恶意代码不能获取到 cookie）, 以上图为例， _gh_sess, logged_in通过 document.cookie 是获取不到的， 另外， document.cookie 只能拿到非 HttpOnly 的键值 上述属性，除了 name，value，其他可以设置值(指通过 js)(HttpOnly 不行)， 但取不到值","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"回顾：angular 1.x 项目总结","slug":"实现-angular-1-summary","date":"2018-07-12T23:31:18.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"实现-angular-1-summary/","link":"","permalink":"https://laputaz.github.io/home/%E5%AE%9E%E7%8E%B0-angular-1-summary/","excerpt":"当年第一个项目使用angular 1.46做的，在这里记录一下， 免得忘了","text":"当年第一个项目使用angular 1.46做的，在这里记录一下， 免得忘了 结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869- common - appConfig // 处理自定义路由格式 - stateConfig // 与SEP平台对接， 中间件控制器 -&gt; 前端路由 - menuConfig.js // 菜单配置- config - quality-analysis - config.js - view.html - health - service-warning - ... - ... - // 所有业务（页面）目录- router - routerConfig.js // 路由- controller - indexController.js - baseController.js- views - documents // 帮助文档（每个页面的） - templates - layouts // 页面布局 - subLayouts // 子布局- directives - comCharts001.js - comCharts002.js - comTable001.js - ... - ... - // 所有组件- services - httpService.js // 请求模块 - layoutService.js // 处理模板 - componentService.js // 处理组件 - dataService.js // 处理数据源 - excelService.js // 处理前端生成excel - ... - ... - ...- themes - css- lib - angular-ui-router.js // 路由 - tinyui // 集成了angular / 以及UI组件 - require.js- assets - images - svgs- main.js // 入口- app.js- index.html // 入口 流程123456789101112131415161718192021222324252627=&gt; index.html=&gt; main.js -&gt; 全局变量 -&gt; 鉴权 / 获取地图数据 -&gt; angular.brootstrap() 挂载元素=&gt; app.js -&gt; app = angular.mudule() 定义主模块 -&gt; app.services() 定义services -&gt; app.filter() 定义过滤器 -&gt; app.controller(index) 定义主控制器=&gt; appConfig.js -&gt; 将 routerConfig 中的路由配置处理为angular-ui-router格式 -&gt; 引入菜单=&gt; 打开某路由=&gt; baseController.js -&gt; 读取config文件夹中的业务配置 -&gt; 定义顶层事件分发, 监听所有子级控制器的消息传播, 并转发 -&gt; 通过 layoutService.js ,componentService.js , dataService.js // 分别处理布局/组件/数据源, 生成页面控制器 -&gt; 定义includes字段以引入公共模板=&gt; config文件夹 -&gt; 页面生成通过ng-includes 问题开发中还是遇到了很多问题的: 一个页面通过多个html使用ng-includes层层嵌套, 看似可复用, 实际上没有 webpack.gulp 等支持, 会产生大量零件碎片, 严重拖慢加载速度 组件组织方式均写到 directives, 并且内部耦合太重, 稍微的功能不符合, 便需要重新写一个类似的 config 文件存在大量的重复代码, 影响代码重复率检测 没有全局数据流管理, 两个控制器通信过分依赖 baseController 顶层, 导致 baseController 本为公共, 却写了大量 if else 特殊判断 类似弹窗这种组件, 不是一对多的, 而是重复写了非常多遍, 导致加载特慢 解决? 第一个问题, 后续不再使用 html 拼接的形式, 而是将模板写到一个 view.html 中 增加按需加载组件, 而不是上来就把 directives 全定义一遍 将弹窗改写为共用的容器 引入 gulp 对代码进行压缩混淆, 但是 angular 的依赖注入有很多坑, 需要特殊的插件处理 结果经过一番折腾后, 性能稍微有些提升, 但是总体还是不理想最后的解决方法是重构既然要重构, 干脆直接抛弃了 angular 1, 转而投向了 vue 全家桶 通信方式 $emit() , $broadcast() angular.element().scope() $parent , $childHead 公用 service","categories":[],"tags":[{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"}]},{"title":"对CommonJS,AMD,CMD规范以及script标签异步加载的理解","slug":"js-cmd-amd-common","date":"2018-06-22T23:34:51.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js-cmd-amd-common/","link":"","permalink":"https://laputaz.github.io/home/js-cmd-amd-common/","excerpt":"对 CommonJS,AMD,CMD 规范以及 script 标签异步加载的理解","text":"对 CommonJS,AMD,CMD 规范以及 script 标签异步加载的理解 1.牢骚CommonJS, AMD, CMD , 其实很早就接触过了。当时, 网上的文章看得眼花缭乱, 只依稀记得几个模糊的概念。什么依赖前置 , 什么按需加载。一头雾水。 现在再回过头来看看概念 , 网上部分文章用词模棱两可。给我们这些菜鸡, 带来了理解的偏差和困惑。记得第一个项目还用了 requireJS 。时过境迁，现在入门前端 , 都是直接上 webpack 了 。但我觉得还是有必要理一理 。 2. 是什么CommonJS, AMD, CMD 是规范, 理念 ; 对 CommonJS 的实现 , 有 node 的模块系统 ; 对 AMD 的实现有 require.js ; 而 CMD, 是在 sea.js 的实现中提出来的 (但是在Google和Stack Overflow, 这个概念很少被提到, 一般出现在国内)。 CommonJS 规范， 模块加载是同步的对node来说，模块存放在本地硬盘，同步加载，等待时间就是硬盘的读取时间，这个时间非常短; AMD、CMD 规范，模块加载是异步的目的, 是为了适应浏览器环境，加载的时间取决于网络的好坏，可能要等很长时间; 3. 先说 async 和 defer记得看文章的时候, 看到了下面这段话 ,我看了半天, 总觉得不是很理解 , 为什么呢 ?这里说, 脚本标签天生是异步的 , 那为什么会出现 async 和 defer ?然后, 我发觉我并没有把 加载和执行的概念区分清楚 , 这里的加载我把它理解为浏览器中的下载这里贴一张图就很清楚了: &lt;script&gt; 标签, 在下载和执行的时候 , 会阻塞 dom 的渲染进程 , 所以如果把&lt;script&gt; 标签放在&lt;head&gt;中, 当 js 文件很大或者网络差时, 会导致页面长时间空白( 顺带提一下, &lt;script&gt;标签并不会阻止其他的&lt;script&gt;标签的下载, 现代浏览器中多个&lt;script&gt;下载是并行的, 在chrome中, 默认支持6个资源(http1.x)并行下载 ), 另外 , 脚本是按照&lt;script&gt;标签的书写顺序执行的 ; &lt;script defer&gt; 在加上defer以后, 下载的过程就不会阻塞 dom 渲染了, 但脚本的执行是在 dom 渲染完毕之后; &lt;script async&gt;在加上async以后, 下载的过程同样不会阻塞 dom 渲染, 但脚本会在下载完后立刻执行, 所以存在多个&lt;script async&gt;时, 无法保证多个 js 文件的执行顺序, 加载较快的脚本会执行; 所以 defer, async 主要作用于加载阶段, 执行阶段仍然会阻塞 dom 渲染 4. 再看 require.js 的异步体现再看看使用 require.js 的模块写法新建 main.js / a.js / b.js , main.js 为入口, 引用了 a.js , b.js 123456789101112131415161718192021222324// main.js// waitSeconds = 0的配置, 是为了防止文件过大或网络不佳时, 加载时间过长导致require报`Load timeout for modules`的错误require.config(&#123; waitSeconds: 0&#125;);require([&quot;a.js&quot;, &quot;b.js&quot;], function(a, b) &#123; // handle / use a, b console.log(a); console.log(b);&#125;);// a.js ------------------------------define([], function() &#123; return &#123; a: 111111111111 &#125;;&#125;);// b.js ------------------------------define([], function() &#123; return &#123; b: 222222222222 &#125;;&#125;); 文件 开始下载 的 顺序： main, a, b为什么文件下载的顺序是 main, a, b 呢? main依赖了 a b, 不是 a b 先下载吗? 那是因为，只有 main 加载之后，才知道mian依赖了啥啊 执行的 顺序 : a, b, main 或者 b, a, main这里体现 require.js 的异步加载。 a 和 b 的加载或者说下载是并行的, 但 a 和 b 的执行顺序不确定的 , a 和 b 先执行哪一个都无所谓 ,只需要保证回调函数在 a 和 b 都执行完之后再执行就可以了; 在 require.js 中模块加载是怎么实现的呢?看一下 require.js 的源码: 123456789101112/** * Creates the node for the load command. Only used in browser envs. */req.createNode = function(config, moduleName, url) &#123; var node = config.xhtml ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;) : document.createElement(&quot;script&quot;); node.type = config.scriptType || &quot;text/javascript&quot;; node.charset = &quot;utf-8&quot;; node.async = true; return node;&#125;; 这段代码, 新建了 script 标签, 并把它的 async设置为true , 另外, 前面说 , 依赖的模块都执行完之后, 才会执行回调函数。 那怎么判断是否 所有依赖的模块 都已经执行完 ?多个模块的情况 , 还没看懂(捂脸) , 但是单个模块的执行状态是可以监听的: 12345678910111213141516......... //mentioned above about not doing the &#x27;script execute, //then fire the script load event listener before execute //next script&#x27; that other browsers do. //Best hope: IE10 fixes the issues, //and then destroys all installs of IE 6-9. //node.attachEvent(&#x27;onerror&#x27;, context.onScriptError); &#125; else &#123; node.addEventListener(&#x27;load&#x27;, context.onScriptLoad, false); node.addEventListener(&#x27;error&#x27;, context.onScriptError, false); &#125; node.src = url; ... ... 上面的代码可以看到, 通过 &lt;script&gt;标签的 onload 事件可以判断, 该脚本是否执行完毕 ; 所以, 个人理解, require.js 的异步第一, 是指下载的异步,第二, 还指回调机制, 依赖模块执行完之后再执行回调函数 5. AMD 和 CMD 的理解误区现在 再来看 AMD 和 CMD 的区别, 网上的说法: AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require 第二点 只有在用到某个模块的时候再去require, 这种说其实是带有误导性的,看看 sea.js 的写法: 1234567define(function(require, exports, module) &#123; console.log(123); var a = require(&quot;a.js&quot;); console.log(a); var b = require(&quot;b.js&quot;); console.log(b);&#125;); 这里, 难道是执行到require, 才去加载/下载require的文件吗 ?当然不是 ! 看一下 sea.js 的代码: 12345window.define = function(callback) &#123; var id = getCurrentJs() var depsInit = s.parseDependencies(callback.toString()) var a = depsInit.map(item =&gt; basepath + item) .... sea.js 把 callback 回调函数用转换成字符串, 再找出有哪些依赖, 这些依赖模块同样是预先加载的 ,不同在于, require.js 会立刻执行依赖模块, 而 sea.js 在遇到 require 语句的时候 , 再执行依赖模块; 5. 总结AMD 和 CMD 最大的区别是: 对依赖模块的执行时机处理不同(注意不是加载的时机)很多人说, requireJS 是异步加载模块，SeaJS 是同步加载模块，这么说实际上是不准确的 ;二者加载模块都是异步的 ;只不过 AMD 依赖前置，可以方便知道依赖了哪些模块，然后马上加载 , 在加载完成后, 就会执行该模块;而 CMD 推崇就近依赖，把模块变为字符串解析一遍, 找到依赖了哪些模块, 在加载模块完成后, 不立刻执行, 而是等到require后再执行;上面只说了异步相关的概念, 其实 require.js / sea.js , 最重要的还是模块化。模块化降低耦合，依赖清晰，让调试, 加功能, 任务分配和交接都更方便。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"浏览器：EventLoop 事件循环以及 for 循环中的 let 和 var","slug":"浏览器-EventLoop时间循环以及for循环中的let和var","date":"2018-05-04T12:30:08.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"浏览器-EventLoop时间循环以及for循环中的let和var/","link":"","permalink":"https://laputaz.github.io/home/%E6%B5%8F%E8%A7%88%E5%99%A8-EventLoop%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E4%BB%A5%E5%8F%8Afor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84let%E5%92%8Cvar/","excerpt":"面试又被问到了，记录一下","text":"面试又被问到了，记录一下 起因先看一个例子 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 100)&#125; 网上文章说 , 会输出 10 个 10, 因为执行 setTimeout 中的内容的时候, for 循环已经执行完了 但是我当时就是想不通 , 比如我改成 12345for (var i = 0; i &lt; 10000; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1)&#125; 这里我改成 10000 次循环 , 而 setTimeout 只有 1ms , 当时我想 , 10000 次循环总不能在 1ms 内执行完吧 ? 为什么打出来还是 10000 个 10000 ? 当时很蠢, 直到我学了 EventLoop 才明白 Event Loop 是什么 javascript是一门单线程语言 任务分为两类： 同步任务 异步任务 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 除了广义的同步任务和异步任务，我们对任务有更精细的定义： JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码 script，setTimeout，setInterval 微任务：Promise.then(非 new Promise)，process.nextTick(node 中) 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放入 Event Queue 中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从 Event Queue 中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。 上面的 for 循环 for 是同步任务进入主线程, 此时为宏任务, setTimeout 的回调函数进入事件队列的宏任务队列, 所以只有 for 循环执行完以后, setTimeout 的回调函数才会执行 再看一个例子 1234567891011for (var i = 0; i &lt; 100; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;) new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;hehe&#x27;) resolve(&#x27;&#x27;) &#125;).then((_) =&gt; &#123; console.log(&#x27;then&#x27;) &#125;)&#125; 这个例子会输出什么? 分析一下: for循环作为同步任务, 宏任务, 进入主线程 遇到setTimeout, setTimeout回调作为异步任务, 宏任务, 进入宏任务事件队列 遇到new Promise, 立刻执行, 输出hehe then进入异步任务, 微任务队列事件 每次循环都执行以上过程, 直到for循环执行完毕 此时, 事件队列如图 宏任务 Event Queue 微任务 Event Queue 100 个setTimeout回调 100 个then 由于 for 循环为宏任务, 所以下一步会首先读取微任务事件队列, 进入主线程 这时先执行 100 个then, 输出 100 个then 执行完毕, 再读取宏任务事件队列 执行 100 个setTimeout回调, 由于for循环早就执行完了, i变量声明方式为var, 所以最后输出 100 个 100 所以最后输出的结果是: 100 个hehe, 100 个then ,100 个 100 for let 和 for var上面把 var 改为 let, 输出的将不是 100 个 100, 而是 0~99 123456for (let i = 0; i &lt; 100; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 100)&#125;// 0 ~ 99 如果变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。 每一次循环，变量i的值都会发生改变，而循环内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 100。 下面是阮一峰ECMAScript 6 入门中的解释 如果变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。我想这也算闭包的范畴。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &#x27;abc&#x27; console.log(i)&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"浏览器","slug":"浏览器","permalink":"https://laputaz.github.io/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"js基础：闭包的一个用途-函数柯里化","slug":"js基础-闭包的一个用途-函数柯里化","date":"2018-05-04T12:25:11.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-闭包的一个用途-函数柯里化/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E7%94%A8%E9%80%94-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"闭包的一个用途：函数柯里化（局部化）","text":"闭包的一个用途：函数柯里化（局部化） 概念 柯里化, Currying(局部化)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 用途 分步, 例如加法 1234567891011function add(a, b) &#123; return a + b&#125;add(1, 2) // 3function curryingAdd(a) &#123; return function (b) &#123; return a + b &#125;&#125;curryingAdd(1)(2) // 3 参数复用， 如正则匹配 123456789101112131415function check(reg, text) &#123; return reg.test(text)&#125;check(/jj/, &#x27;jj&#x27;) // truecheck(/jj/, &#x27;tt&#x27;) // false//可以直接写为function curringCheck(reg) &#123; return function (text) &#123; return reg.test(text) &#125;&#125;let checkFunc = curringCheck(/jj/)checkFunc(&#x27;jj&#x27;) // truecheckFunc(&#x27;js&#x27;) // false 延迟运行 1234567891011121314151617181920Function.prototype.bind = function () &#123; var self = this // 保存原函数 var context = [].shift.call(arguments) // 保存需要绑定的this上下文(第一个参数，就是传进来的函数) var args = [].slice.call(arguments) // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 // 合并参数 var pars = [].concat.call(args, [].slice.call(arguments)) self.apply(context, pars) &#125;&#125;window.a = 1window.b = 2function log() &#123; console.log(this.a, this.b)&#125;let k = log.bind(window)k() // 1 2 像我们 js 中经常使用的 bind，实现的机制就是 Currying","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：this的指向以及call-apply-bind的实现","slug":"js基础-this的指向以及call-apply-bind的实现","date":"2018-05-04T12:08:03.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-this的指向以及call-apply-bind的实现/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-this%E7%9A%84%E6%8C%87%E5%90%91%E4%BB%A5%E5%8F%8Acall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"总是记不住，这里实现一下","text":"总是记不住，这里实现一下 this 的绑定规则有哪些？ 默认绑定 隐式绑定 显式绑定 / 硬绑定 new 绑定 默认绑定在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。如下， 严格模式下 this 为undefined 12345function sayHi() &#123; console.log(&#x27;Hello,&#x27;, this.name)&#125;var name = &#x27;gg&#x27;sayHi() //gg 隐式绑定函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun(), 对象属性链中只有最后一层会影响到调用位置。 123456789101112function sayHi() &#123; console.log(&#x27;Hello,&#x27;, this.name)&#125;var person2 = &#123; name: &#x27;ggg&#x27;, sayHi: sayHi,&#125;var person1 = &#123; name: &#x27;yyy&#x27;, friend: person2,&#125;person1.friend.sayHi() //Hello,ggg 函数赋值于其他变量： 12345678910function sayHi() &#123; console.log(&#x27;Hello,&#x27;, this.name)&#125;var person = &#123; name: &#x27;ggg&#x27;, sayHi: sayHi,&#125;var name = &#x27;yyy&#x27;var Hi = person.sayHiHi() // Hello, yyy 回调的情况 123456789101112131415161718192021function sayHi() &#123; console.log(&#x27;Hello,&#x27;, this.name)&#125;var person1 = &#123; name: &#x27;YvetteLau&#x27;, sayHi: function () &#123; setTimeout(function () &#123; console.log(&#x27;Hello,&#x27;, this.name) &#125;) &#125;,&#125;var person2 = &#123; name: &#x27;Christina&#x27;, sayHi: sayHi,&#125;var name = &#x27;Wiliam&#x27;person1.sayHi()setTimeout(person2.sayHi, 100)setTimeout(function () &#123; person2.sayHi()&#125;, 200) 123Hello, WiliamHello, WiliamHello, Christina 情况 1: setTimeout 中回调为默认绑定 情况 2: 相当于 person2.sayHi 函数赋值给了一个中间形参 fn，最后执行 fn， 所以和函数赋值于其他变量一样 情况 3: 对象上触发的，没毛病 显式绑定 / 硬绑定就是通过 call,apply,bind 的方式，显式的指定 this 所指向的对象。箭头函数无法通过call、apply，bind改变this指向 new 绑定顾名思义 使用 new 来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即 this 指向这个新对象 执行构造函数中的代码 返回新对象 因此，我们使用 new 来调用函数的时候，就会新对象绑定到这个函数的 this 上。 绑定优先级new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 call/apply/bind 的实现三者都可以用于改变 this 的指向，区别在于 call 接受目标函数和需要枚举参数，并立刻执行 apply 接受目标函数和参数数组，并立刻执行 bind 接受目标函数和需要枚举参数，返回新函数，不会立刻执行 call 和 apply 如何实现呢？利用隐式绑定的特性，即 obj.xxx()，分三步走： 将函数设为对象的属性 执行该函数 删除该函数 1234567891011121314151617Function.prototype.call = function (context) &#123; // 没有传时，指向 window var context = context || window // 例如 func.call(obj), 那么 this 就是函数自身 context.fn = this // 取得参数 var args = [] for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;) &#125; // 执行 var result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) // 从对象上删除 delete context.fn // 返回 result return result&#125; apply 的实现是类似的，只是参数变成了一个显示传入的数组 123456789101112131415161718Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window context.fn = this var result if (!arr) &#123; result = context.fn() &#125; else &#123; var args = [] for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;) &#125; result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) &#125; delete context.fn return result&#125; bind 的实现，可以借助柯里化的思路，将传入的 obj 和参数保存在内存中： 1234567891011121314Function.prototype.bind = function () &#123; var self = this // 保存原函数 // 保存需要绑定的this上下文(第一个参数，就是传进来的对象) var context = [].shift.call(arguments) // 剩余的参数转为数组 var args = [].slice.call(arguments) return function () &#123; // 返回一个新函数 // 合并参数 var pars = [].concat.call(args, [].slice.call(arguments)) self.apply(context, pars) &#125;&#125; 注意，bind 方法可以接受并保存多余的参数，如: 123456789101112131415let obj = &#123; a: 3, func(a, b) &#123; console.log(this.a + &#x27;&#x27; + a + b) &#125;,&#125;// 执行obj.func(1, 2) // =&gt; 312// 此时 在 window 上绑定一个 awindow.a = 1const f = obj.func.bind(window, 1) // 指定第一个参数// 执行f(2) // =&gt; 112 可以看到，1 是被保存起来的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：instanceof 原理和简单实现","slug":"js基础-instanceof原理和简单实现","date":"2018-05-01T12:32:53.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-instanceof原理和简单实现/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-instanceof%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"instanceOf 被问到的频率太高了，记录一波","text":"instanceOf 被问到的频率太高了，记录一波 1. 是什么在 MDN 上是这样描述 instanceof 的： The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object. instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象原型链中的任何位置 2. 实现这里已经描述的很清楚了, 怎么实现呢思路: 首先 instanceof 左侧必须是对象, 才能找到它的原型链 instanceof 右侧必须是函数, 函数才会prototype属性 迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧 代码: 123456789101112131415161718const instance_of = (left, right) =&gt; &#123; // 基本的数据类型为false const baseType = [&#x27;number&#x27;, &#x27;string&#x27;, &#x27;boolean&#x27;, &#x27;undefined&#x27;, &#x27;symbol&#x27;] if (baseType.includes(typeof left)) return false // 右侧函数的原型 const RP = right.prototype while (true) &#123; // 出口, left.__proto__.__proto__....的尽头是null, // 并且 null instanceof 任何类型 都不成立, 即使是Object, 下面会说到 if (left === null) &#123; return false &#125; else if (left === RP) &#123; return true &#125; // 找不到 ? 把left的值改为它的原型 left = left.__proto__ &#125;&#125; 3. 需要注意的一些情况以下状况均为 false 1234567891011121314151617/** * 因为 &#x27;abc&#x27; 是字符串, 是基本数据类型 * 有人说 &#x27;abc&#x27;.__proto__ === String.prototype 明明是成立的呀 * 这是因为, 当一个字符串调用方法或者属性的时候( 如&#x27;abc&#x27;.__proto__ )，会发生一个装箱操作，转换为包装类型 * 隐式转换为 new String(&#x27;abc&#x27;) * 但是 &#x27;abc&#x27; instanceof String 并不存在装箱操作 */&#x27;abc&#x27; instanceof String // false// null不具有任何对象的特性, null也没有__proto__属性null instanceof Object // false// String.__proto__.constructor.name === &#x27;Function&#x27;String instanceof String // falseNumber instanceof Number // false//....//....","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：new 对象发生了什么","slug":"js基础-new对象发生了什么","date":"2018-04-07T12:18:12.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-new对象发生了什么/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-new%E5%AF%B9%E8%B1%A1%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"老生常谈了","text":"老生常谈了 new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即{}）； 1var obj = &#123;&#125; 设置原型链，将 obj 的proto成员指向了构造函数的 prototype 1obj.__proto__ = xx.prototype 将步骤 1 新创建的对象作为 this 的上下文 ； 1let o = xx.call(obj) 如果构造函数 return 了一个新的“对象”，那么这个对象就会取代整个 new 出来的结果。如果构造函数没有 return 对象，那么就会返回步骤 1 所创建的对象，即隐式返回 this 1return o ? o : obj 完整版本 说明一下 Object.create 方法：Object.create 方法会创建一个新的空对象，该对象的原型指向传进来的参数。 1234567891011121314function newObject() &#123; var con = [].shift.call(arguments) var obj = Object.create(con.prototype) var res = con.apply(obj, arguments) return res ? res : obj&#125;function My(a) &#123; return &#123; a, &#125;&#125;// 使用const a = newObject(My, 1) // &#123; a: 1 &#125; 声明一个普通函数, 该函数返回一个基本类型, 或者返回函数, 这个时候会发生什么? 函数返回基本类型,使用 new, 会生成空对象 函数返回函数类型,使用 new, 返回该函数(函数本身也是对象) 123456789101112131415161718// 函数返回基本类型 -----------------function func(a, b) &#123; return a + b&#125;var c = new func(1, 2)console.dir(c) // func&#123;&#125; func类型的空对象Object.keys(c) // []// 函数返回函数 ---------------------function func() &#123; return function () &#123; return 22 &#125;&#125;var c = new func()c() // 22","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]},{"title":"js基础：对象创建和继承的几种方式","slug":"js基础-对象创建和继承的几种方式","date":"2018-04-06T12:34:07.000Z","updated":"2024-11-26T03:47:07.887Z","comments":true,"path":"js基础-对象创建和继承的几种方式/","link":"","permalink":"https://laputaz.github.io/home/js%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"最近看网上各种文章, 头异常的大。 刚好看完红宝书，于是整理了一下。","text":"最近看网上各种文章, 头异常的大。 刚好看完红宝书，于是整理了一下。 1. 工厂模式单纯地创建对象, 使用 Object 构造函数, 或者字面量表示都 ok, 但是, 会产生大量重复代码, 每次都要写 new Object() 等等,工厂模式可以解决这个问题 1234567891011121314function createPerson(name, job) &#123; // 创建一个Object var o = new Object() o.name = name o.job = job // 口吐芬芳 o.sayFword = function () &#123; alert(&#x27;Funny&#x27;) &#125; return o&#125;// 创建实例var person1 = createPerson(&#x27;Tony Stark&#x27;, &#x27;Iron Man&#x27;)var person2 = createPerson(&#x27;进喜 王&#x27;, &#x27;铁人&#x27;) 工厂模式解决了创建多个相似对象的问题, 但是没有解决对象识别问题, 所有实例类型均为 object.为了解决这个问题, 群众想出了构造函数模式 2. 构造函数模式1234567891011function Person(name, job) &#123; this.name = name this.job = job // 口吐芬芳 this.sayFword = function () &#123; alert(&#x27;Funny&#x27;) &#125;&#125;// 创建实例var person1 = new Person(&#x27;Tony Stark&#x27;, &#x27;Iron Man&#x27;)var person2 = new Person(&#x27;王进喜&#x27;, &#x27;铁人&#x27;) 这里, Person 取代了 createPerson 函数, 而且, 有几个不同: 没有显式创建对象 直接将属性, 方法赋给了 this 没有显式 return 函数名以大写字母开头 这个时候, 就可以识别对象类型了 12345person1.constructor === Person //trueperson2.constructor === Person //trueperson1 instanceof Person //trueperson2 instanceof Person //true 如果不用 new 会有什么后果 ?后果是, this 指向全局对象, 浏览器中, 传入的属性和方法都挂到 window 对象了 123var person3 = Person(&#x27;王进喜&#x27;, &#x27;铁人&#x27;)window.name //&#x27;王进喜&#x27;window.job //&#x27;铁人&#x27; 我们可以用 call 或 apply, 将 this 指向实例, 但这样标识不了类型, 构造函数模式便失去了意义 1234var person4 = new Object()Person.call(person4, &#x27;王进喜&#x27;, &#x27;铁人&#x27;)person4.name //&#x27;王进喜&#x27;person4 instanceof Person //false 当然, 除非手动将proto指向 Person.prototype, 这是后话 12person4.__proto__ = Person.prototypeperson4 instanceof Person // true 构造函数模式有一个问题 —— 每个方法都要在每个实例上创建一遍, 也就是说, 不同函数的同名方法实际上是不相等的 12// person1下的sayFword 和 person2下的sayFword 是两个不同的方法person1.sayFword === person2.sayFword //false 而我们想要让某一些方法成为该类型的所有实例共用的, 而不是每创建一个实例就去创建一个同样的方法/属性于是, 群众又想出了下一个模式, 原型模式 3. 原型模式原型模式的思想是, 给构造函数 (实际上只要是函数) 赋予一个 prototype 属性 , 这个属性的值是一个指针, 指向一个对象, 而这个对象包含其所有实例共享的属性和方法 1234567891011function Person() &#123;&#125;Person.prototype.name = &#x27;Tony Stark&#x27;Person.prototype.job = &#x27;Iron Man&#x27;// 口吐芬芳Person.prototype.sayFword = function () &#123; alert(&#x27;Funny&#x27;)&#125;// 创建实例var person1 = new Person()var person2 = new Person()person1.sayName === person2.sayName // true 默认情况下 prototype 会自动获得 constructor 属性, 该属性指向构造函数本身 1Person.prototype.constructor === Person // true 如果实例中定义了跟 prototype 重名的属性, 会怎么样呢 1234var person3 = new Person()person3.name = &#x27;灭霸&#x27;console.log(person3.name) //&#x27;灭霸&#x27;console.log(Person.prototype.name) // &#x27;Tony Stark&#x27; 很明显, 原型上的同名属性并不会受到影响我们可以用 delete 操作符删除对实例的属性, 从而重新访问原型中的属性 12delete person3.nameconsole.log(person3.name) // &#x27;Tony Stark&#x27; 需要注意的是, 使用 in 操作符, 即使属性是在原型上, 也会返回 true (for in 亦是如此) 1&#x27;job&#x27; in person3 //true 单纯的原型模式, 也是有缺点的, 例如 123456789function Person() &#123;&#125;Person.prototype = &#123; friends: [1, 2],&#125;// 创建实例var person1 = new Person()var person2 = new Person()person1.friends.push(3)console.log(person2.friends) // 1,2,3 如果共享的属性为引用类型, 修改实例该属性时, 会影响到原型上的该属性, 从而影响到其他实例这个问题可以用 组合构造函数和原型模式 来解决 4. 组合构造函数和原型模式构造函数模式用于定义实例的属性, 而原型模式用于定义方法和共享属性 , 集两家之所长 123456789101112131415function Person(name, job, friends) &#123; this.name = name this.job = job this.friends = friends&#125;// 口吐芬芳Person.prototype.sayFword = function () &#123; alert(&#x27;Funny&#x27;)&#125;// 创建实例var person1 = new Person(&#x27;Tony Stark&#x27;, &#x27;Iron Man&#x27;, [1, 2])var person2 = new Person(&#x27;王进喜&#x27;, &#x27;铁人&#x27;, [3, 4])person1.sayFword === person2.sayFword // trueperson1.friends.push(3)console.log(person2.friends) // 3, 4 5. 动态原型模式这种模式多了一层判断 123456789function Person(name, age) &#123; this.name = name this.age = age if (typeof this.sayFword != &#x27;function&#x27;) &#123; Person.prototype.sayFword = function () &#123; alert(this.name) &#125; &#125;&#125; 那么, 这样做的优点在哪呢 ? 想想看, 如果没有 if 的话，每 new 一次，都会重新定义一个新的函数，然后挂到 Person.prototype.sayFword 属性上, 这就造成没必要的时间和空间浪费 。加上 if 后，只在 new 第一个实例时才会定义 sayFword 方法，之后就不会了 。并且 ————if语句检查的可以是初始化之后应该存在的任何属性或方法 —— 不必用一大堆if语句检查每个属性和每个方法，只要检查其中一个即可。———— 什么意思呢 ？是这样的：假设除了 sayFword 方法外，还定义了其他方法，比如 sayHi、sayBye 等等。此时只需要把它们都放到对 sayFword 判断的 if 块里面就可以了 123456if (typeof this.sayFword != &quot;function&quot;) &#123; Person.prototype.sayFword = function() &#123;...&#125;; Person.prototype.sayHi = function() &#123;...&#125;; Person.prototype.sayBye = function() &#123;...&#125;; ...&#125; 这样一来，要么它们全都还没有定义(new 第一个实例时)，要么已经全都定义了(new 其他实例后)，即它们的存在性是一致的，用同一个判断就可以了，而不需要分别对它们进行判断。 6. 寄生构造函数模式12345678910function SpecialArray() &#123; var values = new Array() // 结构 arguments 拼接数组 ,在es6中不用这样写, 直接 value.push(...arguments) values.push.apply(values, arguments) // 此方法 将数组用|分隔拼接成字符串返回 values.toPipedString = function () &#123; return this.join(&#x27;|&#x27;) &#125; return values&#125; 虽然它写的和工厂模式一样，但是创建时用了 new，因此使得实现的过程不一样（但是实现过程不重要)作用嘛, 比如创建具有额外方法的已有类型（如数组，Date 类型等，但是又想不污染原有的类型 ;例如上面如果直接在 Array 中定义新的方法，会污染其它的数组对象, 于是创建了一个 SpecialArray 类型, 它包含了 Array 的所有方法, 又有自己的方法 toPipedString ; 7. 稳妥构造函数模式稳妥对象指没有公共属性，而且其他方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者防止数据被其他应用程序改动时使用 . 1234567891011function Persion(name, age, job) &#123; // 创建要返回的对象 var o = new Object() // 添加方法 o.sayName = function () &#123; alert(name) &#125; return o&#125;var p1 = Persion(&#x27;bill&#x27;, 23, &#x27;FE&#x27;)p1.sayName() // bill; 除了了调用 sayName()外，没有别的方式可以访问其他数据成员。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"}]}],"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://laputaz.github.io/home/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://laputaz.github.io/home/tags/%E5%9F%BA%E7%A1%80/"},{"name":"手写","slug":"手写","permalink":"https://laputaz.github.io/home/tags/%E6%89%8B%E5%86%99/"},{"name":"算法","slug":"算法","permalink":"https://laputaz.github.io/home/tags/%E7%AE%97%E6%B3%95/"},{"name":"回顾","slug":"回顾","permalink":"https://laputaz.github.io/home/tags/%E5%9B%9E%E9%A1%BE/"},{"name":"踩坑","slug":"踩坑","permalink":"https://laputaz.github.io/home/tags/%E8%B8%A9%E5%9D%91/"},{"name":"人工智能","slug":"人工智能","permalink":"https://laputaz.github.io/home/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"ai","slug":"ai","permalink":"https://laputaz.github.io/home/tags/ai/"},{"name":"方案设计","slug":"方案设计","permalink":"https://laputaz.github.io/home/tags/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"},{"name":"sem","slug":"sem","permalink":"https://laputaz.github.io/home/tags/sem/"},{"name":"二进制","slug":"二进制","permalink":"https://laputaz.github.io/home/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"css","slug":"css","permalink":"https://laputaz.github.io/home/tags/css/"},{"name":"进制","slug":"进制","permalink":"https://laputaz.github.io/home/tags/%E8%BF%9B%E5%88%B6/"},{"name":"vue","slug":"vue","permalink":"https://laputaz.github.io/home/tags/vue/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://laputaz.github.io/home/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"},{"name":"AB Testing","slug":"AB-Testing","permalink":"https://laputaz.github.io/home/tags/AB-Testing/"},{"name":"npm","slug":"npm","permalink":"https://laputaz.github.io/home/tags/npm/"},{"name":"lerna","slug":"lerna","permalink":"https://laputaz.github.io/home/tags/lerna/"},{"name":"包管理","slug":"包管理","permalink":"https://laputaz.github.io/home/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"},{"name":"hook","slug":"hook","permalink":"https://laputaz.github.io/home/tags/hook/"},{"name":"俄语笔记","slug":"俄语笔记","permalink":"https://laputaz.github.io/home/tags/%E4%BF%84%E8%AF%AD%E7%AC%94%E8%AE%B0/"},{"name":"yarn","slug":"yarn","permalink":"https://laputaz.github.io/home/tags/yarn/"},{"name":"实现","slug":"实现","permalink":"https://laputaz.github.io/home/tags/%E5%AE%9E%E7%8E%B0/"},{"name":"websocket","slug":"websocket","permalink":"https://laputaz.github.io/home/tags/websocket/"},{"name":"问题","slug":"问题","permalink":"https://laputaz.github.io/home/tags/%E9%97%AE%E9%A2%98/"},{"name":"webpack","slug":"webpack","permalink":"https://laputaz.github.io/home/tags/webpack/"},{"name":"网络","slug":"网络","permalink":"https://laputaz.github.io/home/tags/%E7%BD%91%E7%BB%9C/"},{"name":"浏览器","slug":"浏览器","permalink":"https://laputaz.github.io/home/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"排序","slug":"排序","permalink":"https://laputaz.github.io/home/tags/%E6%8E%92%E5%BA%8F/"},{"name":"shell","slug":"shell","permalink":"https://laputaz.github.io/home/tags/shell/"},{"name":"网络安全","slug":"网络安全","permalink":"https://laputaz.github.io/home/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"小程序","slug":"小程序","permalink":"https://laputaz.github.io/home/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"跨端","slug":"跨端","permalink":"https://laputaz.github.io/home/tags/%E8%B7%A8%E7%AB%AF/"}]}